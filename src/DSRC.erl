%% Generated by the Erlang ASN.1 PER (unaligned) compiler. Version: 5.0.9
%% Purpose: Encoding and decoding of the types in DSRC.

-module('DSRC').
-compile(nowarn_unused_vars).
-dialyzer(no_improper_lists).
-asn1_info([{vsn,'5.0.9'},
            {module,'DSRC'},
            {options,[{i,"src"},maps,uper,noobj,{outdir,"src"},{i,"."},{i,"asn1"}]}]).

-export([encoding_rule/0,maps/0,bit_string_format/0,
         legacy_erlang_types/0]).
-export(['dialyzer-suppressions'/1]).
-export([
enc_MessageFrame/1,
enc_BasicSafetyMessage/1,
'enc_PartII-Id'/1,
enc_CommonSafetyRequest/1,
enc_EmergencyVehicleAlert/1,
enc_IntersectionCollision/1,
enc_MapData/1,
enc_NMEAcorrections/1,
enc_PersonalSafetyMessage/1,
enc_ProbeDataManagement/1,
enc_ProbeVehicleData/1,
enc_RoadSideAlert/1,
enc_RTCMcorrections/1,
enc_SPAT/1,
enc_SignalRequestMessage/1,
enc_SignalStatusMessage/1,
enc_TravelerInformation/1,
enc_TestMessage00/1,
enc_TestMessage01/1,
enc_TestMessage02/1,
enc_TestMessage03/1,
enc_TestMessage04/1,
enc_TestMessage05/1,
enc_TestMessage06/1,
enc_TestMessage07/1,
enc_TestMessage08/1,
enc_TestMessage09/1,
enc_TestMessage10/1,
enc_TestMessage11/1,
enc_TestMessage12/1,
enc_TestMessage13/1,
enc_TestMessage14/1,
enc_TestMessage15/1,
enc_AccelerationSet4Way/1,
enc_AccelSteerYawRateConfidence/1,
enc_AdvisorySpeed/1,
enc_AdvisorySpeedList/1,
enc_AntennaOffsetSet/1,
enc_ApproachOrLane/1,
enc_BrakeSystemStatus/1,
enc_BSMcoreData/1,
enc_BumperHeights/1,
enc_Circle/1,
enc_ComputedLane/1,
enc_ConfidenceSet/1,
enc_ConnectingLane/1,
enc_Connection/1,
enc_ConnectionManeuverAssist/1,
enc_ConnectsToList/1,
enc_DataParameters/1,
enc_DDate/1,
enc_DDateTime/1,
enc_DFullTime/1,
enc_DMonthDay/1,
enc_DTime/1,
enc_DYearMonth/1,
enc_DisabledVehicle/1,
enc_EmergencyDetails/1,
enc_EnabledLaneList/1,
enc_EventDescription/1,
enc_FullPositionVector/1,
enc_GenericLane/1,
enc_GeographicalPath/1,
enc_GeometricProjection/1,
enc_Header/1,
enc_IntersectionAccessPoint/1,
enc_IntersectionGeometry/1,
enc_IntersectionGeometryList/1,
enc_IntersectionReferenceID/1,
enc_IntersectionState/1,
enc_IntersectionStateList/1,
enc_ExitService/1,
enc_GenericSignage/1,
enc_SpeedLimit/1,
enc_WorkZone/1,
enc_J1939data/1,
enc_TireDataList/1,
enc_TireData/1,
enc_AxleWeightList/1,
enc_AxleWeightSet/1,
enc_LaneAttributes/1,
enc_LaneDataAttribute/1,
enc_LaneDataAttributeList/1,
enc_LaneList/1,
enc_LaneTypeAttributes/1,
enc_ManeuverAssistList/1,
enc_MovementEventList/1,
enc_MovementEvent/1,
enc_MovementList/1,
enc_MovementState/1,
'enc_Node-LL-24B'/1,
'enc_Node-LL-28B'/1,
'enc_Node-LL-32B'/1,
'enc_Node-LL-36B'/1,
'enc_Node-LL-44B'/1,
'enc_Node-LL-48B'/1,
'enc_Node-LLmD-64b'/1,
'enc_Node-XY-20b'/1,
'enc_Node-XY-22b'/1,
'enc_Node-XY-24b'/1,
'enc_Node-XY-26b'/1,
'enc_Node-XY-28b'/1,
'enc_Node-XY-32b'/1,
enc_NodeAttributeLLList/1,
enc_NodeAttributeSetLL/1,
enc_NodeAttributeSetXY/1,
enc_NodeAttributeXYList/1,
enc_NodeListLL/1,
enc_NodeListXY/1,
enc_NodeLL/1,
enc_NodeOffsetPointLL/1,
enc_NodeOffsetPointXY/1,
enc_NodeSetLL/1,
enc_NodeSetXY/1,
enc_NodeXY/1,
enc_ObstacleDetection/1,
enc_OffsetSystem/1,
enc_OverlayLaneList/1,
enc_PathHistory/1,
enc_PathHistoryPointList/1,
enc_PathHistoryPoint/1,
enc_PathPrediction/1,
enc_PivotPointDescription/1,
enc_Position3D/1,
enc_PositionalAccuracy/1,
enc_PositionConfidenceSet/1,
enc_PreemptPriorityList/1,
enc_SignalControlZone/1,
enc_PrivilegedEvents/1,
enc_PropelledInformation/1,
enc_RegionList/1,
enc_RegionOffsets/1,
enc_RegionPointSet/1,
enc_RegulatorySpeedLimit/1,
enc_RequestedItemList/1,
enc_RequestorDescription/1,
enc_RequestorPositionVector/1,
enc_RequestorType/1,
enc_RestrictionClassAssignment/1,
enc_RestrictionClassList/1,
enc_RestrictionUserTypeList/1,
enc_RestrictionUserType/1,
enc_RoadLaneSetList/1,
enc_RoadSegmentList/1,
enc_RoadSegmentReferenceID/1,
enc_RoadSegment/1,
enc_RoadSignID/1,
enc_RTCMheader/1,
enc_RTCMmessageList/1,
enc_RTCMPackage/1,
enc_Sample/1,
enc_SegmentAttributeLLList/1,
enc_SegmentAttributeXYList/1,
enc_ShapePointSet/1,
enc_SignalRequesterInfo/1,
enc_SignalRequestList/1,
enc_SignalRequestPackage/1,
enc_SignalRequest/1,
enc_SignalStatusList/1,
enc_SignalStatusPackageList/1,
enc_SignalStatusPackage/1,
enc_SignalStatus/1,
enc_SnapshotDistance/1,
enc_Snapshot/1,
enc_SnapshotTime/1,
enc_SpecialVehicleExtensions/1,
enc_SpeedandHeadingandThrottleConfidence/1,
enc_SpeedLimitList/1,
enc_SpeedProfileMeasurementList/1,
enc_SpeedProfile/1,
enc_SupplementalVehicleExtensions/1,
enc_TimeChangeDetails/1,
enc_TrailerData/1,
enc_TrailerHistoryPointList/1,
enc_TrailerHistoryPoint/1,
enc_TrailerUnitDescriptionList/1,
enc_TrailerUnitDescription/1,
enc_TransmissionAndSpeed/1,
enc_TravelerDataFrameList/1,
enc_TravelerDataFrame/1,
enc_ValidRegion/1,
enc_VehicleClassification/1,
enc_VehicleData/1,
enc_VehicleIdent/1,
enc_VehicleID/1,
enc_VehicleSafetyExtensions/1,
enc_VehicleSize/1,
enc_VehicleStatusRequest/1,
enc_VehicleStatusRequestList/1,
enc_VehicleStatus/1,
enc_VerticalOffset/1,
enc_WeatherProbe/1,
enc_WeatherReport/1,
enc_WiperSet/1,
enc_Acceleration/1,
enc_AccelerationConfidence/1,
enc_AdvisorySpeedType/1,
enc_AllowedManeuvers/1,
enc_AmbientAirPressure/1,
enc_AmbientAirTemperature/1,
enc_Angle/1,
enc_AnimalPropelledType/1,
enc_AnimalType/1,
enc_AntiLockBrakeStatus/1,
enc_ApproachID/1,
enc_Attachment/1,
enc_AttachmentRadius/1,
enc_AuxiliaryBrakeStatus/1,
enc_BasicVehicleClass/1,
enc_BasicVehicleRole/1,
enc_Binary_Id/1,
enc_Binary_Id/2,
enc_BrakeAppliedPressure/1,
enc_BrakeAppliedStatus/1,
enc_BrakeBoostApplied/1,
enc_BumperHeight/1,
enc_CoarseHeading/1,
enc_CodeWord/1,
enc_CoefficientOfFriction/1,
enc_Confidence/1,
enc_Count/1,
enc_DDay/1,
enc_DeltaAngle/1,
enc_DeltaTime/1,
enc_DescriptiveName/1,
enc_DHour/1,
enc_DirectionOfUse/1,
enc_DistanceUnits/1,
enc_DMinute/1,
enc_DMonth/1,
enc_DOffset/1,
enc_DrivenLineOffsetLg/1,
enc_DrivenLineOffsetSm/1,
enc_DrivingWheelAngle/1,
enc_DSecond/1,
enc_DSRCmsgID/1,
enc_Duration/1,
enc_DYear/1,
enc_ElevationConfidence/1,
enc_Elevation/1,
enc_Extent/1,
enc_ExteriorLights/1,
enc_FuelType/1,
enc_FurtherInfoID/1,
enc_GNSSstatus/1,
enc_GrossDistance/1,
enc_GrossSpeed/1,
enc_HeadingConfidence/1,
enc_Heading/1,
enc_HeadingSlice/1,
enc_IntersectionID/1,
enc_IntersectionStatusObject/1,
enc_IsDolly/1,
enc_Iso3833VehicleType/1,
enc_ITIStextPhrase/1,
enc_AxleLocation/1,
enc_AxleWeight/1,
enc_CargoWeight/1,
enc_DriveAxleLiftAirPressure/1,
enc_DriveAxleLocation/1,
enc_DriveAxleLubePressure/1,
enc_DriveAxleTemperature/1,
enc_SteeringAxleLubePressure/1,
enc_SteeringAxleTemperature/1,
enc_TireLeakageRate/1,
enc_TireLocation/1,
enc_TirePressureThresholdDetection/1,
enc_TirePressure/1,
enc_TireTemp/1,
enc_TrailerWeight/1,
enc_WheelEndElectFault/1,
enc_WheelSensorStatus/1,
'enc_LaneAttributes-Barrier'/1,
'enc_LaneAttributes-Bike'/1,
'enc_LaneAttributes-Crosswalk'/1,
'enc_LaneAttributes-Parking'/1,
'enc_LaneAttributes-Sidewalk'/1,
'enc_LaneAttributes-Striping'/1,
'enc_LaneAttributes-TrackedVehicle'/1,
'enc_LaneAttributes-Vehicle'/1,
enc_LaneConnectionID/1,
enc_LaneDirection/1,
enc_LaneID/1,
enc_LaneSharing/1,
enc_LaneWidth/1,
enc_Latitude/1,
enc_LayerID/1,
enc_LayerType/1,
enc_LightbarInUse/1,
enc_Longitude/1,
'enc_Location-quality'/1,
'enc_Location-tech'/1,
enc_MergeDivergeNodeAngle/1,
enc_MessageBLOB/1,
enc_MinuteOfTheYear/1,
enc_MinutesDuration/1,
enc_MotorizedPropelledType/1,
enc_MovementPhaseState/1,
enc_MsgCount/1,
enc_MsgCRC/1,
enc_MultiVehicleResponse/1,
enc_MUTCDCode/1,
'enc_NMEA-MsgType'/1,
'enc_NMEA-Payload'/1,
'enc_NMEA-Revision'/1,
enc_NodeAttributeLL/1,
enc_NodeAttributeXY/1,
enc_NumberOfParticipantsInCluster/1,
enc_ObjectCount/1,
enc_ObstacleDirection/1,
enc_ObstacleDistance/1,
'enc_Offset-B09'/1,
'enc_Offset-B10'/1,
'enc_Offset-B11'/1,
'enc_Offset-B12'/1,
'enc_Offset-B13'/1,
'enc_Offset-B14'/1,
'enc_Offset-B16'/1,
'enc_OffsetLL-B12'/1,
'enc_OffsetLL-B14'/1,
'enc_OffsetLL-B16'/1,
'enc_OffsetLL-B18'/1,
'enc_OffsetLL-B22'/1,
'enc_OffsetLL-B24'/1,
enc_PayloadData/1,
enc_PedestrianBicycleDetect/1,
enc_HumanPropelledType/1,
enc_PersonalAssistive/1,
enc_PersonalClusterRadius/1,
enc_PersonalCrossingInProgress/1,
enc_PersonalCrossingRequest/1,
enc_PersonalDeviceUsageState/1,
enc_PersonalDeviceUserType/1,
enc_PivotingAllowed/1,
enc_PositionConfidence/1,
enc_PrioritizationResponseStatus/1,
enc_Priority/1,
enc_PriorityRequestType/1,
enc_PrivilegedEventFlags/1,
enc_ProbeSegmentNumber/1,
enc_PublicSafetyAndRoadWorkerActivity/1,
enc_PublicSafetyDirectingTrafficSubType/1,
enc_PublicSafetyEventResponderWorkerType/1,
enc_RadiusOfCurvature/1,
'enc_Radius-B12'/1,
enc_RainSensor/1,
enc_RegionId/1,
enc_RequestedItem/1,
enc_RequestID/1,
enc_RequestImportanceLevel/1,
enc_RequestSubRole/1,
enc_ResponseType/1,
enc_RestrictionAppliesTo/1,
enc_RestrictionClassID/1,
enc_RoadRegulatorID/1,
enc_RoadSegmentID/1,
enc_RoadwayCrownAngle/1,
'enc_RTCM-Revision'/1,
enc_RTCMmessage/1,
'enc_Scale-B12'/1,
enc_SecondOfTime/1,
enc_SegmentAttributeLL/1,
enc_SegmentAttributeXY/1,
enc_SemiMajorAxisAccuracy/1,
enc_SemiMajorAxisOrientation/1,
enc_SemiMinorAxisAccuracy/1,
enc_SignalGroupID/1,
enc_SignalReqScheme/1,
enc_SignPrority/1,
enc_SirenInUse/1,
enc_SpeedAdvice/1,
enc_SpeedConfidence/1,
enc_SpeedLimitType/1,
enc_SpeedProfileMeasurement/1,
enc_Speed/1,
enc_SSPindex/1,
enc_StabilityControlStatus/1,
enc_StationID/1,
enc_SteeringWheelAngleConfidence/1,
enc_SteeringWheelAngleRateOfChange/1,
enc_SteeringWheelAngle/1,
enc_SunSensor/1,
enc_TemporaryID/1,
enc_TermDistance/1,
enc_TermTime/1,
enc_ThrottleConfidence/1,
enc_ThrottlePosition/1,
enc_TimeConfidence/1,
enc_TimeIntervalConfidence/1,
enc_TimeMark/1,
enc_TimeOffset/1,
enc_TractionControlStatus/1,
enc_TrailerMass/1,
enc_TransitStatus/1,
enc_TransitVehicleOccupancy/1,
enc_TransitVehicleStatus/1,
enc_TransmissionState/1,
enc_TravelerInfoType/1,
enc_UniqueMSGID/1,
'enc_URL-Base'/1,
'enc_URL-Link'/1,
'enc_URL-Short'/1,
enc_UserSizeAndBehaviour/1,
enc_VehicleEventFlags/1,
enc_VehicleHeight/1,
enc_VehicleLength/1,
enc_VehicleMass/1,
enc_VehicleStatusDeviceTypeTag/1,
enc_VehicleType/1,
enc_VehicleWidth/1,
enc_Velocity/1,
enc_VerticalAccelerationThreshold/1,
enc_VerticalAcceleration/1,
'enc_VertOffset-B07'/1,
'enc_VertOffset-B08'/1,
'enc_VertOffset-B09'/1,
'enc_VertOffset-B10'/1,
'enc_VertOffset-B11'/1,
'enc_VertOffset-B12'/1,
enc_VINstring/1,
enc_WaitOnStopline/1,
enc_WiperRate/1,
enc_WiperStatus/1,
enc_YawRateConfidence/1,
enc_YawRate/1,
enc_ZoneLength/1,
enc_Zoom/1
]).

-export([
dec_MessageFrame/1,
dec_BasicSafetyMessage/1,
'dec_PartII-Id'/1,
dec_CommonSafetyRequest/1,
dec_EmergencyVehicleAlert/1,
dec_IntersectionCollision/1,
dec_MapData/1,
dec_NMEAcorrections/1,
dec_PersonalSafetyMessage/1,
dec_ProbeDataManagement/1,
dec_ProbeVehicleData/1,
dec_RoadSideAlert/1,
dec_RTCMcorrections/1,
dec_SPAT/1,
dec_SignalRequestMessage/1,
dec_SignalStatusMessage/1,
dec_TravelerInformation/1,
dec_TestMessage00/1,
dec_TestMessage01/1,
dec_TestMessage02/1,
dec_TestMessage03/1,
dec_TestMessage04/1,
dec_TestMessage05/1,
dec_TestMessage06/1,
dec_TestMessage07/1,
dec_TestMessage08/1,
dec_TestMessage09/1,
dec_TestMessage10/1,
dec_TestMessage11/1,
dec_TestMessage12/1,
dec_TestMessage13/1,
dec_TestMessage14/1,
dec_TestMessage15/1,
dec_AccelerationSet4Way/1,
dec_AccelSteerYawRateConfidence/1,
dec_AdvisorySpeed/1,
dec_AdvisorySpeedList/1,
dec_AntennaOffsetSet/1,
dec_ApproachOrLane/1,
dec_Binary_Id/1,
dec_BrakeSystemStatus/1,
dec_BSMcoreData/1,
dec_BumperHeights/1,
dec_Circle/1,
dec_ComputedLane/1,
dec_ConfidenceSet/1,
dec_ConnectingLane/1,
dec_Connection/1,
dec_ConnectionManeuverAssist/1,
dec_ConnectsToList/1,
dec_DataParameters/1,
dec_DDate/1,
dec_DDateTime/1,
dec_DFullTime/1,
dec_DMonthDay/1,
dec_DTime/1,
dec_DYearMonth/1,
dec_DisabledVehicle/1,
dec_EmergencyDetails/1,
dec_EnabledLaneList/1,
dec_EventDescription/1,
dec_FullPositionVector/1,
dec_GenericLane/1,
dec_GeographicalPath/1,
dec_GeometricProjection/1,
dec_Header/1,
dec_IntersectionAccessPoint/1,
dec_IntersectionGeometry/1,
dec_IntersectionGeometryList/1,
dec_IntersectionReferenceID/1,
dec_IntersectionState/1,
dec_IntersectionStateList/1,
dec_ExitService/1,
dec_GenericSignage/1,
dec_SpeedLimit/1,
dec_WorkZone/1,
dec_J1939data/1,
dec_TireDataList/1,
dec_TireData/1,
dec_AxleWeightList/1,
dec_AxleWeightSet/1,
dec_LaneAttributes/1,
dec_LaneDataAttribute/1,
dec_LaneDataAttributeList/1,
dec_LaneList/1,
dec_LaneTypeAttributes/1,
dec_ManeuverAssistList/1,
dec_MovementEventList/1,
dec_MovementEvent/1,
dec_MovementList/1,
dec_MovementState/1,
'dec_Node-LL-24B'/1,
'dec_Node-LL-28B'/1,
'dec_Node-LL-32B'/1,
'dec_Node-LL-36B'/1,
'dec_Node-LL-44B'/1,
'dec_Node-LL-48B'/1,
'dec_Node-LLmD-64b'/1,
'dec_Node-XY-20b'/1,
'dec_Node-XY-22b'/1,
'dec_Node-XY-24b'/1,
'dec_Node-XY-26b'/1,
'dec_Node-XY-28b'/1,
'dec_Node-XY-32b'/1,
dec_NodeAttributeLLList/1,
dec_NodeAttributeSetLL/1,
dec_NodeAttributeSetXY/1,
dec_NodeAttributeXYList/1,
dec_NodeListLL/1,
dec_NodeListXY/1,
dec_NodeLL/1,
dec_NodeOffsetPointLL/1,
dec_NodeOffsetPointXY/1,
dec_NodeSetLL/1,
dec_NodeSetXY/1,
dec_NodeXY/1,
dec_ObstacleDetection/1,
dec_OffsetSystem/1,
dec_OverlayLaneList/1,
dec_PathHistory/1,
dec_PathHistoryPointList/1,
dec_PathHistoryPoint/1,
dec_PathPrediction/1,
dec_PivotPointDescription/1,
dec_Position3D/1,
dec_PositionalAccuracy/1,
dec_PositionConfidenceSet/1,
dec_PreemptPriorityList/1,
dec_SignalControlZone/1,
dec_PrivilegedEvents/1,
dec_PropelledInformation/1,
dec_RegionList/1,
dec_RegionOffsets/1,
dec_RegionPointSet/1,
dec_RegulatorySpeedLimit/1,
dec_RequestedItemList/1,
dec_RequestorDescription/1,
dec_RequestorPositionVector/1,
dec_RequestorType/1,
dec_RestrictionClassAssignment/1,
dec_RestrictionClassList/1,
dec_RestrictionUserTypeList/1,
dec_RestrictionUserType/1,
dec_RoadLaneSetList/1,
dec_RoadSegmentList/1,
dec_RoadSegmentReferenceID/1,
dec_RoadSegment/1,
dec_RoadSignID/1,
dec_RTCMheader/1,
dec_RTCMmessageList/1,
dec_RTCMPackage/1,
dec_Sample/1,
dec_SegmentAttributeLLList/1,
dec_SegmentAttributeXYList/1,
dec_ShapePointSet/1,
dec_SignalRequesterInfo/1,
dec_SignalRequestList/1,
dec_SignalRequestPackage/1,
dec_SignalRequest/1,
dec_SignalStatusList/1,
dec_SignalStatusPackageList/1,
dec_SignalStatusPackage/1,
dec_SignalStatus/1,
dec_SnapshotDistance/1,
dec_Snapshot/1,
dec_SnapshotTime/1,
dec_SpecialVehicleExtensions/1,
dec_SpeedandHeadingandThrottleConfidence/1,
dec_SpeedLimitList/1,
dec_SpeedProfileMeasurementList/1,
dec_SpeedProfile/1,
dec_SupplementalVehicleExtensions/1,
dec_TimeChangeDetails/1,
dec_TrailerData/1,
dec_TrailerHistoryPointList/1,
dec_TrailerHistoryPoint/1,
dec_TrailerUnitDescriptionList/1,
dec_TrailerUnitDescription/1,
dec_TransmissionAndSpeed/1,
dec_TravelerDataFrameList/1,
dec_TravelerDataFrame/1,
dec_ValidRegion/1,
dec_VehicleClassification/1,
dec_VehicleData/1,
dec_VehicleIdent/1,
dec_VehicleID/1,
dec_VehicleSafetyExtensions/1,
dec_VehicleSize/1,
dec_VehicleStatusRequest/1,
dec_VehicleStatusRequestList/1,
dec_VehicleStatus/1,
dec_VerticalOffset/1,
dec_WeatherProbe/1,
dec_WeatherReport/1,
dec_WiperSet/1,
dec_Acceleration/1,
dec_AccelerationConfidence/1,
dec_AdvisorySpeedType/1,
dec_AllowedManeuvers/1,
dec_AmbientAirPressure/1,
dec_AmbientAirTemperature/1,
dec_Angle/1,
dec_AnimalPropelledType/1,
dec_AnimalType/1,
dec_AntiLockBrakeStatus/1,
dec_ApproachID/1,
dec_Attachment/1,
dec_AttachmentRadius/1,
dec_AuxiliaryBrakeStatus/1,
dec_BasicVehicleClass/1,
dec_BasicVehicleRole/1,
dec_BrakeAppliedPressure/1,
dec_BrakeAppliedStatus/1,
dec_BrakeBoostApplied/1,
dec_BumperHeight/1,
dec_CoarseHeading/1,
dec_CodeWord/1,
dec_CoefficientOfFriction/1,
dec_Confidence/1,
dec_Count/1,
dec_DDay/1,
dec_DeltaAngle/1,
dec_DeltaTime/1,
dec_DescriptiveName/1,
dec_DHour/1,
dec_DirectionOfUse/1,
dec_DistanceUnits/1,
dec_DMinute/1,
dec_DMonth/1,
dec_DOffset/1,
dec_DrivenLineOffsetLg/1,
dec_DrivenLineOffsetSm/1,
dec_DrivingWheelAngle/1,
dec_DSecond/1,
dec_DSRCmsgID/1,
dec_Duration/1,
dec_DYear/1,
dec_ElevationConfidence/1,
dec_Elevation/1,
dec_Extent/1,
dec_ExteriorLights/1,
dec_FuelType/1,
dec_FurtherInfoID/1,
dec_GNSSstatus/1,
dec_GrossDistance/1,
dec_GrossSpeed/1,
dec_HeadingConfidence/1,
dec_Heading/1,
dec_HeadingSlice/1,
dec_IntersectionID/1,
dec_IntersectionStatusObject/1,
dec_IsDolly/1,
dec_Iso3833VehicleType/1,
dec_ITIStextPhrase/1,
dec_AxleLocation/1,
dec_AxleWeight/1,
dec_CargoWeight/1,
dec_DriveAxleLiftAirPressure/1,
dec_DriveAxleLocation/1,
dec_DriveAxleLubePressure/1,
dec_DriveAxleTemperature/1,
dec_SteeringAxleLubePressure/1,
dec_SteeringAxleTemperature/1,
dec_TireLeakageRate/1,
dec_TireLocation/1,
dec_TirePressureThresholdDetection/1,
dec_TirePressure/1,
dec_TireTemp/1,
dec_TrailerWeight/1,
dec_WheelEndElectFault/1,
dec_WheelSensorStatus/1,
'dec_LaneAttributes-Barrier'/1,
'dec_LaneAttributes-Bike'/1,
'dec_LaneAttributes-Crosswalk'/1,
'dec_LaneAttributes-Parking'/1,
'dec_LaneAttributes-Sidewalk'/1,
'dec_LaneAttributes-Striping'/1,
'dec_LaneAttributes-TrackedVehicle'/1,
'dec_LaneAttributes-Vehicle'/1,
dec_LaneConnectionID/1,
dec_LaneDirection/1,
dec_LaneID/1,
dec_LaneSharing/1,
dec_LaneWidth/1,
dec_Latitude/1,
dec_LayerID/1,
dec_LayerType/1,
dec_LightbarInUse/1,
dec_Longitude/1,
'dec_Location-quality'/1,
'dec_Location-tech'/1,
dec_MergeDivergeNodeAngle/1,
dec_MessageBLOB/1,
dec_MinuteOfTheYear/1,
dec_MinutesDuration/1,
dec_MotorizedPropelledType/1,
dec_MovementPhaseState/1,
dec_MsgCount/1,
dec_MsgCRC/1,
dec_MultiVehicleResponse/1,
dec_MUTCDCode/1,
'dec_NMEA-MsgType'/1,
'dec_NMEA-Payload'/1,
'dec_NMEA-Revision'/1,
dec_NodeAttributeLL/1,
dec_NodeAttributeXY/1,
dec_NumberOfParticipantsInCluster/1,
dec_ObjectCount/1,
dec_ObstacleDirection/1,
dec_ObstacleDistance/1,
'dec_Offset-B09'/1,
'dec_Offset-B10'/1,
'dec_Offset-B11'/1,
'dec_Offset-B12'/1,
'dec_Offset-B13'/1,
'dec_Offset-B14'/1,
'dec_Offset-B16'/1,
'dec_OffsetLL-B12'/1,
'dec_OffsetLL-B14'/1,
'dec_OffsetLL-B16'/1,
'dec_OffsetLL-B18'/1,
'dec_OffsetLL-B22'/1,
'dec_OffsetLL-B24'/1,
dec_PayloadData/1,
dec_PedestrianBicycleDetect/1,
dec_HumanPropelledType/1,
dec_PersonalAssistive/1,
dec_PersonalClusterRadius/1,
dec_PersonalCrossingInProgress/1,
dec_PersonalCrossingRequest/1,
dec_PersonalDeviceUsageState/1,
dec_PersonalDeviceUserType/1,
dec_PivotingAllowed/1,
dec_PositionConfidence/1,
dec_PrioritizationResponseStatus/1,
dec_Priority/1,
dec_PriorityRequestType/1,
dec_PrivilegedEventFlags/1,
dec_ProbeSegmentNumber/1,
dec_PublicSafetyAndRoadWorkerActivity/1,
dec_PublicSafetyDirectingTrafficSubType/1,
dec_PublicSafetyEventResponderWorkerType/1,
dec_RadiusOfCurvature/1,
'dec_Radius-B12'/1,
dec_RainSensor/1,
dec_RegionId/1,
dec_RequestedItem/1,
dec_RequestID/1,
dec_RequestImportanceLevel/1,
dec_RequestSubRole/1,
dec_ResponseType/1,
dec_RestrictionAppliesTo/1,
dec_RestrictionClassID/1,
dec_RoadRegulatorID/1,
dec_RoadSegmentID/1,
dec_RoadwayCrownAngle/1,
'dec_RTCM-Revision'/1,
dec_RTCMmessage/1,
'dec_Scale-B12'/1,
dec_SecondOfTime/1,
dec_SegmentAttributeLL/1,
dec_SegmentAttributeXY/1,
dec_SemiMajorAxisAccuracy/1,
dec_SemiMajorAxisOrientation/1,
dec_SemiMinorAxisAccuracy/1,
dec_SignalGroupID/1,
dec_SignalReqScheme/1,
dec_SignPrority/1,
dec_SirenInUse/1,
dec_SpeedAdvice/1,
dec_SpeedConfidence/1,
dec_SpeedLimitType/1,
dec_SpeedProfileMeasurement/1,
dec_Speed/1,
dec_SSPindex/1,
dec_StabilityControlStatus/1,
dec_StationID/1,
dec_SteeringWheelAngleConfidence/1,
dec_SteeringWheelAngleRateOfChange/1,
dec_SteeringWheelAngle/1,
dec_SunSensor/1,
dec_TemporaryID/1,
dec_TermDistance/1,
dec_TermTime/1,
dec_ThrottleConfidence/1,
dec_ThrottlePosition/1,
dec_TimeConfidence/1,
dec_TimeIntervalConfidence/1,
dec_TimeMark/1,
dec_TimeOffset/1,
dec_TractionControlStatus/1,
dec_TrailerMass/1,
dec_TransitStatus/1,
dec_TransitVehicleOccupancy/1,
dec_TransitVehicleStatus/1,
dec_TransmissionState/1,
dec_TravelerInfoType/1,
dec_UniqueMSGID/1,
'dec_URL-Base'/1,
'dec_URL-Link'/1,
'dec_URL-Short'/1,
dec_UserSizeAndBehaviour/1,
dec_VehicleEventFlags/1,
dec_VehicleHeight/1,
dec_VehicleLength/1,
dec_VehicleMass/1,
dec_VehicleStatusDeviceTypeTag/1,
dec_VehicleType/1,
dec_VehicleWidth/1,
dec_Velocity/1,
dec_VerticalAccelerationThreshold/1,
dec_VerticalAcceleration/1,
'dec_VertOffset-B07'/1,
'dec_VertOffset-B08'/1,
'dec_VertOffset-B09'/1,
'dec_VertOffset-B10'/1,
'dec_VertOffset-B11'/1,
'dec_VertOffset-B12'/1,
dec_VINstring/1,
dec_WaitOnStopline/1,
dec_WiperRate/1,
dec_WiperStatus/1,
dec_YawRateConfidence/1,
dec_YawRate/1,
dec_ZoneLength/1,
dec_Zoom/1
]).

-export([
vehicleSafetyExt/0,
specialVehicleExt/0,
supplementalVehicleExt/0,
unknownVehicleClass/0,
specialVehicleClass/0,
'passenger-Vehicle-TypeUnknown'/0,
'passenger-Vehicle-TypeOther'/0,
'lightTruck-Vehicle-TypeUnknown'/0,
'lightTruck-Vehicle-TypeOther'/0,
'truck-Vehicle-TypeUnknown'/0,
'truck-Vehicle-TypeOther'/0,
'truck-axleCnt2'/0,
'truck-axleCnt3'/0,
'truck-axleCnt4'/0,
'truck-axleCnt4Trailer'/0,
'truck-axleCnt5Trailer'/0,
'truck-axleCnt6Trailer'/0,
'truck-axleCnt5MultiTrailer'/0,
'truck-axleCnt6MultiTrailer'/0,
'truck-axleCnt7MultiTrailer'/0,
'motorcycle-TypeUnknown'/0,
'motorcycle-TypeOther'/0,
'motorcycle-Cruiser-Standard'/0,
'motorcycle-SportUnclad'/0,
'motorcycle-SportTouring'/0,
'motorcycle-SuperSport'/0,
'motorcycle-Touring'/0,
'motorcycle-Trike'/0,
'motorcycle-wPassengers'/0,
'transit-TypeUnknown'/0,
'transit-TypeOther'/0,
'transit-BRT'/0,
'transit-ExpressBus'/0,
'transit-LocalBus'/0,
'transit-SchoolBus'/0,
'transit-FixedGuideway'/0,
'transit-Paratransit'/0,
'transit-Paratransit-Ambulance'/0,
'emergency-TypeUnknown'/0,
'emergency-TypeOther'/0,
'emergency-Fire-Light-Vehicle'/0,
'emergency-Fire-Heavy-Vehicle'/0,
'emergency-Fire-Paramedic-Vehicle'/0,
'emergency-Fire-Ambulance-Vehicle'/0,
'emergency-Police-Light-Vehicle'/0,
'emergency-Police-Heavy-Vehicle'/0,
'emergency-Other-Responder'/0,
'emergency-Other-Ambulance'/0,
'otherTraveler-TypeUnknown'/0,
'otherTraveler-TypeOther'/0,
'otherTraveler-Pedestrian'/0,
'otherTraveler-Visually-Disabled'/0,
'otherTraveler-Physically-Disabled'/0,
'otherTraveler-Bicycle'/0,
'otherTraveler-Vulnerable-Roadworker'/0,
'infrastructure-TypeUnknown'/0,
'infrastructure-Fixed'/0,
'infrastructure-Movable'/0,
'equipped-CargoTrailer'/0,
'reservedMessageId-D'/0,
'alaCarteMessage-D'/0,
'basicSafetyMessage-D'/0,
'basicSafetyMessageVerbose-D'/0,
'commonSafetyRequest-D'/0,
'emergencyVehicleAlert-D'/0,
'intersectionCollision-D'/0,
'mapData-D'/0,
'nmeaCorrections-D'/0,
'probeDataManagement-D'/0,
'probeVehicleData-D'/0,
'roadSideAlert-D'/0,
'rtcmCorrections-D'/0,
'signalPhaseAndTimingMessage-D'/0,
'signalRequestMessage-D'/0,
'signalStatusMessage-D'/0,
'travelerInformation-D'/0,
'uperFrame-D'/0,
mapData/0,
signalPhaseAndTimingMessage/0,
basicSafetyMessage/0,
commonSafetyRequest/0,
emergencyVehicleAlert/0,
intersectionCollision/0,
nmeaCorrections/0,
probeDataManagement/0,
probeVehicleData/0,
roadSideAlert/0,
rtcmCorrections/0,
signalRequestMessage/0,
signalStatusMessage/0,
travelerInformation/0,
personalSafetyMessage/0,
testMessage00/0,
testMessage01/0,
testMessage02/0,
testMessage03/0,
testMessage04/0,
testMessage05/0,
testMessage06/0,
testMessage07/0,
testMessage08/0,
testMessage09/0,
testMessage10/0,
testMessage11/0,
testMessage12/0,
testMessage13/0,
testMessage14/0,
testMessage15/0,
unknownFuel/0,
gasoline/0,
ethanol/0,
diesel/0,
electric/0,
hybrid/0,
hydrogen/0,
natGasLiquid/0,
natGasComp/0,
propane/0,
noRegion/0,
addGrpA/0,
addGrpB/0,
addGrpC/0
]).

-export([info/0]).

-export([encode/2,decode/2]).

encoding_rule() -> uper.

maps() -> true.

bit_string_format() -> bitstring.

legacy_erlang_types() -> false.

encode(Type, Data) ->
try complete(encode_disp(Type, Data)) of
  Bytes ->
    {ok,Bytes}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.

decode(Type, Data) ->
try
   {Result,_Rest} = decode_disp(Type, Data),
   {ok,Result}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.

enc_Binary_Id(Val) -> enc_Binary_Id(Val, 4).
enc_Binary_Id(Val, Length) ->
    if
        is_integer(Val) ->
            Encoded_Id = binary:encode_unsigned(Val),
            Padding = (Length - byte_size(Encoded_Id)) * 8,
            <<0:Padding,Encoded_Id/binary>>;
        is_bitstring(Val) ->
            Encoded@len = byte_size(Val),
            if Encoded@len =:= Length ->
                Val
            end
    end.

dec_Binary_Id(Val) ->
    BitPadding = 8 - (bit_size(Val) rem 8),
    ValAsBin = <<0:BitPadding, Val/bits>>,
    binary:decode_unsigned(ValAsBin).

encode_disp('MessageFrame', Data) -> enc_MessageFrame(Data);
encode_disp('BasicSafetyMessage', Data) -> enc_BasicSafetyMessage(Data);
encode_disp('PartII-Id', Data) -> 'enc_PartII-Id'(Data);
encode_disp('CommonSafetyRequest', Data) -> enc_CommonSafetyRequest(Data);
encode_disp('EmergencyVehicleAlert', Data) -> enc_EmergencyVehicleAlert(Data);
encode_disp('IntersectionCollision', Data) -> enc_IntersectionCollision(Data);
encode_disp('MapData', Data) -> enc_MapData(Data);
encode_disp('NMEAcorrections', Data) -> enc_NMEAcorrections(Data);
encode_disp('PersonalSafetyMessage', Data) -> enc_PersonalSafetyMessage(Data);
encode_disp('ProbeDataManagement', Data) -> enc_ProbeDataManagement(Data);
encode_disp('ProbeVehicleData', Data) -> enc_ProbeVehicleData(Data);
encode_disp('RoadSideAlert', Data) -> enc_RoadSideAlert(Data);
encode_disp('RTCMcorrections', Data) -> enc_RTCMcorrections(Data);
encode_disp('SPAT', Data) -> enc_SPAT(Data);
encode_disp('SignalRequestMessage', Data) -> enc_SignalRequestMessage(Data);
encode_disp('SignalStatusMessage', Data) -> enc_SignalStatusMessage(Data);
encode_disp('TravelerInformation', Data) -> enc_TravelerInformation(Data);
encode_disp('TestMessage00', Data) -> enc_TestMessage00(Data);
encode_disp('TestMessage01', Data) -> enc_TestMessage01(Data);
encode_disp('TestMessage02', Data) -> enc_TestMessage02(Data);
encode_disp('TestMessage03', Data) -> enc_TestMessage03(Data);
encode_disp('TestMessage04', Data) -> enc_TestMessage04(Data);
encode_disp('TestMessage05', Data) -> enc_TestMessage05(Data);
encode_disp('TestMessage06', Data) -> enc_TestMessage06(Data);
encode_disp('TestMessage07', Data) -> enc_TestMessage07(Data);
encode_disp('TestMessage08', Data) -> enc_TestMessage08(Data);
encode_disp('TestMessage09', Data) -> enc_TestMessage09(Data);
encode_disp('TestMessage10', Data) -> enc_TestMessage10(Data);
encode_disp('TestMessage11', Data) -> enc_TestMessage11(Data);
encode_disp('TestMessage12', Data) -> enc_TestMessage12(Data);
encode_disp('TestMessage13', Data) -> enc_TestMessage13(Data);
encode_disp('TestMessage14', Data) -> enc_TestMessage14(Data);
encode_disp('TestMessage15', Data) -> enc_TestMessage15(Data);
encode_disp('AccelerationSet4Way', Data) -> enc_AccelerationSet4Way(Data);
encode_disp('AccelSteerYawRateConfidence', Data) -> enc_AccelSteerYawRateConfidence(Data);
encode_disp('AdvisorySpeed', Data) -> enc_AdvisorySpeed(Data);
encode_disp('AdvisorySpeedList', Data) -> enc_AdvisorySpeedList(Data);
encode_disp('AntennaOffsetSet', Data) -> enc_AntennaOffsetSet(Data);
encode_disp('ApproachOrLane', Data) -> enc_ApproachOrLane(Data);
encode_disp('BrakeSystemStatus', Data) -> enc_BrakeSystemStatus(Data);
encode_disp('BSMcoreData', Data) -> enc_BSMcoreData(Data);
encode_disp('BumperHeights', Data) -> enc_BumperHeights(Data);
encode_disp('Circle', Data) -> enc_Circle(Data);
encode_disp('ComputedLane', Data) -> enc_ComputedLane(Data);
encode_disp('ConfidenceSet', Data) -> enc_ConfidenceSet(Data);
encode_disp('ConnectingLane', Data) -> enc_ConnectingLane(Data);
encode_disp('Connection', Data) -> enc_Connection(Data);
encode_disp('ConnectionManeuverAssist', Data) -> enc_ConnectionManeuverAssist(Data);
encode_disp('ConnectsToList', Data) -> enc_ConnectsToList(Data);
encode_disp('DataParameters', Data) -> enc_DataParameters(Data);
encode_disp('DDate', Data) -> enc_DDate(Data);
encode_disp('DDateTime', Data) -> enc_DDateTime(Data);
encode_disp('DFullTime', Data) -> enc_DFullTime(Data);
encode_disp('DMonthDay', Data) -> enc_DMonthDay(Data);
encode_disp('DTime', Data) -> enc_DTime(Data);
encode_disp('DYearMonth', Data) -> enc_DYearMonth(Data);
encode_disp('DisabledVehicle', Data) -> enc_DisabledVehicle(Data);
encode_disp('EmergencyDetails', Data) -> enc_EmergencyDetails(Data);
encode_disp('EnabledLaneList', Data) -> enc_EnabledLaneList(Data);
encode_disp('EventDescription', Data) -> enc_EventDescription(Data);
encode_disp('FullPositionVector', Data) -> enc_FullPositionVector(Data);
encode_disp('GenericLane', Data) -> enc_GenericLane(Data);
encode_disp('GeographicalPath', Data) -> enc_GeographicalPath(Data);
encode_disp('GeometricProjection', Data) -> enc_GeometricProjection(Data);
encode_disp('Header', Data) -> enc_Header(Data);
encode_disp('IntersectionAccessPoint', Data) -> enc_IntersectionAccessPoint(Data);
encode_disp('IntersectionGeometry', Data) -> enc_IntersectionGeometry(Data);
encode_disp('IntersectionGeometryList', Data) -> enc_IntersectionGeometryList(Data);
encode_disp('IntersectionReferenceID', Data) -> enc_IntersectionReferenceID(Data);
encode_disp('IntersectionState', Data) -> enc_IntersectionState(Data);
encode_disp('IntersectionStateList', Data) -> enc_IntersectionStateList(Data);
encode_disp('ExitService', Data) -> enc_ExitService(Data);
encode_disp('GenericSignage', Data) -> enc_GenericSignage(Data);
encode_disp('SpeedLimit', Data) -> enc_SpeedLimit(Data);
encode_disp('WorkZone', Data) -> enc_WorkZone(Data);
encode_disp('J1939data', Data) -> enc_J1939data(Data);
encode_disp('TireDataList', Data) -> enc_TireDataList(Data);
encode_disp('TireData', Data) -> enc_TireData(Data);
encode_disp('AxleWeightList', Data) -> enc_AxleWeightList(Data);
encode_disp('AxleWeightSet', Data) -> enc_AxleWeightSet(Data);
encode_disp('LaneAttributes', Data) -> enc_LaneAttributes(Data);
encode_disp('LaneDataAttribute', Data) -> enc_LaneDataAttribute(Data);
encode_disp('LaneDataAttributeList', Data) -> enc_LaneDataAttributeList(Data);
encode_disp('LaneList', Data) -> enc_LaneList(Data);
encode_disp('LaneTypeAttributes', Data) -> enc_LaneTypeAttributes(Data);
encode_disp('ManeuverAssistList', Data) -> enc_ManeuverAssistList(Data);
encode_disp('MovementEventList', Data) -> enc_MovementEventList(Data);
encode_disp('MovementEvent', Data) -> enc_MovementEvent(Data);
encode_disp('MovementList', Data) -> enc_MovementList(Data);
encode_disp('MovementState', Data) -> enc_MovementState(Data);
encode_disp('Node-LL-24B', Data) -> 'enc_Node-LL-24B'(Data);
encode_disp('Node-LL-28B', Data) -> 'enc_Node-LL-28B'(Data);
encode_disp('Node-LL-32B', Data) -> 'enc_Node-LL-32B'(Data);
encode_disp('Node-LL-36B', Data) -> 'enc_Node-LL-36B'(Data);
encode_disp('Node-LL-44B', Data) -> 'enc_Node-LL-44B'(Data);
encode_disp('Node-LL-48B', Data) -> 'enc_Node-LL-48B'(Data);
encode_disp('Node-LLmD-64b', Data) -> 'enc_Node-LLmD-64b'(Data);
encode_disp('Node-XY-20b', Data) -> 'enc_Node-XY-20b'(Data);
encode_disp('Node-XY-22b', Data) -> 'enc_Node-XY-22b'(Data);
encode_disp('Node-XY-24b', Data) -> 'enc_Node-XY-24b'(Data);
encode_disp('Node-XY-26b', Data) -> 'enc_Node-XY-26b'(Data);
encode_disp('Node-XY-28b', Data) -> 'enc_Node-XY-28b'(Data);
encode_disp('Node-XY-32b', Data) -> 'enc_Node-XY-32b'(Data);
encode_disp('NodeAttributeLLList', Data) -> enc_NodeAttributeLLList(Data);
encode_disp('NodeAttributeSetLL', Data) -> enc_NodeAttributeSetLL(Data);
encode_disp('NodeAttributeSetXY', Data) -> enc_NodeAttributeSetXY(Data);
encode_disp('NodeAttributeXYList', Data) -> enc_NodeAttributeXYList(Data);
encode_disp('NodeListLL', Data) -> enc_NodeListLL(Data);
encode_disp('NodeListXY', Data) -> enc_NodeListXY(Data);
encode_disp('NodeLL', Data) -> enc_NodeLL(Data);
encode_disp('NodeOffsetPointLL', Data) -> enc_NodeOffsetPointLL(Data);
encode_disp('NodeOffsetPointXY', Data) -> enc_NodeOffsetPointXY(Data);
encode_disp('NodeSetLL', Data) -> enc_NodeSetLL(Data);
encode_disp('NodeSetXY', Data) -> enc_NodeSetXY(Data);
encode_disp('NodeXY', Data) -> enc_NodeXY(Data);
encode_disp('ObstacleDetection', Data) -> enc_ObstacleDetection(Data);
encode_disp('OffsetSystem', Data) -> enc_OffsetSystem(Data);
encode_disp('OverlayLaneList', Data) -> enc_OverlayLaneList(Data);
encode_disp('PathHistory', Data) -> enc_PathHistory(Data);
encode_disp('PathHistoryPointList', Data) -> enc_PathHistoryPointList(Data);
encode_disp('PathHistoryPoint', Data) -> enc_PathHistoryPoint(Data);
encode_disp('PathPrediction', Data) -> enc_PathPrediction(Data);
encode_disp('PivotPointDescription', Data) -> enc_PivotPointDescription(Data);
encode_disp('Position3D', Data) -> enc_Position3D(Data);
encode_disp('PositionalAccuracy', Data) -> enc_PositionalAccuracy(Data);
encode_disp('PositionConfidenceSet', Data) -> enc_PositionConfidenceSet(Data);
encode_disp('PreemptPriorityList', Data) -> enc_PreemptPriorityList(Data);
encode_disp('SignalControlZone', Data) -> enc_SignalControlZone(Data);
encode_disp('PrivilegedEvents', Data) -> enc_PrivilegedEvents(Data);
encode_disp('PropelledInformation', Data) -> enc_PropelledInformation(Data);
encode_disp('RegionList', Data) -> enc_RegionList(Data);
encode_disp('RegionOffsets', Data) -> enc_RegionOffsets(Data);
encode_disp('RegionPointSet', Data) -> enc_RegionPointSet(Data);
encode_disp('RegulatorySpeedLimit', Data) -> enc_RegulatorySpeedLimit(Data);
encode_disp('RequestedItemList', Data) -> enc_RequestedItemList(Data);
encode_disp('RequestorDescription', Data) -> enc_RequestorDescription(Data);
encode_disp('RequestorPositionVector', Data) -> enc_RequestorPositionVector(Data);
encode_disp('RequestorType', Data) -> enc_RequestorType(Data);
encode_disp('RestrictionClassAssignment', Data) -> enc_RestrictionClassAssignment(Data);
encode_disp('RestrictionClassList', Data) -> enc_RestrictionClassList(Data);
encode_disp('RestrictionUserTypeList', Data) -> enc_RestrictionUserTypeList(Data);
encode_disp('RestrictionUserType', Data) -> enc_RestrictionUserType(Data);
encode_disp('RoadLaneSetList', Data) -> enc_RoadLaneSetList(Data);
encode_disp('RoadSegmentList', Data) -> enc_RoadSegmentList(Data);
encode_disp('RoadSegmentReferenceID', Data) -> enc_RoadSegmentReferenceID(Data);
encode_disp('RoadSegment', Data) -> enc_RoadSegment(Data);
encode_disp('RoadSignID', Data) -> enc_RoadSignID(Data);
encode_disp('RTCMheader', Data) -> enc_RTCMheader(Data);
encode_disp('RTCMmessageList', Data) -> enc_RTCMmessageList(Data);
encode_disp('RTCMPackage', Data) -> enc_RTCMPackage(Data);
encode_disp('Sample', Data) -> enc_Sample(Data);
encode_disp('SegmentAttributeLLList', Data) -> enc_SegmentAttributeLLList(Data);
encode_disp('SegmentAttributeXYList', Data) -> enc_SegmentAttributeXYList(Data);
encode_disp('ShapePointSet', Data) -> enc_ShapePointSet(Data);
encode_disp('SignalRequesterInfo', Data) -> enc_SignalRequesterInfo(Data);
encode_disp('SignalRequestList', Data) -> enc_SignalRequestList(Data);
encode_disp('SignalRequestPackage', Data) -> enc_SignalRequestPackage(Data);
encode_disp('SignalRequest', Data) -> enc_SignalRequest(Data);
encode_disp('SignalStatusList', Data) -> enc_SignalStatusList(Data);
encode_disp('SignalStatusPackageList', Data) -> enc_SignalStatusPackageList(Data);
encode_disp('SignalStatusPackage', Data) -> enc_SignalStatusPackage(Data);
encode_disp('SignalStatus', Data) -> enc_SignalStatus(Data);
encode_disp('SnapshotDistance', Data) -> enc_SnapshotDistance(Data);
encode_disp('Snapshot', Data) -> enc_Snapshot(Data);
encode_disp('SnapshotTime', Data) -> enc_SnapshotTime(Data);
encode_disp('SpecialVehicleExtensions', Data) -> enc_SpecialVehicleExtensions(Data);
encode_disp('SpeedandHeadingandThrottleConfidence', Data) -> enc_SpeedandHeadingandThrottleConfidence(Data);
encode_disp('SpeedLimitList', Data) -> enc_SpeedLimitList(Data);
encode_disp('SpeedProfileMeasurementList', Data) -> enc_SpeedProfileMeasurementList(Data);
encode_disp('SpeedProfile', Data) -> enc_SpeedProfile(Data);
encode_disp('SupplementalVehicleExtensions', Data) -> enc_SupplementalVehicleExtensions(Data);
encode_disp('TimeChangeDetails', Data) -> enc_TimeChangeDetails(Data);
encode_disp('TrailerData', Data) -> enc_TrailerData(Data);
encode_disp('TrailerHistoryPointList', Data) -> enc_TrailerHistoryPointList(Data);
encode_disp('TrailerHistoryPoint', Data) -> enc_TrailerHistoryPoint(Data);
encode_disp('TrailerUnitDescriptionList', Data) -> enc_TrailerUnitDescriptionList(Data);
encode_disp('TrailerUnitDescription', Data) -> enc_TrailerUnitDescription(Data);
encode_disp('TransmissionAndSpeed', Data) -> enc_TransmissionAndSpeed(Data);
encode_disp('TravelerDataFrameList', Data) -> enc_TravelerDataFrameList(Data);
encode_disp('TravelerDataFrame', Data) -> enc_TravelerDataFrame(Data);
encode_disp('ValidRegion', Data) -> enc_ValidRegion(Data);
encode_disp('VehicleClassification', Data) -> enc_VehicleClassification(Data);
encode_disp('VehicleData', Data) -> enc_VehicleData(Data);
encode_disp('VehicleIdent', Data) -> enc_VehicleIdent(Data);
encode_disp('VehicleID', Data) -> enc_VehicleID(Data);
encode_disp('VehicleSafetyExtensions', Data) -> enc_VehicleSafetyExtensions(Data);
encode_disp('VehicleSize', Data) -> enc_VehicleSize(Data);
encode_disp('VehicleStatusRequest', Data) -> enc_VehicleStatusRequest(Data);
encode_disp('VehicleStatusRequestList', Data) -> enc_VehicleStatusRequestList(Data);
encode_disp('VehicleStatus', Data) -> enc_VehicleStatus(Data);
encode_disp('VerticalOffset', Data) -> enc_VerticalOffset(Data);
encode_disp('WeatherProbe', Data) -> enc_WeatherProbe(Data);
encode_disp('WeatherReport', Data) -> enc_WeatherReport(Data);
encode_disp('WiperSet', Data) -> enc_WiperSet(Data);
encode_disp('Acceleration', Data) -> enc_Acceleration(Data);
encode_disp('AccelerationConfidence', Data) -> enc_AccelerationConfidence(Data);
encode_disp('AdvisorySpeedType', Data) -> enc_AdvisorySpeedType(Data);
encode_disp('AllowedManeuvers', Data) -> enc_AllowedManeuvers(Data);
encode_disp('AmbientAirPressure', Data) -> enc_AmbientAirPressure(Data);
encode_disp('AmbientAirTemperature', Data) -> enc_AmbientAirTemperature(Data);
encode_disp('Angle', Data) -> enc_Angle(Data);
encode_disp('AnimalPropelledType', Data) -> enc_AnimalPropelledType(Data);
encode_disp('AnimalType', Data) -> enc_AnimalType(Data);
encode_disp('AntiLockBrakeStatus', Data) -> enc_AntiLockBrakeStatus(Data);
encode_disp('ApproachID', Data) -> enc_ApproachID(Data);
encode_disp('Attachment', Data) -> enc_Attachment(Data);
encode_disp('AttachmentRadius', Data) -> enc_AttachmentRadius(Data);
encode_disp('AuxiliaryBrakeStatus', Data) -> enc_AuxiliaryBrakeStatus(Data);
encode_disp('BasicVehicleClass', Data) -> enc_BasicVehicleClass(Data);
encode_disp('BasicVehicleRole', Data) -> enc_BasicVehicleRole(Data);
encode_disp('BrakeAppliedPressure', Data) -> enc_BrakeAppliedPressure(Data);
encode_disp('BrakeAppliedStatus', Data) -> enc_BrakeAppliedStatus(Data);
encode_disp('BrakeBoostApplied', Data) -> enc_BrakeBoostApplied(Data);
encode_disp('BumperHeight', Data) -> enc_BumperHeight(Data);
encode_disp('CoarseHeading', Data) -> enc_CoarseHeading(Data);
encode_disp('CodeWord', Data) -> enc_CodeWord(Data);
encode_disp('CoefficientOfFriction', Data) -> enc_CoefficientOfFriction(Data);
encode_disp('Confidence', Data) -> enc_Confidence(Data);
encode_disp('Count', Data) -> enc_Count(Data);
encode_disp('DDay', Data) -> enc_DDay(Data);
encode_disp('DeltaAngle', Data) -> enc_DeltaAngle(Data);
encode_disp('DeltaTime', Data) -> enc_DeltaTime(Data);
encode_disp('DescriptiveName', Data) -> enc_DescriptiveName(Data);
encode_disp('DHour', Data) -> enc_DHour(Data);
encode_disp('DirectionOfUse', Data) -> enc_DirectionOfUse(Data);
encode_disp('DistanceUnits', Data) -> enc_DistanceUnits(Data);
encode_disp('DMinute', Data) -> enc_DMinute(Data);
encode_disp('DMonth', Data) -> enc_DMonth(Data);
encode_disp('DOffset', Data) -> enc_DOffset(Data);
encode_disp('DrivenLineOffsetLg', Data) -> enc_DrivenLineOffsetLg(Data);
encode_disp('DrivenLineOffsetSm', Data) -> enc_DrivenLineOffsetSm(Data);
encode_disp('DrivingWheelAngle', Data) -> enc_DrivingWheelAngle(Data);
encode_disp('DSecond', Data) -> enc_DSecond(Data);
encode_disp('DSRCmsgID', Data) -> enc_DSRCmsgID(Data);
encode_disp('Duration', Data) -> enc_Duration(Data);
encode_disp('DYear', Data) -> enc_DYear(Data);
encode_disp('ElevationConfidence', Data) -> enc_ElevationConfidence(Data);
encode_disp('Elevation', Data) -> enc_Elevation(Data);
encode_disp('Extent', Data) -> enc_Extent(Data);
encode_disp('ExteriorLights', Data) -> enc_ExteriorLights(Data);
encode_disp('FuelType', Data) -> enc_FuelType(Data);
encode_disp('FurtherInfoID', Data) -> enc_FurtherInfoID(Data);
encode_disp('GNSSstatus', Data) -> enc_GNSSstatus(Data);
encode_disp('GrossDistance', Data) -> enc_GrossDistance(Data);
encode_disp('GrossSpeed', Data) -> enc_GrossSpeed(Data);
encode_disp('HeadingConfidence', Data) -> enc_HeadingConfidence(Data);
encode_disp('Heading', Data) -> enc_Heading(Data);
encode_disp('HeadingSlice', Data) -> enc_HeadingSlice(Data);
encode_disp('IntersectionID', Data) -> enc_IntersectionID(Data);
encode_disp('IntersectionStatusObject', Data) -> enc_IntersectionStatusObject(Data);
encode_disp('IsDolly', Data) -> enc_IsDolly(Data);
encode_disp('Iso3833VehicleType', Data) -> enc_Iso3833VehicleType(Data);
encode_disp('ITIStextPhrase', Data) -> enc_ITIStextPhrase(Data);
encode_disp('AxleLocation', Data) -> enc_AxleLocation(Data);
encode_disp('AxleWeight', Data) -> enc_AxleWeight(Data);
encode_disp('CargoWeight', Data) -> enc_CargoWeight(Data);
encode_disp('DriveAxleLiftAirPressure', Data) -> enc_DriveAxleLiftAirPressure(Data);
encode_disp('DriveAxleLocation', Data) -> enc_DriveAxleLocation(Data);
encode_disp('DriveAxleLubePressure', Data) -> enc_DriveAxleLubePressure(Data);
encode_disp('DriveAxleTemperature', Data) -> enc_DriveAxleTemperature(Data);
encode_disp('SteeringAxleLubePressure', Data) -> enc_SteeringAxleLubePressure(Data);
encode_disp('SteeringAxleTemperature', Data) -> enc_SteeringAxleTemperature(Data);
encode_disp('TireLeakageRate', Data) -> enc_TireLeakageRate(Data);
encode_disp('TireLocation', Data) -> enc_TireLocation(Data);
encode_disp('TirePressureThresholdDetection', Data) -> enc_TirePressureThresholdDetection(Data);
encode_disp('TirePressure', Data) -> enc_TirePressure(Data);
encode_disp('TireTemp', Data) -> enc_TireTemp(Data);
encode_disp('TrailerWeight', Data) -> enc_TrailerWeight(Data);
encode_disp('WheelEndElectFault', Data) -> enc_WheelEndElectFault(Data);
encode_disp('WheelSensorStatus', Data) -> enc_WheelSensorStatus(Data);
encode_disp('LaneAttributes-Barrier', Data) -> 'enc_LaneAttributes-Barrier'(Data);
encode_disp('LaneAttributes-Bike', Data) -> 'enc_LaneAttributes-Bike'(Data);
encode_disp('LaneAttributes-Crosswalk', Data) -> 'enc_LaneAttributes-Crosswalk'(Data);
encode_disp('LaneAttributes-Parking', Data) -> 'enc_LaneAttributes-Parking'(Data);
encode_disp('LaneAttributes-Sidewalk', Data) -> 'enc_LaneAttributes-Sidewalk'(Data);
encode_disp('LaneAttributes-Striping', Data) -> 'enc_LaneAttributes-Striping'(Data);
encode_disp('LaneAttributes-TrackedVehicle', Data) -> 'enc_LaneAttributes-TrackedVehicle'(Data);
encode_disp('LaneAttributes-Vehicle', Data) -> 'enc_LaneAttributes-Vehicle'(Data);
encode_disp('LaneConnectionID', Data) -> enc_LaneConnectionID(Data);
encode_disp('LaneDirection', Data) -> enc_LaneDirection(Data);
encode_disp('LaneID', Data) -> enc_LaneID(Data);
encode_disp('LaneSharing', Data) -> enc_LaneSharing(Data);
encode_disp('LaneWidth', Data) -> enc_LaneWidth(Data);
encode_disp('Latitude', Data) -> enc_Latitude(Data);
encode_disp('LayerID', Data) -> enc_LayerID(Data);
encode_disp('LayerType', Data) -> enc_LayerType(Data);
encode_disp('LightbarInUse', Data) -> enc_LightbarInUse(Data);
encode_disp('Longitude', Data) -> enc_Longitude(Data);
encode_disp('Location-quality', Data) -> 'enc_Location-quality'(Data);
encode_disp('Location-tech', Data) -> 'enc_Location-tech'(Data);
encode_disp('MergeDivergeNodeAngle', Data) -> enc_MergeDivergeNodeAngle(Data);
encode_disp('MessageBLOB', Data) -> enc_MessageBLOB(Data);
encode_disp('MinuteOfTheYear', Data) -> enc_MinuteOfTheYear(Data);
encode_disp('MinutesDuration', Data) -> enc_MinutesDuration(Data);
encode_disp('MotorizedPropelledType', Data) -> enc_MotorizedPropelledType(Data);
encode_disp('MovementPhaseState', Data) -> enc_MovementPhaseState(Data);
encode_disp('MsgCount', Data) -> enc_MsgCount(Data);
encode_disp('MsgCRC', Data) -> enc_MsgCRC(Data);
encode_disp('MultiVehicleResponse', Data) -> enc_MultiVehicleResponse(Data);
encode_disp('MUTCDCode', Data) -> enc_MUTCDCode(Data);
encode_disp('NMEA-MsgType', Data) -> 'enc_NMEA-MsgType'(Data);
encode_disp('NMEA-Payload', Data) -> 'enc_NMEA-Payload'(Data);
encode_disp('NMEA-Revision', Data) -> 'enc_NMEA-Revision'(Data);
encode_disp('NodeAttributeLL', Data) -> enc_NodeAttributeLL(Data);
encode_disp('NodeAttributeXY', Data) -> enc_NodeAttributeXY(Data);
encode_disp('NumberOfParticipantsInCluster', Data) -> enc_NumberOfParticipantsInCluster(Data);
encode_disp('ObjectCount', Data) -> enc_ObjectCount(Data);
encode_disp('ObstacleDirection', Data) -> enc_ObstacleDirection(Data);
encode_disp('ObstacleDistance', Data) -> enc_ObstacleDistance(Data);
encode_disp('Offset-B09', Data) -> 'enc_Offset-B09'(Data);
encode_disp('Offset-B10', Data) -> 'enc_Offset-B10'(Data);
encode_disp('Offset-B11', Data) -> 'enc_Offset-B11'(Data);
encode_disp('Offset-B12', Data) -> 'enc_Offset-B12'(Data);
encode_disp('Offset-B13', Data) -> 'enc_Offset-B13'(Data);
encode_disp('Offset-B14', Data) -> 'enc_Offset-B14'(Data);
encode_disp('Offset-B16', Data) -> 'enc_Offset-B16'(Data);
encode_disp('OffsetLL-B12', Data) -> 'enc_OffsetLL-B12'(Data);
encode_disp('OffsetLL-B14', Data) -> 'enc_OffsetLL-B14'(Data);
encode_disp('OffsetLL-B16', Data) -> 'enc_OffsetLL-B16'(Data);
encode_disp('OffsetLL-B18', Data) -> 'enc_OffsetLL-B18'(Data);
encode_disp('OffsetLL-B22', Data) -> 'enc_OffsetLL-B22'(Data);
encode_disp('OffsetLL-B24', Data) -> 'enc_OffsetLL-B24'(Data);
encode_disp('PayloadData', Data) -> enc_PayloadData(Data);
encode_disp('PedestrianBicycleDetect', Data) -> enc_PedestrianBicycleDetect(Data);
encode_disp('HumanPropelledType', Data) -> enc_HumanPropelledType(Data);
encode_disp('PersonalAssistive', Data) -> enc_PersonalAssistive(Data);
encode_disp('PersonalClusterRadius', Data) -> enc_PersonalClusterRadius(Data);
encode_disp('PersonalCrossingInProgress', Data) -> enc_PersonalCrossingInProgress(Data);
encode_disp('PersonalCrossingRequest', Data) -> enc_PersonalCrossingRequest(Data);
encode_disp('PersonalDeviceUsageState', Data) -> enc_PersonalDeviceUsageState(Data);
encode_disp('PersonalDeviceUserType', Data) -> enc_PersonalDeviceUserType(Data);
encode_disp('PivotingAllowed', Data) -> enc_PivotingAllowed(Data);
encode_disp('PositionConfidence', Data) -> enc_PositionConfidence(Data);
encode_disp('PrioritizationResponseStatus', Data) -> enc_PrioritizationResponseStatus(Data);
encode_disp('Priority', Data) -> enc_Priority(Data);
encode_disp('PriorityRequestType', Data) -> enc_PriorityRequestType(Data);
encode_disp('PrivilegedEventFlags', Data) -> enc_PrivilegedEventFlags(Data);
encode_disp('ProbeSegmentNumber', Data) -> enc_ProbeSegmentNumber(Data);
encode_disp('PublicSafetyAndRoadWorkerActivity', Data) -> enc_PublicSafetyAndRoadWorkerActivity(Data);
encode_disp('PublicSafetyDirectingTrafficSubType', Data) -> enc_PublicSafetyDirectingTrafficSubType(Data);
encode_disp('PublicSafetyEventResponderWorkerType', Data) -> enc_PublicSafetyEventResponderWorkerType(Data);
encode_disp('RadiusOfCurvature', Data) -> enc_RadiusOfCurvature(Data);
encode_disp('Radius-B12', Data) -> 'enc_Radius-B12'(Data);
encode_disp('RainSensor', Data) -> enc_RainSensor(Data);
encode_disp('RegionId', Data) -> enc_RegionId(Data);
encode_disp('RequestedItem', Data) -> enc_RequestedItem(Data);
encode_disp('RequestID', Data) -> enc_RequestID(Data);
encode_disp('RequestImportanceLevel', Data) -> enc_RequestImportanceLevel(Data);
encode_disp('RequestSubRole', Data) -> enc_RequestSubRole(Data);
encode_disp('ResponseType', Data) -> enc_ResponseType(Data);
encode_disp('RestrictionAppliesTo', Data) -> enc_RestrictionAppliesTo(Data);
encode_disp('RestrictionClassID', Data) -> enc_RestrictionClassID(Data);
encode_disp('RoadRegulatorID', Data) -> enc_RoadRegulatorID(Data);
encode_disp('RoadSegmentID', Data) -> enc_RoadSegmentID(Data);
encode_disp('RoadwayCrownAngle', Data) -> enc_RoadwayCrownAngle(Data);
encode_disp('RTCM-Revision', Data) -> 'enc_RTCM-Revision'(Data);
encode_disp('RTCMmessage', Data) -> enc_RTCMmessage(Data);
encode_disp('Scale-B12', Data) -> 'enc_Scale-B12'(Data);
encode_disp('SecondOfTime', Data) -> enc_SecondOfTime(Data);
encode_disp('SegmentAttributeLL', Data) -> enc_SegmentAttributeLL(Data);
encode_disp('SegmentAttributeXY', Data) -> enc_SegmentAttributeXY(Data);
encode_disp('SemiMajorAxisAccuracy', Data) -> enc_SemiMajorAxisAccuracy(Data);
encode_disp('SemiMajorAxisOrientation', Data) -> enc_SemiMajorAxisOrientation(Data);
encode_disp('SemiMinorAxisAccuracy', Data) -> enc_SemiMinorAxisAccuracy(Data);
encode_disp('SignalGroupID', Data) -> enc_SignalGroupID(Data);
encode_disp('SignalReqScheme', Data) -> enc_SignalReqScheme(Data);
encode_disp('SignPrority', Data) -> enc_SignPrority(Data);
encode_disp('SirenInUse', Data) -> enc_SirenInUse(Data);
encode_disp('SpeedAdvice', Data) -> enc_SpeedAdvice(Data);
encode_disp('SpeedConfidence', Data) -> enc_SpeedConfidence(Data);
encode_disp('SpeedLimitType', Data) -> enc_SpeedLimitType(Data);
encode_disp('SpeedProfileMeasurement', Data) -> enc_SpeedProfileMeasurement(Data);
encode_disp('Speed', Data) -> enc_Speed(Data);
encode_disp('SSPindex', Data) -> enc_SSPindex(Data);
encode_disp('StabilityControlStatus', Data) -> enc_StabilityControlStatus(Data);
encode_disp('StationID', Data) -> enc_StationID(Data);
encode_disp('SteeringWheelAngleConfidence', Data) -> enc_SteeringWheelAngleConfidence(Data);
encode_disp('SteeringWheelAngleRateOfChange', Data) -> enc_SteeringWheelAngleRateOfChange(Data);
encode_disp('SteeringWheelAngle', Data) -> enc_SteeringWheelAngle(Data);
encode_disp('SunSensor', Data) -> enc_SunSensor(Data);
encode_disp('TemporaryID', Data) -> enc_TemporaryID(Data);
encode_disp('TermDistance', Data) -> enc_TermDistance(Data);
encode_disp('TermTime', Data) -> enc_TermTime(Data);
encode_disp('ThrottleConfidence', Data) -> enc_ThrottleConfidence(Data);
encode_disp('ThrottlePosition', Data) -> enc_ThrottlePosition(Data);
encode_disp('TimeConfidence', Data) -> enc_TimeConfidence(Data);
encode_disp('TimeIntervalConfidence', Data) -> enc_TimeIntervalConfidence(Data);
encode_disp('TimeMark', Data) -> enc_TimeMark(Data);
encode_disp('TimeOffset', Data) -> enc_TimeOffset(Data);
encode_disp('TractionControlStatus', Data) -> enc_TractionControlStatus(Data);
encode_disp('TrailerMass', Data) -> enc_TrailerMass(Data);
encode_disp('TransitStatus', Data) -> enc_TransitStatus(Data);
encode_disp('TransitVehicleOccupancy', Data) -> enc_TransitVehicleOccupancy(Data);
encode_disp('TransitVehicleStatus', Data) -> enc_TransitVehicleStatus(Data);
encode_disp('TransmissionState', Data) -> enc_TransmissionState(Data);
encode_disp('TravelerInfoType', Data) -> enc_TravelerInfoType(Data);
encode_disp('UniqueMSGID', Data) -> enc_UniqueMSGID(Data);
encode_disp('URL-Base', Data) -> 'enc_URL-Base'(Data);
encode_disp('URL-Link', Data) -> 'enc_URL-Link'(Data);
encode_disp('URL-Short', Data) -> 'enc_URL-Short'(Data);
encode_disp('UserSizeAndBehaviour', Data) -> enc_UserSizeAndBehaviour(Data);
encode_disp('VehicleEventFlags', Data) -> enc_VehicleEventFlags(Data);
encode_disp('VehicleHeight', Data) -> enc_VehicleHeight(Data);
encode_disp('VehicleLength', Data) -> enc_VehicleLength(Data);
encode_disp('VehicleMass', Data) -> enc_VehicleMass(Data);
encode_disp('VehicleStatusDeviceTypeTag', Data) -> enc_VehicleStatusDeviceTypeTag(Data);
encode_disp('VehicleType', Data) -> enc_VehicleType(Data);
encode_disp('VehicleWidth', Data) -> enc_VehicleWidth(Data);
encode_disp('Velocity', Data) -> enc_Velocity(Data);
encode_disp('VerticalAccelerationThreshold', Data) -> enc_VerticalAccelerationThreshold(Data);
encode_disp('VerticalAcceleration', Data) -> enc_VerticalAcceleration(Data);
encode_disp('VertOffset-B07', Data) -> 'enc_VertOffset-B07'(Data);
encode_disp('VertOffset-B08', Data) -> 'enc_VertOffset-B08'(Data);
encode_disp('VertOffset-B09', Data) -> 'enc_VertOffset-B09'(Data);
encode_disp('VertOffset-B10', Data) -> 'enc_VertOffset-B10'(Data);
encode_disp('VertOffset-B11', Data) -> 'enc_VertOffset-B11'(Data);
encode_disp('VertOffset-B12', Data) -> 'enc_VertOffset-B12'(Data);
encode_disp('VINstring', Data) -> enc_VINstring(Data);
encode_disp('WaitOnStopline', Data) -> enc_WaitOnStopline(Data);
encode_disp('WiperRate', Data) -> enc_WiperRate(Data);
encode_disp('WiperStatus', Data) -> enc_WiperStatus(Data);
encode_disp('YawRateConfidence', Data) -> enc_YawRateConfidence(Data);
encode_disp('YawRate', Data) -> enc_YawRate(Data);
encode_disp('ZoneLength', Data) -> enc_ZoneLength(Data);
encode_disp('Zoom', Data) -> enc_Zoom(Data);
encode_disp(Type, _Data) -> exit({error,{asn1,{undefined_type,Type}}}).

decode_disp('MessageFrame', Data) -> dec_MessageFrame(Data);
decode_disp('BasicSafetyMessage', Data) -> dec_BasicSafetyMessage(Data);
decode_disp('PartII-Id', Data) -> 'dec_PartII-Id'(Data);
decode_disp('CommonSafetyRequest', Data) -> dec_CommonSafetyRequest(Data);
decode_disp('EmergencyVehicleAlert', Data) -> dec_EmergencyVehicleAlert(Data);
decode_disp('IntersectionCollision', Data) -> dec_IntersectionCollision(Data);
decode_disp('MapData', Data) -> dec_MapData(Data);
decode_disp('NMEAcorrections', Data) -> dec_NMEAcorrections(Data);
decode_disp('PersonalSafetyMessage', Data) -> dec_PersonalSafetyMessage(Data);
decode_disp('ProbeDataManagement', Data) -> dec_ProbeDataManagement(Data);
decode_disp('ProbeVehicleData', Data) -> dec_ProbeVehicleData(Data);
decode_disp('RoadSideAlert', Data) -> dec_RoadSideAlert(Data);
decode_disp('RTCMcorrections', Data) -> dec_RTCMcorrections(Data);
decode_disp('SPAT', Data) -> dec_SPAT(Data);
decode_disp('SignalRequestMessage', Data) -> dec_SignalRequestMessage(Data);
decode_disp('SignalStatusMessage', Data) -> dec_SignalStatusMessage(Data);
decode_disp('TravelerInformation', Data) -> dec_TravelerInformation(Data);
decode_disp('TestMessage00', Data) -> dec_TestMessage00(Data);
decode_disp('TestMessage01', Data) -> dec_TestMessage01(Data);
decode_disp('TestMessage02', Data) -> dec_TestMessage02(Data);
decode_disp('TestMessage03', Data) -> dec_TestMessage03(Data);
decode_disp('TestMessage04', Data) -> dec_TestMessage04(Data);
decode_disp('TestMessage05', Data) -> dec_TestMessage05(Data);
decode_disp('TestMessage06', Data) -> dec_TestMessage06(Data);
decode_disp('TestMessage07', Data) -> dec_TestMessage07(Data);
decode_disp('TestMessage08', Data) -> dec_TestMessage08(Data);
decode_disp('TestMessage09', Data) -> dec_TestMessage09(Data);
decode_disp('TestMessage10', Data) -> dec_TestMessage10(Data);
decode_disp('TestMessage11', Data) -> dec_TestMessage11(Data);
decode_disp('TestMessage12', Data) -> dec_TestMessage12(Data);
decode_disp('TestMessage13', Data) -> dec_TestMessage13(Data);
decode_disp('TestMessage14', Data) -> dec_TestMessage14(Data);
decode_disp('TestMessage15', Data) -> dec_TestMessage15(Data);
decode_disp('AccelerationSet4Way', Data) -> dec_AccelerationSet4Way(Data);
decode_disp('AccelSteerYawRateConfidence', Data) -> dec_AccelSteerYawRateConfidence(Data);
decode_disp('AdvisorySpeed', Data) -> dec_AdvisorySpeed(Data);
decode_disp('AdvisorySpeedList', Data) -> dec_AdvisorySpeedList(Data);
decode_disp('AntennaOffsetSet', Data) -> dec_AntennaOffsetSet(Data);
decode_disp('ApproachOrLane', Data) -> dec_ApproachOrLane(Data);
decode_disp('BrakeSystemStatus', Data) -> dec_BrakeSystemStatus(Data);
decode_disp('BSMcoreData', Data) -> dec_BSMcoreData(Data);
decode_disp('BumperHeights', Data) -> dec_BumperHeights(Data);
decode_disp('Circle', Data) -> dec_Circle(Data);
decode_disp('ComputedLane', Data) -> dec_ComputedLane(Data);
decode_disp('ConfidenceSet', Data) -> dec_ConfidenceSet(Data);
decode_disp('ConnectingLane', Data) -> dec_ConnectingLane(Data);
decode_disp('Connection', Data) -> dec_Connection(Data);
decode_disp('ConnectionManeuverAssist', Data) -> dec_ConnectionManeuverAssist(Data);
decode_disp('ConnectsToList', Data) -> dec_ConnectsToList(Data);
decode_disp('DataParameters', Data) -> dec_DataParameters(Data);
decode_disp('DDate', Data) -> dec_DDate(Data);
decode_disp('DDateTime', Data) -> dec_DDateTime(Data);
decode_disp('DFullTime', Data) -> dec_DFullTime(Data);
decode_disp('DMonthDay', Data) -> dec_DMonthDay(Data);
decode_disp('DTime', Data) -> dec_DTime(Data);
decode_disp('DYearMonth', Data) -> dec_DYearMonth(Data);
decode_disp('DisabledVehicle', Data) -> dec_DisabledVehicle(Data);
decode_disp('EmergencyDetails', Data) -> dec_EmergencyDetails(Data);
decode_disp('EnabledLaneList', Data) -> dec_EnabledLaneList(Data);
decode_disp('EventDescription', Data) -> dec_EventDescription(Data);
decode_disp('FullPositionVector', Data) -> dec_FullPositionVector(Data);
decode_disp('GenericLane', Data) -> dec_GenericLane(Data);
decode_disp('GeographicalPath', Data) -> dec_GeographicalPath(Data);
decode_disp('GeometricProjection', Data) -> dec_GeometricProjection(Data);
decode_disp('Header', Data) -> dec_Header(Data);
decode_disp('IntersectionAccessPoint', Data) -> dec_IntersectionAccessPoint(Data);
decode_disp('IntersectionGeometry', Data) -> dec_IntersectionGeometry(Data);
decode_disp('IntersectionGeometryList', Data) -> dec_IntersectionGeometryList(Data);
decode_disp('IntersectionReferenceID', Data) -> dec_IntersectionReferenceID(Data);
decode_disp('IntersectionState', Data) -> dec_IntersectionState(Data);
decode_disp('IntersectionStateList', Data) -> dec_IntersectionStateList(Data);
decode_disp('ExitService', Data) -> dec_ExitService(Data);
decode_disp('GenericSignage', Data) -> dec_GenericSignage(Data);
decode_disp('SpeedLimit', Data) -> dec_SpeedLimit(Data);
decode_disp('WorkZone', Data) -> dec_WorkZone(Data);
decode_disp('J1939data', Data) -> dec_J1939data(Data);
decode_disp('TireDataList', Data) -> dec_TireDataList(Data);
decode_disp('TireData', Data) -> dec_TireData(Data);
decode_disp('AxleWeightList', Data) -> dec_AxleWeightList(Data);
decode_disp('AxleWeightSet', Data) -> dec_AxleWeightSet(Data);
decode_disp('LaneAttributes', Data) -> dec_LaneAttributes(Data);
decode_disp('LaneDataAttribute', Data) -> dec_LaneDataAttribute(Data);
decode_disp('LaneDataAttributeList', Data) -> dec_LaneDataAttributeList(Data);
decode_disp('LaneList', Data) -> dec_LaneList(Data);
decode_disp('LaneTypeAttributes', Data) -> dec_LaneTypeAttributes(Data);
decode_disp('ManeuverAssistList', Data) -> dec_ManeuverAssistList(Data);
decode_disp('MovementEventList', Data) -> dec_MovementEventList(Data);
decode_disp('MovementEvent', Data) -> dec_MovementEvent(Data);
decode_disp('MovementList', Data) -> dec_MovementList(Data);
decode_disp('MovementState', Data) -> dec_MovementState(Data);
decode_disp('Node-LL-24B', Data) -> 'dec_Node-LL-24B'(Data);
decode_disp('Node-LL-28B', Data) -> 'dec_Node-LL-28B'(Data);
decode_disp('Node-LL-32B', Data) -> 'dec_Node-LL-32B'(Data);
decode_disp('Node-LL-36B', Data) -> 'dec_Node-LL-36B'(Data);
decode_disp('Node-LL-44B', Data) -> 'dec_Node-LL-44B'(Data);
decode_disp('Node-LL-48B', Data) -> 'dec_Node-LL-48B'(Data);
decode_disp('Node-LLmD-64b', Data) -> 'dec_Node-LLmD-64b'(Data);
decode_disp('Node-XY-20b', Data) -> 'dec_Node-XY-20b'(Data);
decode_disp('Node-XY-22b', Data) -> 'dec_Node-XY-22b'(Data);
decode_disp('Node-XY-24b', Data) -> 'dec_Node-XY-24b'(Data);
decode_disp('Node-XY-26b', Data) -> 'dec_Node-XY-26b'(Data);
decode_disp('Node-XY-28b', Data) -> 'dec_Node-XY-28b'(Data);
decode_disp('Node-XY-32b', Data) -> 'dec_Node-XY-32b'(Data);
decode_disp('NodeAttributeLLList', Data) -> dec_NodeAttributeLLList(Data);
decode_disp('NodeAttributeSetLL', Data) -> dec_NodeAttributeSetLL(Data);
decode_disp('NodeAttributeSetXY', Data) -> dec_NodeAttributeSetXY(Data);
decode_disp('NodeAttributeXYList', Data) -> dec_NodeAttributeXYList(Data);
decode_disp('NodeListLL', Data) -> dec_NodeListLL(Data);
decode_disp('NodeListXY', Data) -> dec_NodeListXY(Data);
decode_disp('NodeLL', Data) -> dec_NodeLL(Data);
decode_disp('NodeOffsetPointLL', Data) -> dec_NodeOffsetPointLL(Data);
decode_disp('NodeOffsetPointXY', Data) -> dec_NodeOffsetPointXY(Data);
decode_disp('NodeSetLL', Data) -> dec_NodeSetLL(Data);
decode_disp('NodeSetXY', Data) -> dec_NodeSetXY(Data);
decode_disp('NodeXY', Data) -> dec_NodeXY(Data);
decode_disp('ObstacleDetection', Data) -> dec_ObstacleDetection(Data);
decode_disp('OffsetSystem', Data) -> dec_OffsetSystem(Data);
decode_disp('OverlayLaneList', Data) -> dec_OverlayLaneList(Data);
decode_disp('PathHistory', Data) -> dec_PathHistory(Data);
decode_disp('PathHistoryPointList', Data) -> dec_PathHistoryPointList(Data);
decode_disp('PathHistoryPoint', Data) -> dec_PathHistoryPoint(Data);
decode_disp('PathPrediction', Data) -> dec_PathPrediction(Data);
decode_disp('PivotPointDescription', Data) -> dec_PivotPointDescription(Data);
decode_disp('Position3D', Data) -> dec_Position3D(Data);
decode_disp('PositionalAccuracy', Data) -> dec_PositionalAccuracy(Data);
decode_disp('PositionConfidenceSet', Data) -> dec_PositionConfidenceSet(Data);
decode_disp('PreemptPriorityList', Data) -> dec_PreemptPriorityList(Data);
decode_disp('SignalControlZone', Data) -> dec_SignalControlZone(Data);
decode_disp('PrivilegedEvents', Data) -> dec_PrivilegedEvents(Data);
decode_disp('PropelledInformation', Data) -> dec_PropelledInformation(Data);
decode_disp('RegionList', Data) -> dec_RegionList(Data);
decode_disp('RegionOffsets', Data) -> dec_RegionOffsets(Data);
decode_disp('RegionPointSet', Data) -> dec_RegionPointSet(Data);
decode_disp('RegulatorySpeedLimit', Data) -> dec_RegulatorySpeedLimit(Data);
decode_disp('RequestedItemList', Data) -> dec_RequestedItemList(Data);
decode_disp('RequestorDescription', Data) -> dec_RequestorDescription(Data);
decode_disp('RequestorPositionVector', Data) -> dec_RequestorPositionVector(Data);
decode_disp('RequestorType', Data) -> dec_RequestorType(Data);
decode_disp('RestrictionClassAssignment', Data) -> dec_RestrictionClassAssignment(Data);
decode_disp('RestrictionClassList', Data) -> dec_RestrictionClassList(Data);
decode_disp('RestrictionUserTypeList', Data) -> dec_RestrictionUserTypeList(Data);
decode_disp('RestrictionUserType', Data) -> dec_RestrictionUserType(Data);
decode_disp('RoadLaneSetList', Data) -> dec_RoadLaneSetList(Data);
decode_disp('RoadSegmentList', Data) -> dec_RoadSegmentList(Data);
decode_disp('RoadSegmentReferenceID', Data) -> dec_RoadSegmentReferenceID(Data);
decode_disp('RoadSegment', Data) -> dec_RoadSegment(Data);
decode_disp('RoadSignID', Data) -> dec_RoadSignID(Data);
decode_disp('RTCMheader', Data) -> dec_RTCMheader(Data);
decode_disp('RTCMmessageList', Data) -> dec_RTCMmessageList(Data);
decode_disp('RTCMPackage', Data) -> dec_RTCMPackage(Data);
decode_disp('Sample', Data) -> dec_Sample(Data);
decode_disp('SegmentAttributeLLList', Data) -> dec_SegmentAttributeLLList(Data);
decode_disp('SegmentAttributeXYList', Data) -> dec_SegmentAttributeXYList(Data);
decode_disp('ShapePointSet', Data) -> dec_ShapePointSet(Data);
decode_disp('SignalRequesterInfo', Data) -> dec_SignalRequesterInfo(Data);
decode_disp('SignalRequestList', Data) -> dec_SignalRequestList(Data);
decode_disp('SignalRequestPackage', Data) -> dec_SignalRequestPackage(Data);
decode_disp('SignalRequest', Data) -> dec_SignalRequest(Data);
decode_disp('SignalStatusList', Data) -> dec_SignalStatusList(Data);
decode_disp('SignalStatusPackageList', Data) -> dec_SignalStatusPackageList(Data);
decode_disp('SignalStatusPackage', Data) -> dec_SignalStatusPackage(Data);
decode_disp('SignalStatus', Data) -> dec_SignalStatus(Data);
decode_disp('SnapshotDistance', Data) -> dec_SnapshotDistance(Data);
decode_disp('Snapshot', Data) -> dec_Snapshot(Data);
decode_disp('SnapshotTime', Data) -> dec_SnapshotTime(Data);
decode_disp('SpecialVehicleExtensions', Data) -> dec_SpecialVehicleExtensions(Data);
decode_disp('SpeedandHeadingandThrottleConfidence', Data) -> dec_SpeedandHeadingandThrottleConfidence(Data);
decode_disp('SpeedLimitList', Data) -> dec_SpeedLimitList(Data);
decode_disp('SpeedProfileMeasurementList', Data) -> dec_SpeedProfileMeasurementList(Data);
decode_disp('SpeedProfile', Data) -> dec_SpeedProfile(Data);
decode_disp('SupplementalVehicleExtensions', Data) -> dec_SupplementalVehicleExtensions(Data);
decode_disp('TimeChangeDetails', Data) -> dec_TimeChangeDetails(Data);
decode_disp('TrailerData', Data) -> dec_TrailerData(Data);
decode_disp('TrailerHistoryPointList', Data) -> dec_TrailerHistoryPointList(Data);
decode_disp('TrailerHistoryPoint', Data) -> dec_TrailerHistoryPoint(Data);
decode_disp('TrailerUnitDescriptionList', Data) -> dec_TrailerUnitDescriptionList(Data);
decode_disp('TrailerUnitDescription', Data) -> dec_TrailerUnitDescription(Data);
decode_disp('TransmissionAndSpeed', Data) -> dec_TransmissionAndSpeed(Data);
decode_disp('TravelerDataFrameList', Data) -> dec_TravelerDataFrameList(Data);
decode_disp('TravelerDataFrame', Data) -> dec_TravelerDataFrame(Data);
decode_disp('ValidRegion', Data) -> dec_ValidRegion(Data);
decode_disp('VehicleClassification', Data) -> dec_VehicleClassification(Data);
decode_disp('VehicleData', Data) -> dec_VehicleData(Data);
decode_disp('VehicleIdent', Data) -> dec_VehicleIdent(Data);
decode_disp('VehicleID', Data) -> dec_VehicleID(Data);
decode_disp('VehicleSafetyExtensions', Data) -> dec_VehicleSafetyExtensions(Data);
decode_disp('VehicleSize', Data) -> dec_VehicleSize(Data);
decode_disp('VehicleStatusRequest', Data) -> dec_VehicleStatusRequest(Data);
decode_disp('VehicleStatusRequestList', Data) -> dec_VehicleStatusRequestList(Data);
decode_disp('VehicleStatus', Data) -> dec_VehicleStatus(Data);
decode_disp('VerticalOffset', Data) -> dec_VerticalOffset(Data);
decode_disp('WeatherProbe', Data) -> dec_WeatherProbe(Data);
decode_disp('WeatherReport', Data) -> dec_WeatherReport(Data);
decode_disp('WiperSet', Data) -> dec_WiperSet(Data);
decode_disp('Acceleration', Data) -> dec_Acceleration(Data);
decode_disp('AccelerationConfidence', Data) -> dec_AccelerationConfidence(Data);
decode_disp('AdvisorySpeedType', Data) -> dec_AdvisorySpeedType(Data);
decode_disp('AllowedManeuvers', Data) -> dec_AllowedManeuvers(Data);
decode_disp('AmbientAirPressure', Data) -> dec_AmbientAirPressure(Data);
decode_disp('AmbientAirTemperature', Data) -> dec_AmbientAirTemperature(Data);
decode_disp('Angle', Data) -> dec_Angle(Data);
decode_disp('AnimalPropelledType', Data) -> dec_AnimalPropelledType(Data);
decode_disp('AnimalType', Data) -> dec_AnimalType(Data);
decode_disp('AntiLockBrakeStatus', Data) -> dec_AntiLockBrakeStatus(Data);
decode_disp('ApproachID', Data) -> dec_ApproachID(Data);
decode_disp('Attachment', Data) -> dec_Attachment(Data);
decode_disp('AttachmentRadius', Data) -> dec_AttachmentRadius(Data);
decode_disp('AuxiliaryBrakeStatus', Data) -> dec_AuxiliaryBrakeStatus(Data);
decode_disp('BasicVehicleClass', Data) -> dec_BasicVehicleClass(Data);
decode_disp('BasicVehicleRole', Data) -> dec_BasicVehicleRole(Data);
decode_disp('BrakeAppliedPressure', Data) -> dec_BrakeAppliedPressure(Data);
decode_disp('BrakeAppliedStatus', Data) -> dec_BrakeAppliedStatus(Data);
decode_disp('BrakeBoostApplied', Data) -> dec_BrakeBoostApplied(Data);
decode_disp('BumperHeight', Data) -> dec_BumperHeight(Data);
decode_disp('CoarseHeading', Data) -> dec_CoarseHeading(Data);
decode_disp('CodeWord', Data) -> dec_CodeWord(Data);
decode_disp('CoefficientOfFriction', Data) -> dec_CoefficientOfFriction(Data);
decode_disp('Confidence', Data) -> dec_Confidence(Data);
decode_disp('Count', Data) -> dec_Count(Data);
decode_disp('DDay', Data) -> dec_DDay(Data);
decode_disp('DeltaAngle', Data) -> dec_DeltaAngle(Data);
decode_disp('DeltaTime', Data) -> dec_DeltaTime(Data);
decode_disp('DescriptiveName', Data) -> dec_DescriptiveName(Data);
decode_disp('DHour', Data) -> dec_DHour(Data);
decode_disp('DirectionOfUse', Data) -> dec_DirectionOfUse(Data);
decode_disp('DistanceUnits', Data) -> dec_DistanceUnits(Data);
decode_disp('DMinute', Data) -> dec_DMinute(Data);
decode_disp('DMonth', Data) -> dec_DMonth(Data);
decode_disp('DOffset', Data) -> dec_DOffset(Data);
decode_disp('DrivenLineOffsetLg', Data) -> dec_DrivenLineOffsetLg(Data);
decode_disp('DrivenLineOffsetSm', Data) -> dec_DrivenLineOffsetSm(Data);
decode_disp('DrivingWheelAngle', Data) -> dec_DrivingWheelAngle(Data);
decode_disp('DSecond', Data) -> dec_DSecond(Data);
decode_disp('DSRCmsgID', Data) -> dec_DSRCmsgID(Data);
decode_disp('Duration', Data) -> dec_Duration(Data);
decode_disp('DYear', Data) -> dec_DYear(Data);
decode_disp('ElevationConfidence', Data) -> dec_ElevationConfidence(Data);
decode_disp('Elevation', Data) -> dec_Elevation(Data);
decode_disp('Extent', Data) -> dec_Extent(Data);
decode_disp('ExteriorLights', Data) -> dec_ExteriorLights(Data);
decode_disp('FuelType', Data) -> dec_FuelType(Data);
decode_disp('FurtherInfoID', Data) -> dec_FurtherInfoID(Data);
decode_disp('GNSSstatus', Data) -> dec_GNSSstatus(Data);
decode_disp('GrossDistance', Data) -> dec_GrossDistance(Data);
decode_disp('GrossSpeed', Data) -> dec_GrossSpeed(Data);
decode_disp('HeadingConfidence', Data) -> dec_HeadingConfidence(Data);
decode_disp('Heading', Data) -> dec_Heading(Data);
decode_disp('HeadingSlice', Data) -> dec_HeadingSlice(Data);
decode_disp('IntersectionID', Data) -> dec_IntersectionID(Data);
decode_disp('IntersectionStatusObject', Data) -> dec_IntersectionStatusObject(Data);
decode_disp('IsDolly', Data) -> dec_IsDolly(Data);
decode_disp('Iso3833VehicleType', Data) -> dec_Iso3833VehicleType(Data);
decode_disp('ITIStextPhrase', Data) -> dec_ITIStextPhrase(Data);
decode_disp('AxleLocation', Data) -> dec_AxleLocation(Data);
decode_disp('AxleWeight', Data) -> dec_AxleWeight(Data);
decode_disp('CargoWeight', Data) -> dec_CargoWeight(Data);
decode_disp('DriveAxleLiftAirPressure', Data) -> dec_DriveAxleLiftAirPressure(Data);
decode_disp('DriveAxleLocation', Data) -> dec_DriveAxleLocation(Data);
decode_disp('DriveAxleLubePressure', Data) -> dec_DriveAxleLubePressure(Data);
decode_disp('DriveAxleTemperature', Data) -> dec_DriveAxleTemperature(Data);
decode_disp('SteeringAxleLubePressure', Data) -> dec_SteeringAxleLubePressure(Data);
decode_disp('SteeringAxleTemperature', Data) -> dec_SteeringAxleTemperature(Data);
decode_disp('TireLeakageRate', Data) -> dec_TireLeakageRate(Data);
decode_disp('TireLocation', Data) -> dec_TireLocation(Data);
decode_disp('TirePressureThresholdDetection', Data) -> dec_TirePressureThresholdDetection(Data);
decode_disp('TirePressure', Data) -> dec_TirePressure(Data);
decode_disp('TireTemp', Data) -> dec_TireTemp(Data);
decode_disp('TrailerWeight', Data) -> dec_TrailerWeight(Data);
decode_disp('WheelEndElectFault', Data) -> dec_WheelEndElectFault(Data);
decode_disp('WheelSensorStatus', Data) -> dec_WheelSensorStatus(Data);
decode_disp('LaneAttributes-Barrier', Data) -> 'dec_LaneAttributes-Barrier'(Data);
decode_disp('LaneAttributes-Bike', Data) -> 'dec_LaneAttributes-Bike'(Data);
decode_disp('LaneAttributes-Crosswalk', Data) -> 'dec_LaneAttributes-Crosswalk'(Data);
decode_disp('LaneAttributes-Parking', Data) -> 'dec_LaneAttributes-Parking'(Data);
decode_disp('LaneAttributes-Sidewalk', Data) -> 'dec_LaneAttributes-Sidewalk'(Data);
decode_disp('LaneAttributes-Striping', Data) -> 'dec_LaneAttributes-Striping'(Data);
decode_disp('LaneAttributes-TrackedVehicle', Data) -> 'dec_LaneAttributes-TrackedVehicle'(Data);
decode_disp('LaneAttributes-Vehicle', Data) -> 'dec_LaneAttributes-Vehicle'(Data);
decode_disp('LaneConnectionID', Data) -> dec_LaneConnectionID(Data);
decode_disp('LaneDirection', Data) -> dec_LaneDirection(Data);
decode_disp('LaneID', Data) -> dec_LaneID(Data);
decode_disp('LaneSharing', Data) -> dec_LaneSharing(Data);
decode_disp('LaneWidth', Data) -> dec_LaneWidth(Data);
decode_disp('Latitude', Data) -> dec_Latitude(Data);
decode_disp('LayerID', Data) -> dec_LayerID(Data);
decode_disp('LayerType', Data) -> dec_LayerType(Data);
decode_disp('LightbarInUse', Data) -> dec_LightbarInUse(Data);
decode_disp('Longitude', Data) -> dec_Longitude(Data);
decode_disp('Location-quality', Data) -> 'dec_Location-quality'(Data);
decode_disp('Location-tech', Data) -> 'dec_Location-tech'(Data);
decode_disp('MergeDivergeNodeAngle', Data) -> dec_MergeDivergeNodeAngle(Data);
decode_disp('MessageBLOB', Data) -> dec_MessageBLOB(Data);
decode_disp('MinuteOfTheYear', Data) -> dec_MinuteOfTheYear(Data);
decode_disp('MinutesDuration', Data) -> dec_MinutesDuration(Data);
decode_disp('MotorizedPropelledType', Data) -> dec_MotorizedPropelledType(Data);
decode_disp('MovementPhaseState', Data) -> dec_MovementPhaseState(Data);
decode_disp('MsgCount', Data) -> dec_MsgCount(Data);
decode_disp('MsgCRC', Data) -> dec_MsgCRC(Data);
decode_disp('MultiVehicleResponse', Data) -> dec_MultiVehicleResponse(Data);
decode_disp('MUTCDCode', Data) -> dec_MUTCDCode(Data);
decode_disp('NMEA-MsgType', Data) -> 'dec_NMEA-MsgType'(Data);
decode_disp('NMEA-Payload', Data) -> 'dec_NMEA-Payload'(Data);
decode_disp('NMEA-Revision', Data) -> 'dec_NMEA-Revision'(Data);
decode_disp('NodeAttributeLL', Data) -> dec_NodeAttributeLL(Data);
decode_disp('NodeAttributeXY', Data) -> dec_NodeAttributeXY(Data);
decode_disp('NumberOfParticipantsInCluster', Data) -> dec_NumberOfParticipantsInCluster(Data);
decode_disp('ObjectCount', Data) -> dec_ObjectCount(Data);
decode_disp('ObstacleDirection', Data) -> dec_ObstacleDirection(Data);
decode_disp('ObstacleDistance', Data) -> dec_ObstacleDistance(Data);
decode_disp('Offset-B09', Data) -> 'dec_Offset-B09'(Data);
decode_disp('Offset-B10', Data) -> 'dec_Offset-B10'(Data);
decode_disp('Offset-B11', Data) -> 'dec_Offset-B11'(Data);
decode_disp('Offset-B12', Data) -> 'dec_Offset-B12'(Data);
decode_disp('Offset-B13', Data) -> 'dec_Offset-B13'(Data);
decode_disp('Offset-B14', Data) -> 'dec_Offset-B14'(Data);
decode_disp('Offset-B16', Data) -> 'dec_Offset-B16'(Data);
decode_disp('OffsetLL-B12', Data) -> 'dec_OffsetLL-B12'(Data);
decode_disp('OffsetLL-B14', Data) -> 'dec_OffsetLL-B14'(Data);
decode_disp('OffsetLL-B16', Data) -> 'dec_OffsetLL-B16'(Data);
decode_disp('OffsetLL-B18', Data) -> 'dec_OffsetLL-B18'(Data);
decode_disp('OffsetLL-B22', Data) -> 'dec_OffsetLL-B22'(Data);
decode_disp('OffsetLL-B24', Data) -> 'dec_OffsetLL-B24'(Data);
decode_disp('PayloadData', Data) -> dec_PayloadData(Data);
decode_disp('PedestrianBicycleDetect', Data) -> dec_PedestrianBicycleDetect(Data);
decode_disp('HumanPropelledType', Data) -> dec_HumanPropelledType(Data);
decode_disp('PersonalAssistive', Data) -> dec_PersonalAssistive(Data);
decode_disp('PersonalClusterRadius', Data) -> dec_PersonalClusterRadius(Data);
decode_disp('PersonalCrossingInProgress', Data) -> dec_PersonalCrossingInProgress(Data);
decode_disp('PersonalCrossingRequest', Data) -> dec_PersonalCrossingRequest(Data);
decode_disp('PersonalDeviceUsageState', Data) -> dec_PersonalDeviceUsageState(Data);
decode_disp('PersonalDeviceUserType', Data) -> dec_PersonalDeviceUserType(Data);
decode_disp('PivotingAllowed', Data) -> dec_PivotingAllowed(Data);
decode_disp('PositionConfidence', Data) -> dec_PositionConfidence(Data);
decode_disp('PrioritizationResponseStatus', Data) -> dec_PrioritizationResponseStatus(Data);
decode_disp('Priority', Data) -> dec_Priority(Data);
decode_disp('PriorityRequestType', Data) -> dec_PriorityRequestType(Data);
decode_disp('PrivilegedEventFlags', Data) -> dec_PrivilegedEventFlags(Data);
decode_disp('ProbeSegmentNumber', Data) -> dec_ProbeSegmentNumber(Data);
decode_disp('PublicSafetyAndRoadWorkerActivity', Data) -> dec_PublicSafetyAndRoadWorkerActivity(Data);
decode_disp('PublicSafetyDirectingTrafficSubType', Data) -> dec_PublicSafetyDirectingTrafficSubType(Data);
decode_disp('PublicSafetyEventResponderWorkerType', Data) -> dec_PublicSafetyEventResponderWorkerType(Data);
decode_disp('RadiusOfCurvature', Data) -> dec_RadiusOfCurvature(Data);
decode_disp('Radius-B12', Data) -> 'dec_Radius-B12'(Data);
decode_disp('RainSensor', Data) -> dec_RainSensor(Data);
decode_disp('RegionId', Data) -> dec_RegionId(Data);
decode_disp('RequestedItem', Data) -> dec_RequestedItem(Data);
decode_disp('RequestID', Data) -> dec_RequestID(Data);
decode_disp('RequestImportanceLevel', Data) -> dec_RequestImportanceLevel(Data);
decode_disp('RequestSubRole', Data) -> dec_RequestSubRole(Data);
decode_disp('ResponseType', Data) -> dec_ResponseType(Data);
decode_disp('RestrictionAppliesTo', Data) -> dec_RestrictionAppliesTo(Data);
decode_disp('RestrictionClassID', Data) -> dec_RestrictionClassID(Data);
decode_disp('RoadRegulatorID', Data) -> dec_RoadRegulatorID(Data);
decode_disp('RoadSegmentID', Data) -> dec_RoadSegmentID(Data);
decode_disp('RoadwayCrownAngle', Data) -> dec_RoadwayCrownAngle(Data);
decode_disp('RTCM-Revision', Data) -> 'dec_RTCM-Revision'(Data);
decode_disp('RTCMmessage', Data) -> dec_RTCMmessage(Data);
decode_disp('Scale-B12', Data) -> 'dec_Scale-B12'(Data);
decode_disp('SecondOfTime', Data) -> dec_SecondOfTime(Data);
decode_disp('SegmentAttributeLL', Data) -> dec_SegmentAttributeLL(Data);
decode_disp('SegmentAttributeXY', Data) -> dec_SegmentAttributeXY(Data);
decode_disp('SemiMajorAxisAccuracy', Data) -> dec_SemiMajorAxisAccuracy(Data);
decode_disp('SemiMajorAxisOrientation', Data) -> dec_SemiMajorAxisOrientation(Data);
decode_disp('SemiMinorAxisAccuracy', Data) -> dec_SemiMinorAxisAccuracy(Data);
decode_disp('SignalGroupID', Data) -> dec_SignalGroupID(Data);
decode_disp('SignalReqScheme', Data) -> dec_SignalReqScheme(Data);
decode_disp('SignPrority', Data) -> dec_SignPrority(Data);
decode_disp('SirenInUse', Data) -> dec_SirenInUse(Data);
decode_disp('SpeedAdvice', Data) -> dec_SpeedAdvice(Data);
decode_disp('SpeedConfidence', Data) -> dec_SpeedConfidence(Data);
decode_disp('SpeedLimitType', Data) -> dec_SpeedLimitType(Data);
decode_disp('SpeedProfileMeasurement', Data) -> dec_SpeedProfileMeasurement(Data);
decode_disp('Speed', Data) -> dec_Speed(Data);
decode_disp('SSPindex', Data) -> dec_SSPindex(Data);
decode_disp('StabilityControlStatus', Data) -> dec_StabilityControlStatus(Data);
decode_disp('StationID', Data) -> dec_StationID(Data);
decode_disp('SteeringWheelAngleConfidence', Data) -> dec_SteeringWheelAngleConfidence(Data);
decode_disp('SteeringWheelAngleRateOfChange', Data) -> dec_SteeringWheelAngleRateOfChange(Data);
decode_disp('SteeringWheelAngle', Data) -> dec_SteeringWheelAngle(Data);
decode_disp('SunSensor', Data) -> dec_SunSensor(Data);
decode_disp('TemporaryID', Data) -> dec_TemporaryID(Data);
decode_disp('TermDistance', Data) -> dec_TermDistance(Data);
decode_disp('TermTime', Data) -> dec_TermTime(Data);
decode_disp('ThrottleConfidence', Data) -> dec_ThrottleConfidence(Data);
decode_disp('ThrottlePosition', Data) -> dec_ThrottlePosition(Data);
decode_disp('TimeConfidence', Data) -> dec_TimeConfidence(Data);
decode_disp('TimeIntervalConfidence', Data) -> dec_TimeIntervalConfidence(Data);
decode_disp('TimeMark', Data) -> dec_TimeMark(Data);
decode_disp('TimeOffset', Data) -> dec_TimeOffset(Data);
decode_disp('TractionControlStatus', Data) -> dec_TractionControlStatus(Data);
decode_disp('TrailerMass', Data) -> dec_TrailerMass(Data);
decode_disp('TransitStatus', Data) -> dec_TransitStatus(Data);
decode_disp('TransitVehicleOccupancy', Data) -> dec_TransitVehicleOccupancy(Data);
decode_disp('TransitVehicleStatus', Data) -> dec_TransitVehicleStatus(Data);
decode_disp('TransmissionState', Data) -> dec_TransmissionState(Data);
decode_disp('TravelerInfoType', Data) -> dec_TravelerInfoType(Data);
decode_disp('UniqueMSGID', Data) -> dec_UniqueMSGID(Data);
decode_disp('URL-Base', Data) -> 'dec_URL-Base'(Data);
decode_disp('URL-Link', Data) -> 'dec_URL-Link'(Data);
decode_disp('URL-Short', Data) -> 'dec_URL-Short'(Data);
decode_disp('UserSizeAndBehaviour', Data) -> dec_UserSizeAndBehaviour(Data);
decode_disp('VehicleEventFlags', Data) -> dec_VehicleEventFlags(Data);
decode_disp('VehicleHeight', Data) -> dec_VehicleHeight(Data);
decode_disp('VehicleLength', Data) -> dec_VehicleLength(Data);
decode_disp('VehicleMass', Data) -> dec_VehicleMass(Data);
decode_disp('VehicleStatusDeviceTypeTag', Data) -> dec_VehicleStatusDeviceTypeTag(Data);
decode_disp('VehicleType', Data) -> dec_VehicleType(Data);
decode_disp('VehicleWidth', Data) -> dec_VehicleWidth(Data);
decode_disp('Velocity', Data) -> dec_Velocity(Data);
decode_disp('VerticalAccelerationThreshold', Data) -> dec_VerticalAccelerationThreshold(Data);
decode_disp('VerticalAcceleration', Data) -> dec_VerticalAcceleration(Data);
decode_disp('VertOffset-B07', Data) -> 'dec_VertOffset-B07'(Data);
decode_disp('VertOffset-B08', Data) -> 'dec_VertOffset-B08'(Data);
decode_disp('VertOffset-B09', Data) -> 'dec_VertOffset-B09'(Data);
decode_disp('VertOffset-B10', Data) -> 'dec_VertOffset-B10'(Data);
decode_disp('VertOffset-B11', Data) -> 'dec_VertOffset-B11'(Data);
decode_disp('VertOffset-B12', Data) -> 'dec_VertOffset-B12'(Data);
decode_disp('VINstring', Data) -> dec_VINstring(Data);
decode_disp('WaitOnStopline', Data) -> dec_WaitOnStopline(Data);
decode_disp('WiperRate', Data) -> dec_WiperRate(Data);
decode_disp('WiperStatus', Data) -> dec_WiperStatus(Data);
decode_disp('YawRateConfidence', Data) -> dec_YawRateConfidence(Data);
decode_disp('YawRate', Data) -> dec_YawRate(Data);
decode_disp('ZoneLength', Data) -> dec_ZoneLength(Data);
decode_disp('Zoom', Data) -> dec_Zoom(Data);
decode_disp(Type, _Data) -> exit({error,{asn1,{undefined_type,Type}}}).

info() ->
   case ?MODULE:module_info(attributes) of
     Attributes when is_list(Attributes) ->
       case lists:keyfind(asn1_info, 1, Attributes) of
         {_,Info} when is_list(Info) ->
           Info;
         _ ->
           []
       end;
     _ ->
       []
   end.
enc_MessageFrame(Val) ->
#{messageId:=Input@1,value:=Input@2} = Val,
[begin
%% attribute messageId(1) with type INTEGER
if Input@1 bsr 15 =:= 0 ->
<<0:1,Input@1:15>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute value(2) with type Type
Enc3@output = enc_os_Type1(Input@2, Input@1),
Enc3@bin = complete(Enc3@output),
Enc3@len = byte_size(Enc3@bin),
if Enc3@len < 128 ->
[Enc3@len|Enc3@bin];
Enc3@len < 16384 ->
[<<2:2,Enc3@len:14>>|Enc3@bin];
true ->
encode_fragmented(Enc3@bin, 8)
end
end].


dec_MessageFrame(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute messageId(1) with type INTEGER
{Term1,Bytes2} = begin
<<V2@V0:15,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute value(2) with type Type
{Tmpterm1, Bytes3} = begin
{V3@V0,V3@Buf1} = case Bytes2 of
<<0:1,V3@V3:7,V3@V5:V3@V3/binary-unit:8,V3@Buf6/bitstring>> ->
{V3@V5,V3@Buf6};
<<1:1,0:1,V3@V4:14,V3@V6:V3@V4/binary-unit:8,V3@Buf7/bitstring>> ->
{V3@V6,V3@Buf7};
<<1:1,1:1,V3@V4:6,V3@Buf5/bitstring>> ->
{V3@V6,V3@Buf7}  = decode_fragmented(V3@V4, V3@Buf5, 8),
{V3@V6,V3@Buf7}
end,
{V3@V0,V3@Buf1}
end,

%% Extensions
{Extensions,Bytes4} = case Ext of
0 -> {<<>>,Bytes3};
1 ->
{V4@V0,V4@Buf1} = case Bytes3 of
<<0:1,V4@V3:6,V4@Buf4/bitstring>> ->
V4@Add5 = V4@V3 + 1,
{V4@Add5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:7,V4@Buf7/bitstring>> when V4@V6 =/= 0 ->
{V4@V6,V4@Buf7};
<<1:1,0:1,V4@V7:14,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
{V4@V7,V4@Buf8}
end,
{V4@V3,V4@Buf4}
end,
<<V4@V9:V4@V0/bitstring-unit:1,V4@Buf10/bitstring>> = V4@Buf1,
{V4@V9,V4@Buf10}
end,
Bytes5= skipextensions(Bytes4, 1, Extensions),
Term2 = dec_os_Type2(Tmpterm1, Term1),
Res1 = #{messageId=>Term1,value=>Term2},
{Res1,Bytes5}.

enc_BasicSafetyMessage(Val) ->
#{coreData:=Input@1} = Val,
Input@2 = case Val of
  #{partII:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{regional:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@2 =:= asn1__MISSING_IN_MAP ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
begin
%% attribute coreData(1) with type BSMcoreData
enc_BSMcoreData(Input@1)
end,
begin
%% attribute partII(2) with type SEQUENCE OF
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_BasicSafetyMessage_partII(Input@2)
end
end|begin
%% attribute regional(3) with type SEQUENCE OF
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_BasicSafetyMessage_regional(Input@3)
end
end].
enc_BasicSafetyMessage_partII(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 3 =:= 0 ->
[<<Enc1@len@sub:3>>|[enc_BasicSafetyMessage_partII_PartIIcontent(Comp) || Comp <- Val]]
end.

enc_BasicSafetyMessage_partII_PartIIcontent(Val) ->
#{'partII-Id':=Input@1,'partII-Value':=Input@2} = Val,
[begin
%% attribute partII-Id(1) with type INTEGER
if Input@1 bsr 6 =:= 0 ->
<<Input@1:6>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute partII-Value(2) with type Type
Enc2@output = enc_os_Type3(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].
enc_BasicSafetyMessage_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_BasicSafetyMessage_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_BasicSafetyMessage_regional_RegionalExtension(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_BasicSafetyMessage(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute coreData(1) with type BSMcoreData
{Term1,Bytes3} = dec_BSMcoreData(Bytes2),

%% attribute partII(2) with type SEQUENCE OF
{Term2,Bytes4} = case (Opt bsr 1) band 1 of
1 ->
dec_BasicSafetyMessage_partII(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute regional(3) with type SEQUENCE OF
{Term3,Bytes5} = case Opt band 1 of
1 ->
dec_BasicSafetyMessage_regional(Bytes4);
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% Extensions
{Extensions,Bytes6} = case Ext of
0 -> {<<>>,Bytes5};
1 ->
{V3@V0,V3@Buf1} = case Bytes5 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V9:V3@V0/bitstring-unit:1,V3@Buf10/bitstring>> = V3@Buf1,
{V3@V9,V3@Buf10}
end,
Bytes7= skipextensions(Bytes6, 1, Extensions),
Res1 = #{coreData=>Term1},
Res2 = case Term2 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{partII=>Term2}
end,
Res3 = case Term3 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{regional=>Term3}
end,
{Res3,Bytes7}.


dec_BasicSafetyMessage_partII(Bytes) ->
%% Length with constraint {1,8}
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components5(V1@Add2, V1@Buf1, []).


dec_BasicSafetyMessage_partII_PartIIcontent(Bytes) ->

%% attribute partII-Id(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:6,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute partII-Value(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type6(Tmpterm1, Term1),
Res1 = #{'partII-Id'=>Term1,'partII-Value'=>Term2},
{Res1,Bytes2}.


dec_BasicSafetyMessage_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components7(V1@Add2, V1@Buf1, []).


dec_BasicSafetyMessage_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

'enc_PartII-Id'(Val) ->
if Val bsr 6 =:= 0 ->
<<Val:6>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


'dec_PartII-Id'(Bytes) ->
begin
<<V1@V0:6,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_CommonSafetyRequest(Val) ->
#{requests:=Input@4} = Val,
Input@1 = case Val of
  #{timeStamp:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{msgCnt:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{id:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{regional:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@3 =:= asn1__MISSING_IN_MAP ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
begin
%% attribute timeStamp(1) with type INTEGER
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@1, Input@1 < 527041 ->
<<Input@1:20>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute msgCnt(2) with type INTEGER
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
Input@2 bsr 7 =:= 0 ->
<<Input@2:7>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end,
begin
%% attribute id(3) with type OCTET STRING
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
enc_Binary_Id(Input@3)
end
end
end,
begin
%% attribute requests(4) with type RequestedItemList
enc_RequestedItemList(Input@4)
end|begin
%% attribute regional(5) with type SEQUENCE OF
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_CommonSafetyRequest_regional(Input@5)
end
end].
enc_CommonSafetyRequest_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_CommonSafetyRequest_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_CommonSafetyRequest_regional_RegionalExtension(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_CommonSafetyRequest(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:4,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute timeStamp(1) with type INTEGER
{Term1,Bytes3} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V3@V0:20,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute msgCnt(2) with type INTEGER
{Term2,Bytes4} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V4@V0:7,V4@Buf1/bitstring>> = Bytes3,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute id(3) with type OCTET STRING
{Term3,Bytes5} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V5@V0:4/binary-unit:8,V5@Buf1/bitstring>> = Bytes4,
V5@Conv2 = binary:copy(V5@V0),
{dec_Binary_Id(V5@Conv2),V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute requests(4) with type RequestedItemList
{Term4,Bytes6} = dec_RequestedItemList(Bytes5),

%% attribute regional(5) with type SEQUENCE OF
{Term5,Bytes7} = case Opt band 1 of
1 ->
dec_CommonSafetyRequest_regional(Bytes6);
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% Extensions
{Extensions,Bytes8} = case Ext of
0 -> {<<>>,Bytes7};
1 ->
{V6@V0,V6@Buf1} = case Bytes7 of
<<0:1,V6@V3:6,V6@Buf4/bitstring>> ->
V6@Add5 = V6@V3 + 1,
{V6@Add5,V6@Buf4};
<<1:1,V6@Buf2/bitstring>> ->
{V6@V3,V6@Buf4} = case V6@Buf2 of
<<0:1,V6@V6:7,V6@Buf7/bitstring>> when V6@V6 =/= 0 ->
{V6@V6,V6@Buf7};
<<1:1,0:1,V6@V7:14,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
{V6@V7,V6@Buf8}
end,
{V6@V3,V6@Buf4}
end,
<<V6@V9:V6@V0/bitstring-unit:1,V6@Buf10/bitstring>> = V6@Buf1,
{V6@V9,V6@Buf10}
end,
Bytes9= skipextensions(Bytes8, 1, Extensions),
Res1 = #{requests=>Term4},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{timeStamp=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{msgCnt=>Term2}
end,
Res4 = case Term3 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{id=>Term3}
end,
Res5 = case Term5 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{regional=>Term5}
end,
{Res5,Bytes9}.


dec_CommonSafetyRequest_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components9(V1@Add2, V1@Buf1, []).


dec_CommonSafetyRequest_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_EmergencyVehicleAlert(Val) ->
#{rsaMsg:=Input@3} = Val,
Input@1 = case Val of
  #{timeStamp:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{id:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{responseType:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{details:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@6 = case Val of
  #{mass:=Input@6_0} -> Input@6_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@7 = case Val of
  #{basicType:=Input@7_0} -> Input@7_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@8 = case Val of
  #{vehicleType:=Input@8_0} -> Input@8_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@9 = case Val of
  #{responseEquip:=Input@9_0} -> Input@9_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@10 = case Val of
  #{responderType:=Input@10_0} -> Input@10_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@11 = case Val of
  #{regional:=Input@11_0} -> Input@11_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@4 =:= asn1__MISSING_IN_MAP ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@6 =:= asn1__MISSING_IN_MAP ->
if Input@7 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@7 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@8 =:= asn1__MISSING_IN_MAP ->
if Input@9 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@9 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@10 =:= asn1__MISSING_IN_MAP ->
if Input@11 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@11 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
begin
%% attribute timeStamp(1) with type INTEGER
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@1, Input@1 < 527041 ->
<<Input@1:20>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute id(2) with type OCTET STRING
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
enc_Binary_Id(Input@2)
end
end
end,
begin
%% attribute rsaMsg(3) with type RoadSideAlert
enc_RoadSideAlert(Input@3)
end,
begin
%% attribute responseType(4) with type ENUMERATED
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
Input@4 =:= notInUseOrNotEquipped ->
<<0:1,0:3>>;
Input@4 =:= emergency ->
<<0:1,1:3>>;
Input@4 =:= nonEmergency ->
<<0:1,2:3>>;
Input@4 =:= pursuit ->
<<0:1,3:3>>;
Input@4 =:= stationary ->
<<0:1,4:3>>;
Input@4 =:= slowMoving ->
<<0:1,5:3>>;
Input@4 =:= stopAndGoMovement ->
<<0:1,6:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@4}}})
end
end,
begin
%% attribute details(5) with type EmergencyDetails
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_EmergencyDetails(Input@5)
end
end,
begin
%% attribute mass(6) with type INTEGER
if Input@6 =:= asn1__MISSING_IN_MAP ->
[];
Input@6 bsr 8 =:= 0 ->
Input@6;
true ->
exit({error,{asn1,{illegal_integer,Input@6}}})
end
end,
begin
%% attribute basicType(7) with type ENUMERATED
if Input@7 =:= asn1__MISSING_IN_MAP ->
[];
Input@7 =:= none ->
<<0:1,0:4>>;
Input@7 =:= unknown ->
<<0:1,1:4>>;
Input@7 =:= special ->
<<0:1,2:4>>;
Input@7 =:= moto ->
<<0:1,3:4>>;
Input@7 =:= car ->
<<0:1,4:4>>;
Input@7 =:= carOther ->
<<0:1,5:4>>;
Input@7 =:= bus ->
<<0:1,6:4>>;
Input@7 =:= axleCnt2 ->
<<0:1,7:4>>;
Input@7 =:= axleCnt3 ->
<<0:1,8:4>>;
Input@7 =:= axleCnt4 ->
<<0:1,9:4>>;
Input@7 =:= axleCnt4Trailer ->
<<0:1,10:4>>;
Input@7 =:= axleCnt5Trailer ->
<<0:1,11:4>>;
Input@7 =:= axleCnt6Trailer ->
<<0:1,12:4>>;
Input@7 =:= axleCnt5MultiTrailer ->
<<0:1,13:4>>;
Input@7 =:= axleCnt6MultiTrailer ->
<<0:1,14:4>>;
Input@7 =:= axleCnt7MultiTrailer ->
<<0:1,15:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@7}}})
end
end,
begin
%% attribute vehicleType(8) with type ENUMERATED
if Input@8 =:= asn1__MISSING_IN_MAP ->
[];
Input@8 =:= 'all-vehicles' ->
<<0:1,0:6>>;
Input@8 =:= bicycles ->
<<0:1,1:6>>;
Input@8 =:= motorcycles ->
<<0:1,2:6>>;
Input@8 =:= cars ->
<<0:1,3:6>>;
Input@8 =:= 'light-vehicles' ->
<<0:1,4:6>>;
Input@8 =:= 'cars-and-light-vehicles' ->
<<0:1,5:6>>;
Input@8 =:= 'cars-with-trailers' ->
<<0:1,6:6>>;
Input@8 =:= 'cars-with-recreational-trailers' ->
<<0:1,7:6>>;
Input@8 =:= 'vehicles-with-trailers' ->
<<0:1,8:6>>;
Input@8 =:= 'heavy-vehicles' ->
<<0:1,9:6>>;
Input@8 =:= trucks ->
<<0:1,10:6>>;
Input@8 =:= buses ->
<<0:1,11:6>>;
Input@8 =:= 'articulated-buses' ->
<<0:1,12:6>>;
Input@8 =:= 'school-buses' ->
<<0:1,13:6>>;
Input@8 =:= 'vehicles-with-semi-trailers' ->
<<0:1,14:6>>;
Input@8 =:= 'vehicles-with-double-trailers' ->
<<0:1,15:6>>;
Input@8 =:= 'high-profile-vehicles' ->
<<0:1,16:6>>;
Input@8 =:= 'wide-vehicles' ->
<<0:1,17:6>>;
Input@8 =:= 'long-vehicles' ->
<<0:1,18:6>>;
Input@8 =:= 'hazardous-loads' ->
<<0:1,19:6>>;
Input@8 =:= 'exceptional-loads' ->
<<0:1,20:6>>;
Input@8 =:= 'abnormal-loads' ->
<<0:1,21:6>>;
Input@8 =:= convoys ->
<<0:1,22:6>>;
Input@8 =:= 'maintenance-vehicles' ->
<<0:1,23:6>>;
Input@8 =:= 'delivery-vehicles' ->
<<0:1,24:6>>;
Input@8 =:= 'vehicles-with-even-numbered-license-plates' ->
<<0:1,25:6>>;
Input@8 =:= 'vehicles-with-odd-numbered-license-plates' ->
<<0:1,26:6>>;
Input@8 =:= 'vehicles-with-parking-permits' ->
<<0:1,27:6>>;
Input@8 =:= 'vehicles-with-catalytic-converters' ->
<<0:1,28:6>>;
Input@8 =:= 'vehicles-without-catalytic-converters' ->
<<0:1,29:6>>;
Input@8 =:= 'gas-powered-vehicles' ->
<<0:1,30:6>>;
Input@8 =:= 'diesel-powered-vehicles' ->
<<0:1,31:6>>;
Input@8 =:= 'lPG-vehicles' ->
<<0:1,32:6>>;
Input@8 =:= 'military-convoys' ->
<<0:1,33:6>>;
Input@8 =:= 'military-vehicles' ->
<<0:1,34:6>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@8}}})
end
end,
begin
%% attribute responseEquip(9) with type ENUMERATED
if Input@9 =:= asn1__MISSING_IN_MAP ->
[];
Input@9 =:= 'ground-fire-suppression' ->
<<0:1,0:7>>;
Input@9 =:= 'heavy-ground-equipment' ->
<<0:1,1:7>>;
Input@9 =:= aircraft ->
<<0:1,2:7>>;
Input@9 =:= 'marine-equipment' ->
<<0:1,3:7>>;
Input@9 =:= 'support-equipment' ->
<<0:1,4:7>>;
Input@9 =:= 'medical-rescue-unit' ->
<<0:1,5:7>>;
Input@9 =:= other ->
<<0:1,6:7>>;
Input@9 =:= 'ground-fire-suppression-other' ->
<<0:1,7:7>>;
Input@9 =:= engine ->
<<0:1,8:7>>;
Input@9 =:= 'truck-or-aerial' ->
<<0:1,9:7>>;
Input@9 =:= quint ->
<<0:1,10:7>>;
Input@9 =:= 'tanker-pumper-combination' ->
<<0:1,11:7>>;
Input@9 =:= 'brush-truck' ->
<<0:1,12:7>>;
Input@9 =:= 'aircraft-rescue-firefighting' ->
<<0:1,13:7>>;
Input@9 =:= 'heavy-ground-equipment-other' ->
<<0:1,14:7>>;
Input@9 =:= 'dozer-or-plow' ->
<<0:1,15:7>>;
Input@9 =:= tractor ->
<<0:1,16:7>>;
Input@9 =:= 'tanker-or-tender' ->
<<0:1,17:7>>;
Input@9 =:= 'aircraft-other' ->
<<0:1,18:7>>;
Input@9 =:= 'aircraft-fixed-wing-tanker' ->
<<0:1,19:7>>;
Input@9 =:= helitanker ->
<<0:1,20:7>>;
Input@9 =:= helicopter ->
<<0:1,21:7>>;
Input@9 =:= 'marine-equipment-other' ->
<<0:1,22:7>>;
Input@9 =:= 'fire-boat-with-pump' ->
<<0:1,23:7>>;
Input@9 =:= 'boat-no-pump' ->
<<0:1,24:7>>;
Input@9 =:= 'support-apparatus-other' ->
<<0:1,25:7>>;
Input@9 =:= 'breathing-apparatus-support' ->
<<0:1,26:7>>;
Input@9 =:= 'light-and-air-unit' ->
<<0:1,27:7>>;
Input@9 =:= 'medical-rescue-unit-other' ->
<<0:1,28:7>>;
Input@9 =:= 'rescue-unit' ->
<<0:1,29:7>>;
Input@9 =:= 'urban-search-rescue-unit' ->
<<0:1,30:7>>;
Input@9 =:= 'high-angle-rescue' ->
<<0:1,31:7>>;
Input@9 =:= 'crash-fire-rescue' ->
<<0:1,32:7>>;
Input@9 =:= 'bLS-unit' ->
<<0:1,33:7>>;
Input@9 =:= 'aLS-unit' ->
<<0:1,34:7>>;
Input@9 =:= 'mobile-command-post' ->
<<0:1,35:7>>;
Input@9 =:= 'chief-officer-car' ->
<<0:1,36:7>>;
Input@9 =:= 'hAZMAT-unit' ->
<<0:1,37:7>>;
Input@9 =:= 'type-i-hand-crew' ->
<<0:1,38:7>>;
Input@9 =:= 'type-ii-hand-crew' ->
<<0:1,39:7>>;
Input@9 =:= 'privately-owned-vehicle' ->
<<0:1,40:7>>;
Input@9 =:= 'other-apparatus-resource' ->
<<0:1,41:7>>;
Input@9 =:= ambulance ->
<<0:1,42:7>>;
Input@9 =:= 'bomb-squad-van' ->
<<0:1,43:7>>;
Input@9 =:= 'combine-harvester' ->
<<0:1,44:7>>;
Input@9 =:= 'construction-vehicle' ->
<<0:1,45:7>>;
Input@9 =:= 'farm-tractor' ->
<<0:1,46:7>>;
Input@9 =:= 'grass-cutting-machines' ->
<<0:1,47:7>>;
Input@9 =:= 'hAZMAT-containment-tow' ->
<<0:1,48:7>>;
Input@9 =:= 'heavy-tow' ->
<<0:1,49:7>>;
Input@9 =:= 'hedge-cutting-machines' ->
<<0:1,50:7>>;
Input@9 =:= 'light-tow' ->
<<0:1,51:7>>;
Input@9 =:= 'mobile-crane' ->
<<0:1,52:7>>;
Input@9 =:= 'refuse-collection-vehicle' ->
<<0:1,53:7>>;
Input@9 =:= 'resurfacing-vehicle' ->
<<0:1,54:7>>;
Input@9 =:= 'road-sweeper' ->
<<0:1,55:7>>;
Input@9 =:= 'roadside-litter-collection-crews' ->
<<0:1,56:7>>;
Input@9 =:= 'salvage-vehicle' ->
<<0:1,57:7>>;
Input@9 =:= 'sand-truck' ->
<<0:1,58:7>>;
Input@9 =:= snowplow ->
<<0:1,59:7>>;
Input@9 =:= 'steam-roller' ->
<<0:1,60:7>>;
Input@9 =:= 'swat-team-van' ->
<<0:1,61:7>>;
Input@9 =:= 'track-laying-vehicle' ->
<<0:1,62:7>>;
Input@9 =:= 'unknown-vehicle' ->
<<0:1,63:7>>;
Input@9 =:= 'white-lining-vehicle' ->
<<0:1,64:7>>;
Input@9 =:= 'dump-truck' ->
<<0:1,65:7>>;
Input@9 =:= 'supervisor-vehicle' ->
<<0:1,66:7>>;
Input@9 =:= 'snow-blower' ->
<<0:1,67:7>>;
Input@9 =:= 'rotary-snow-blower' ->
<<0:1,68:7>>;
Input@9 =:= 'road-grader' ->
<<0:1,69:7>>;
Input@9 =:= 'steam-truck' ->
<<0:1,70:7>>;
Input@9 =:= 'flatbed-tow' ->
<<0:1,71:7>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@9}}})
end
end,
begin
%% attribute responderType(10) with type ENUMERATED
if Input@10 =:= asn1__MISSING_IN_MAP ->
[];
Input@10 =:= 'emergency-vehicle-units' ->
<<0:1,0:4>>;
Input@10 =:= 'federal-law-enforcement-units' ->
<<0:1,1:4>>;
Input@10 =:= 'state-police-units' ->
<<0:1,2:4>>;
Input@10 =:= 'county-police-units' ->
<<0:1,3:4>>;
Input@10 =:= 'local-police-units' ->
<<0:1,4:4>>;
Input@10 =:= 'ambulance-units' ->
<<0:1,5:4>>;
Input@10 =:= 'rescue-units' ->
<<0:1,6:4>>;
Input@10 =:= 'fire-units' ->
<<0:1,7:4>>;
Input@10 =:= 'hAZMAT-units' ->
<<0:1,8:4>>;
Input@10 =:= 'light-tow-unit' ->
<<0:1,9:4>>;
Input@10 =:= 'heavy-tow-unit' ->
<<0:1,10:4>>;
Input@10 =:= 'freeway-service-patrols' ->
<<0:1,11:4>>;
Input@10 =:= 'transportation-response-units' ->
<<0:1,12:4>>;
Input@10 =:= 'private-contractor-response-units' ->
<<0:1,13:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@10}}})
end
end|begin
%% attribute regional(11) with type SEQUENCE OF
if Input@11 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_EmergencyVehicleAlert_regional(Input@11)
end
end].
enc_EmergencyVehicleAlert_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_EmergencyVehicleAlert_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_EmergencyVehicleAlert_regional_RegionalExtension(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_EmergencyVehicleAlert(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:10,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute timeStamp(1) with type INTEGER
{Term1,Bytes3} = case (Opt bsr 9) band 1 of
1 ->
begin
<<V3@V0:20,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute id(2) with type OCTET STRING
{Term2,Bytes4} = case (Opt bsr 8) band 1 of
1 ->
begin
<<V4@V0:4/binary-unit:8,V4@Buf1/bitstring>> = Bytes3,
V4@Conv2 = binary:copy(V4@V0),
{dec_Binary_Id(V4@Conv2),V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute rsaMsg(3) with type RoadSideAlert
{Term3,Bytes5} = dec_RoadSideAlert(Bytes4),

%% attribute responseType(4) with type ENUMERATED
{Term4,Bytes6} = case (Opt bsr 7) band 1 of
1 ->
begin
{V5@V0,V5@Buf1} = case Bytes5 of
<<0:1,V5@V3:3,V5@Buf4/bitstring>> ->
V5@Int5 = case V5@V3 of
0 -> notInUseOrNotEquipped;
1 -> emergency;
2 -> nonEmergency;
3 -> pursuit;
4 -> stationary;
5 -> slowMoving;
6 -> stopAndGoMovement;
_ -> exit({error,{asn1,{decode_enumerated,V5@V3}}})
end,
{V5@Int5,V5@Buf4};
<<1:1,V5@Buf2/bitstring>> ->
{V5@V3,V5@Buf4} = case V5@Buf2 of
<<0:1,V5@V6:6,V5@Buf7/bitstring>> ->
{V5@V6,V5@Buf7};
<<1:1,V5@Buf5/bitstring>> ->
{V5@V6,V5@Buf7} = case V5@Buf5 of
<<0:1,V5@V9:7,V5@Buf10/bitstring>> when V5@V9 =/= 0 ->
{V5@V9,V5@Buf10};
<<1:1,0:1,V5@V10:14,V5@Buf11/bitstring>> when V5@V10 =/= 0 ->
{V5@V10,V5@Buf11}
end,
<<V5@V12:V5@V6/unit:8,V5@Buf13/bitstring>> = V5@Buf7,
{V5@V12,V5@Buf13}
end,
V5@Int14 = case V5@V3 of
_ -> {asn1_enum,V5@V3}
end,
{V5@Int14,V5@Buf4}
end,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute details(5) with type EmergencyDetails
{Term5,Bytes7} = case (Opt bsr 6) band 1 of
1 ->
dec_EmergencyDetails(Bytes6);
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute mass(6) with type INTEGER
{Term6,Bytes8} = case (Opt bsr 5) band 1 of
1 ->
begin
<<V6@V0:8,V6@Buf1/bitstring>> = Bytes7,
{V6@V0,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute basicType(7) with type ENUMERATED
{Term7,Bytes9} = case (Opt bsr 4) band 1 of
1 ->
begin
{V7@V0,V7@Buf1} = case Bytes8 of
<<0:1,V7@V3:4,V7@Buf4/bitstring>> ->
V7@Int5 = case V7@V3 of
0 -> none;
1 -> unknown;
2 -> special;
3 -> moto;
4 -> car;
5 -> carOther;
6 -> bus;
7 -> axleCnt2;
8 -> axleCnt3;
9 -> axleCnt4;
10 -> axleCnt4Trailer;
11 -> axleCnt5Trailer;
12 -> axleCnt6Trailer;
13 -> axleCnt5MultiTrailer;
14 -> axleCnt6MultiTrailer;
15 -> axleCnt7MultiTrailer
end,
{V7@Int5,V7@Buf4};
<<1:1,V7@Buf2/bitstring>> ->
{V7@V3,V7@Buf4} = case V7@Buf2 of
<<0:1,V7@V6:6,V7@Buf7/bitstring>> ->
{V7@V6,V7@Buf7};
<<1:1,V7@Buf5/bitstring>> ->
{V7@V6,V7@Buf7} = case V7@Buf5 of
<<0:1,V7@V9:7,V7@Buf10/bitstring>> when V7@V9 =/= 0 ->
{V7@V9,V7@Buf10};
<<1:1,0:1,V7@V10:14,V7@Buf11/bitstring>> when V7@V10 =/= 0 ->
{V7@V10,V7@Buf11}
end,
<<V7@V12:V7@V6/unit:8,V7@Buf13/bitstring>> = V7@Buf7,
{V7@V12,V7@Buf13}
end,
V7@Int14 = case V7@V3 of
_ -> {asn1_enum,V7@V3}
end,
{V7@Int14,V7@Buf4}
end,
{V7@V0,V7@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% attribute vehicleType(8) with type ENUMERATED
{Term8,Bytes10} = case (Opt bsr 3) band 1 of
1 ->
begin
{V8@V0,V8@Buf1} = case Bytes9 of
<<0:1,V8@V3:6,V8@Buf4/bitstring>> ->
V8@Int5 = case V8@V3 of
0 -> 'all-vehicles';
1 -> bicycles;
2 -> motorcycles;
3 -> cars;
4 -> 'light-vehicles';
5 -> 'cars-and-light-vehicles';
6 -> 'cars-with-trailers';
7 -> 'cars-with-recreational-trailers';
8 -> 'vehicles-with-trailers';
9 -> 'heavy-vehicles';
10 -> trucks;
11 -> buses;
12 -> 'articulated-buses';
13 -> 'school-buses';
14 -> 'vehicles-with-semi-trailers';
15 -> 'vehicles-with-double-trailers';
16 -> 'high-profile-vehicles';
17 -> 'wide-vehicles';
18 -> 'long-vehicles';
19 -> 'hazardous-loads';
20 -> 'exceptional-loads';
21 -> 'abnormal-loads';
22 -> convoys;
23 -> 'maintenance-vehicles';
24 -> 'delivery-vehicles';
25 -> 'vehicles-with-even-numbered-license-plates';
26 -> 'vehicles-with-odd-numbered-license-plates';
27 -> 'vehicles-with-parking-permits';
28 -> 'vehicles-with-catalytic-converters';
29 -> 'vehicles-without-catalytic-converters';
30 -> 'gas-powered-vehicles';
31 -> 'diesel-powered-vehicles';
32 -> 'lPG-vehicles';
33 -> 'military-convoys';
34 -> 'military-vehicles';
_ -> exit({error,{asn1,{decode_enumerated,V8@V3}}})
end,
{V8@Int5,V8@Buf4};
<<1:1,V8@Buf2/bitstring>> ->
{V8@V3,V8@Buf4} = case V8@Buf2 of
<<0:1,V8@V6:6,V8@Buf7/bitstring>> ->
{V8@V6,V8@Buf7};
<<1:1,V8@Buf5/bitstring>> ->
{V8@V6,V8@Buf7} = case V8@Buf5 of
<<0:1,V8@V9:7,V8@Buf10/bitstring>> when V8@V9 =/= 0 ->
{V8@V9,V8@Buf10};
<<1:1,0:1,V8@V10:14,V8@Buf11/bitstring>> when V8@V10 =/= 0 ->
{V8@V10,V8@Buf11}
end,
<<V8@V12:V8@V6/unit:8,V8@Buf13/bitstring>> = V8@Buf7,
{V8@V12,V8@Buf13}
end,
V8@Int14 = case V8@V3 of
_ -> {asn1_enum,V8@V3}
end,
{V8@Int14,V8@Buf4}
end,
{V8@V0,V8@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes9}
end,

%% attribute responseEquip(9) with type ENUMERATED
{Term9,Bytes11} = case (Opt bsr 2) band 1 of
1 ->
begin
{V9@V0,V9@Buf1} = case Bytes10 of
<<0:1,V9@V3:7,V9@Buf4/bitstring>> ->
V9@Int5 = case V9@V3 of
0 -> 'ground-fire-suppression';
1 -> 'heavy-ground-equipment';
2 -> aircraft;
3 -> 'marine-equipment';
4 -> 'support-equipment';
5 -> 'medical-rescue-unit';
6 -> other;
7 -> 'ground-fire-suppression-other';
8 -> engine;
9 -> 'truck-or-aerial';
10 -> quint;
11 -> 'tanker-pumper-combination';
12 -> 'brush-truck';
13 -> 'aircraft-rescue-firefighting';
14 -> 'heavy-ground-equipment-other';
15 -> 'dozer-or-plow';
16 -> tractor;
17 -> 'tanker-or-tender';
18 -> 'aircraft-other';
19 -> 'aircraft-fixed-wing-tanker';
20 -> helitanker;
21 -> helicopter;
22 -> 'marine-equipment-other';
23 -> 'fire-boat-with-pump';
24 -> 'boat-no-pump';
25 -> 'support-apparatus-other';
26 -> 'breathing-apparatus-support';
27 -> 'light-and-air-unit';
28 -> 'medical-rescue-unit-other';
29 -> 'rescue-unit';
30 -> 'urban-search-rescue-unit';
31 -> 'high-angle-rescue';
32 -> 'crash-fire-rescue';
33 -> 'bLS-unit';
34 -> 'aLS-unit';
35 -> 'mobile-command-post';
36 -> 'chief-officer-car';
37 -> 'hAZMAT-unit';
38 -> 'type-i-hand-crew';
39 -> 'type-ii-hand-crew';
40 -> 'privately-owned-vehicle';
41 -> 'other-apparatus-resource';
42 -> ambulance;
43 -> 'bomb-squad-van';
44 -> 'combine-harvester';
45 -> 'construction-vehicle';
46 -> 'farm-tractor';
47 -> 'grass-cutting-machines';
48 -> 'hAZMAT-containment-tow';
49 -> 'heavy-tow';
50 -> 'hedge-cutting-machines';
51 -> 'light-tow';
52 -> 'mobile-crane';
53 -> 'refuse-collection-vehicle';
54 -> 'resurfacing-vehicle';
55 -> 'road-sweeper';
56 -> 'roadside-litter-collection-crews';
57 -> 'salvage-vehicle';
58 -> 'sand-truck';
59 -> snowplow;
60 -> 'steam-roller';
61 -> 'swat-team-van';
62 -> 'track-laying-vehicle';
63 -> 'unknown-vehicle';
64 -> 'white-lining-vehicle';
65 -> 'dump-truck';
66 -> 'supervisor-vehicle';
67 -> 'snow-blower';
68 -> 'rotary-snow-blower';
69 -> 'road-grader';
70 -> 'steam-truck';
71 -> 'flatbed-tow';
_ -> exit({error,{asn1,{decode_enumerated,V9@V3}}})
end,
{V9@Int5,V9@Buf4};
<<1:1,V9@Buf2/bitstring>> ->
{V9@V3,V9@Buf4} = case V9@Buf2 of
<<0:1,V9@V6:6,V9@Buf7/bitstring>> ->
{V9@V6,V9@Buf7};
<<1:1,V9@Buf5/bitstring>> ->
{V9@V6,V9@Buf7} = case V9@Buf5 of
<<0:1,V9@V9:7,V9@Buf10/bitstring>> when V9@V9 =/= 0 ->
{V9@V9,V9@Buf10};
<<1:1,0:1,V9@V10:14,V9@Buf11/bitstring>> when V9@V10 =/= 0 ->
{V9@V10,V9@Buf11}
end,
<<V9@V12:V9@V6/unit:8,V9@Buf13/bitstring>> = V9@Buf7,
{V9@V12,V9@Buf13}
end,
V9@Int14 = case V9@V3 of
_ -> {asn1_enum,V9@V3}
end,
{V9@Int14,V9@Buf4}
end,
{V9@V0,V9@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes10}
end,

%% attribute responderType(10) with type ENUMERATED
{Term10,Bytes12} = case (Opt bsr 1) band 1 of
1 ->
begin
{V10@V0,V10@Buf1} = case Bytes11 of
<<0:1,V10@V3:4,V10@Buf4/bitstring>> ->
V10@Int5 = case V10@V3 of
0 -> 'emergency-vehicle-units';
1 -> 'federal-law-enforcement-units';
2 -> 'state-police-units';
3 -> 'county-police-units';
4 -> 'local-police-units';
5 -> 'ambulance-units';
6 -> 'rescue-units';
7 -> 'fire-units';
8 -> 'hAZMAT-units';
9 -> 'light-tow-unit';
10 -> 'heavy-tow-unit';
11 -> 'freeway-service-patrols';
12 -> 'transportation-response-units';
13 -> 'private-contractor-response-units';
_ -> exit({error,{asn1,{decode_enumerated,V10@V3}}})
end,
{V10@Int5,V10@Buf4};
<<1:1,V10@Buf2/bitstring>> ->
{V10@V3,V10@Buf4} = case V10@Buf2 of
<<0:1,V10@V6:6,V10@Buf7/bitstring>> ->
{V10@V6,V10@Buf7};
<<1:1,V10@Buf5/bitstring>> ->
{V10@V6,V10@Buf7} = case V10@Buf5 of
<<0:1,V10@V9:7,V10@Buf10/bitstring>> when V10@V9 =/= 0 ->
{V10@V9,V10@Buf10};
<<1:1,0:1,V10@V10:14,V10@Buf11/bitstring>> when V10@V10 =/= 0 ->
{V10@V10,V10@Buf11}
end,
<<V10@V12:V10@V6/unit:8,V10@Buf13/bitstring>> = V10@Buf7,
{V10@V12,V10@Buf13}
end,
V10@Int14 = case V10@V3 of
_ -> {asn1_enum,V10@V3}
end,
{V10@Int14,V10@Buf4}
end,
{V10@V0,V10@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes11}
end,

%% attribute regional(11) with type SEQUENCE OF
{Term11,Bytes13} = case Opt band 1 of
1 ->
dec_EmergencyVehicleAlert_regional(Bytes12);
0 ->
{asn1_NOVALUE,Bytes12}
end,

%% Extensions
{Extensions,Bytes14} = case Ext of
0 -> {<<>>,Bytes13};
1 ->
{V11@V0,V11@Buf1} = case Bytes13 of
<<0:1,V11@V3:6,V11@Buf4/bitstring>> ->
V11@Add5 = V11@V3 + 1,
{V11@Add5,V11@Buf4};
<<1:1,V11@Buf2/bitstring>> ->
{V11@V3,V11@Buf4} = case V11@Buf2 of
<<0:1,V11@V6:7,V11@Buf7/bitstring>> when V11@V6 =/= 0 ->
{V11@V6,V11@Buf7};
<<1:1,0:1,V11@V7:14,V11@Buf8/bitstring>> when V11@V7 =/= 0 ->
{V11@V7,V11@Buf8}
end,
{V11@V3,V11@Buf4}
end,
<<V11@V9:V11@V0/bitstring-unit:1,V11@Buf10/bitstring>> = V11@Buf1,
{V11@V9,V11@Buf10}
end,
Bytes15= skipextensions(Bytes14, 1, Extensions),
Res1 = #{rsaMsg=>Term3},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{timeStamp=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{id=>Term2}
end,
Res4 = case Term4 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{responseType=>Term4}
end,
Res5 = case Term5 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{details=>Term5}
end,
Res6 = case Term6 of
  asn1_NOVALUE -> Res5;
  _ -> Res5#{mass=>Term6}
end,
Res7 = case Term7 of
  asn1_NOVALUE -> Res6;
  _ -> Res6#{basicType=>Term7}
end,
Res8 = case Term8 of
  asn1_NOVALUE -> Res7;
  _ -> Res7#{vehicleType=>Term8}
end,
Res9 = case Term9 of
  asn1_NOVALUE -> Res8;
  _ -> Res8#{responseEquip=>Term9}
end,
Res10 = case Term10 of
  asn1_NOVALUE -> Res9;
  _ -> Res9#{responderType=>Term10}
end,
Res11 = case Term11 of
  asn1_NOVALUE -> Res10;
  _ -> Res10#{regional=>Term11}
end,
{Res11,Bytes15}.


dec_EmergencyVehicleAlert_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components10(V1@Add2, V1@Buf1, []).


dec_EmergencyVehicleAlert_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_IntersectionCollision(Val) ->
#{msgCnt:=Input@1,id:=Input@2,intersectionID:=Input@7,laneNumber:=Input@8,eventFlag:=Input@9} = Val,
Input@3 = case Val of
  #{timeStamp:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{partOne:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{path:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@6 = case Val of
  #{pathPrediction:=Input@6_0} -> Input@6_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@10 = case Val of
  #{regional:=Input@10_0} -> Input@10_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@3 =:= asn1__MISSING_IN_MAP ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@5 =:= asn1__MISSING_IN_MAP ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@10 =:= asn1__MISSING_IN_MAP ->
<<0:1>>;
true ->
<<1:1>>
end,
begin
%% attribute msgCnt(1) with type INTEGER
if Input@1 bsr 7 =:= 0 ->
<<Input@1:7>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute id(2) with type OCTET STRING
enc_Binary_Id(Input@2)
end,
begin
%% attribute timeStamp(3) with type INTEGER
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@3, Input@3 < 527041 ->
<<Input@3:20>>;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end,
begin
%% attribute partOne(4) with type BSMcoreData
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_BSMcoreData(Input@4)
end
end,
begin
%% attribute path(5) with type PathHistory
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_PathHistory(Input@5)
end
end,
begin
%% attribute pathPrediction(6) with type PathPrediction
if Input@6 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_PathPrediction(Input@6)
end
end,
begin
%% attribute intersectionID(7) with type IntersectionReferenceID
enc_IntersectionReferenceID(Input@7)
end,
begin
%% attribute laneNumber(8) with type ApproachOrLane
enc_ApproachOrLane(Input@8)
end,
begin
%% attribute eventFlag(9) with type BIT STRING
Enc9@bs = try bit_string_name2pos_11(Input@9) of
Enc9@positions ->
bitstring_from_positions(Enc9@positions, 13)
catch throw:invalid ->
adjust_trailing_zeroes(Input@9, 13)
end,
Enc9@bits = bit_size(Enc9@bs),
if Enc9@bits =:= 13 ->
[<<0:1>>|Enc9@bs];
Enc9@bits < 128 ->
[<<1:1,Enc9@bits:8>>|Enc9@bs];
Enc9@bits < 16384 ->
[<<1:1,2:2,Enc9@bits:14>>|Enc9@bs];
true ->
[<<1:1>>|encode_fragmented(Enc9@bs, 1)]
end
end|begin
%% attribute regional(10) with type SEQUENCE OF
if Input@10 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_IntersectionCollision_regional(Input@10)
end
end].
enc_IntersectionCollision_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_IntersectionCollision_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_IntersectionCollision_regional_RegionalExtension(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_IntersectionCollision(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:5,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute msgCnt(1) with type INTEGER
{Term1,Bytes3} = begin
<<V3@V0:7,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute id(2) with type OCTET STRING
{Term2,Bytes4} = begin
<<V4@V0:4/binary-unit:8,V4@Buf1/bitstring>> = Bytes3,
V4@Conv2 = binary:copy(V4@V0),
{dec_Binary_Id(V4@Conv2),V4@Buf1}
end,

%% attribute timeStamp(3) with type INTEGER
{Term3,Bytes5} = case (Opt bsr 4) band 1 of
1 ->
begin
<<V5@V0:20,V5@Buf1/bitstring>> = Bytes4,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute partOne(4) with type BSMcoreData
{Term4,Bytes6} = case (Opt bsr 3) band 1 of
1 ->
dec_BSMcoreData(Bytes5);
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute path(5) with type PathHistory
{Term5,Bytes7} = case (Opt bsr 2) band 1 of
1 ->
dec_PathHistory(Bytes6);
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute pathPrediction(6) with type PathPrediction
{Term6,Bytes8} = case (Opt bsr 1) band 1 of
1 ->
dec_PathPrediction(Bytes7);
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute intersectionID(7) with type IntersectionReferenceID
{Term7,Bytes9} = dec_IntersectionReferenceID(Bytes8),

%% attribute laneNumber(8) with type ApproachOrLane
{Term8,Bytes10} = dec_ApproachOrLane(Bytes9),

%% attribute eventFlag(9) with type BIT STRING
{Term9,Bytes11} = begin
{V6@V0,V6@Buf1} = case Bytes10 of
<<0:1,V6@V3:13/binary-unit:1,V6@Buf4/bitstring>> ->
{V6@V3,V6@Buf4};
<<1:1,V6@Buf2/bitstring>> ->
{V6@V3,V6@Buf4} = case V6@Buf2 of
<<0:1,V6@V6:7,V6@V8:V6@V6/binary-unit:1,V6@Buf9/bitstring>> ->
{V6@V8,V6@Buf9};
<<1:1,0:1,V6@V7:14,V6@V9:V6@V7/binary-unit:1,V6@Buf10/bitstring>> ->
{V6@V9,V6@Buf10};
<<1:1,1:1,V6@V7:6,V6@Buf8/bitstring>> ->
{V6@V9,V6@Buf10}  = decode_fragmented(V6@V7, V6@Buf8, 1),
{V6@V9,V6@Buf10}
end,
{V6@V3,V6@Buf4}
end,
{V6@V11,V6@Buf12}  = {decode_named_bit_string(V6@V0, [{eventHazardLights,0},{eventStopLineViolation,1},{eventABSactivated,2},{eventTractionControlLoss,3},{eventStabilityControlactivated,4},{eventHazardousMaterials,5},{eventReserved1,6},{eventHardBraking,7},{eventLightsChanged,8},{eventWipersChanged,9},{eventFlatTire,10},{eventDisabledVehicle,11},{eventAirBagDeployment,12}]),V6@Buf1},
{V6@V11,V6@Buf12}
end,

%% attribute regional(10) with type SEQUENCE OF
{Term10,Bytes12} = case Opt band 1 of
1 ->
dec_IntersectionCollision_regional(Bytes11);
0 ->
{asn1_NOVALUE,Bytes11}
end,

%% Extensions
{Extensions,Bytes13} = case Ext of
0 -> {<<>>,Bytes12};
1 ->
{V7@V0,V7@Buf1} = case Bytes12 of
<<0:1,V7@V3:6,V7@Buf4/bitstring>> ->
V7@Add5 = V7@V3 + 1,
{V7@Add5,V7@Buf4};
<<1:1,V7@Buf2/bitstring>> ->
{V7@V3,V7@Buf4} = case V7@Buf2 of
<<0:1,V7@V6:7,V7@Buf7/bitstring>> when V7@V6 =/= 0 ->
{V7@V6,V7@Buf7};
<<1:1,0:1,V7@V7:14,V7@Buf8/bitstring>> when V7@V7 =/= 0 ->
{V7@V7,V7@Buf8}
end,
{V7@V3,V7@Buf4}
end,
<<V7@V9:V7@V0/bitstring-unit:1,V7@Buf10/bitstring>> = V7@Buf1,
{V7@V9,V7@Buf10}
end,
Bytes14= skipextensions(Bytes13, 1, Extensions),
Res1 = #{msgCnt=>Term1,id=>Term2,intersectionID=>Term7,laneNumber=>Term8,eventFlag=>Term9},
Res2 = case Term3 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{timeStamp=>Term3}
end,
Res3 = case Term4 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{partOne=>Term4}
end,
Res4 = case Term5 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{path=>Term5}
end,
Res5 = case Term6 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{pathPrediction=>Term6}
end,
Res6 = case Term10 of
  asn1_NOVALUE -> Res5;
  _ -> Res5#{regional=>Term10}
end,
{Res6,Bytes14}.


dec_IntersectionCollision_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components12(V1@Add2, V1@Buf1, []).


dec_IntersectionCollision_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_MapData(Val) ->
#{msgIssueRevision:=Input@2} = Val,
Input@1 = case Val of
  #{timeStamp:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{layerType:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{layerID:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{intersections:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@6 = case Val of
  #{roadSegments:=Input@6_0} -> Input@6_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@7 = case Val of
  #{dataParameters:=Input@7_0} -> Input@7_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@8 = case Val of
  #{restrictionList:=Input@8_0} -> Input@8_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@9 = case Val of
  #{regional:=Input@9_0} -> Input@9_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@4 =:= asn1__MISSING_IN_MAP ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@6 =:= asn1__MISSING_IN_MAP ->
if Input@7 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@7 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@8 =:= asn1__MISSING_IN_MAP ->
if Input@9 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@9 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
begin
%% attribute timeStamp(1) with type INTEGER
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@1, Input@1 < 527041 ->
<<Input@1:20>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute msgIssueRevision(2) with type INTEGER
if Input@2 bsr 7 =:= 0 ->
<<Input@2:7>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end,
begin
%% attribute layerType(3) with type ENUMERATED
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
Input@3 =:= none ->
<<0:1,0:3>>;
Input@3 =:= mixedContent ->
<<0:1,1:3>>;
Input@3 =:= generalMapData ->
<<0:1,2:3>>;
Input@3 =:= intersectionData ->
<<0:1,3:3>>;
Input@3 =:= curveData ->
<<0:1,4:3>>;
Input@3 =:= roadwaySectionData ->
<<0:1,5:3>>;
Input@3 =:= parkingAreaData ->
<<0:1,6:3>>;
Input@3 =:= sharedLaneData ->
<<0:1,7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@3}}})
end
end,
begin
%% attribute layerID(4) with type INTEGER
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@4, Input@4 < 101 ->
<<Input@4:7>>;
true ->
exit({error,{asn1,{illegal_integer,Input@4}}})
end
end,
begin
%% attribute intersections(5) with type IntersectionGeometryList
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_IntersectionGeometryList(Input@5)
end
end,
begin
%% attribute roadSegments(6) with type RoadSegmentList
if Input@6 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_RoadSegmentList(Input@6)
end
end,
begin
%% attribute dataParameters(7) with type DataParameters
if Input@7 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_DataParameters(Input@7)
end
end,
begin
%% attribute restrictionList(8) with type RestrictionClassList
if Input@8 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_RestrictionClassList(Input@8)
end
end|begin
%% attribute regional(9) with type SEQUENCE OF
if Input@9 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_MapData_regional(Input@9)
end
end].
enc_MapData_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_MapData_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_MapData_regional_RegionalExtension(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type13(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_MapData(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute timeStamp(1) with type INTEGER
{Term1,Bytes3} = case (Opt bsr 7) band 1 of
1 ->
begin
<<V3@V0:20,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute msgIssueRevision(2) with type INTEGER
{Term2,Bytes4} = begin
<<V4@V0:7,V4@Buf1/bitstring>> = Bytes3,
{V4@V0,V4@Buf1}
end,

%% attribute layerType(3) with type ENUMERATED
{Term3,Bytes5} = case (Opt bsr 6) band 1 of
1 ->
begin
{V5@V0,V5@Buf1} = case Bytes4 of
<<0:1,V5@V3:3,V5@Buf4/bitstring>> ->
V5@Int5 = case V5@V3 of
0 -> none;
1 -> mixedContent;
2 -> generalMapData;
3 -> intersectionData;
4 -> curveData;
5 -> roadwaySectionData;
6 -> parkingAreaData;
7 -> sharedLaneData
end,
{V5@Int5,V5@Buf4};
<<1:1,V5@Buf2/bitstring>> ->
{V5@V3,V5@Buf4} = case V5@Buf2 of
<<0:1,V5@V6:6,V5@Buf7/bitstring>> ->
{V5@V6,V5@Buf7};
<<1:1,V5@Buf5/bitstring>> ->
{V5@V6,V5@Buf7} = case V5@Buf5 of
<<0:1,V5@V9:7,V5@Buf10/bitstring>> when V5@V9 =/= 0 ->
{V5@V9,V5@Buf10};
<<1:1,0:1,V5@V10:14,V5@Buf11/bitstring>> when V5@V10 =/= 0 ->
{V5@V10,V5@Buf11}
end,
<<V5@V12:V5@V6/unit:8,V5@Buf13/bitstring>> = V5@Buf7,
{V5@V12,V5@Buf13}
end,
V5@Int14 = case V5@V3 of
_ -> {asn1_enum,V5@V3}
end,
{V5@Int14,V5@Buf4}
end,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute layerID(4) with type INTEGER
{Term4,Bytes6} = case (Opt bsr 5) band 1 of
1 ->
begin
<<V6@V0:7,V6@Buf1/bitstring>> = Bytes5,
{V6@V0,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute intersections(5) with type IntersectionGeometryList
{Term5,Bytes7} = case (Opt bsr 4) band 1 of
1 ->
dec_IntersectionGeometryList(Bytes6);
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute roadSegments(6) with type RoadSegmentList
{Term6,Bytes8} = case (Opt bsr 3) band 1 of
1 ->
dec_RoadSegmentList(Bytes7);
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute dataParameters(7) with type DataParameters
{Term7,Bytes9} = case (Opt bsr 2) band 1 of
1 ->
dec_DataParameters(Bytes8);
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% attribute restrictionList(8) with type RestrictionClassList
{Term8,Bytes10} = case (Opt bsr 1) band 1 of
1 ->
dec_RestrictionClassList(Bytes9);
0 ->
{asn1_NOVALUE,Bytes9}
end,

%% attribute regional(9) with type SEQUENCE OF
{Term9,Bytes11} = case Opt band 1 of
1 ->
dec_MapData_regional(Bytes10);
0 ->
{asn1_NOVALUE,Bytes10}
end,

%% Extensions
{Extensions,Bytes12} = case Ext of
0 -> {<<>>,Bytes11};
1 ->
{V7@V0,V7@Buf1} = case Bytes11 of
<<0:1,V7@V3:6,V7@Buf4/bitstring>> ->
V7@Add5 = V7@V3 + 1,
{V7@Add5,V7@Buf4};
<<1:1,V7@Buf2/bitstring>> ->
{V7@V3,V7@Buf4} = case V7@Buf2 of
<<0:1,V7@V6:7,V7@Buf7/bitstring>> when V7@V6 =/= 0 ->
{V7@V6,V7@Buf7};
<<1:1,0:1,V7@V7:14,V7@Buf8/bitstring>> when V7@V7 =/= 0 ->
{V7@V7,V7@Buf8}
end,
{V7@V3,V7@Buf4}
end,
<<V7@V9:V7@V0/bitstring-unit:1,V7@Buf10/bitstring>> = V7@Buf1,
{V7@V9,V7@Buf10}
end,
Bytes13= skipextensions(Bytes12, 1, Extensions),
Res1 = #{msgIssueRevision=>Term2},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{timeStamp=>Term1}
end,
Res3 = case Term3 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{layerType=>Term3}
end,
Res4 = case Term4 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{layerID=>Term4}
end,
Res5 = case Term5 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{intersections=>Term5}
end,
Res6 = case Term6 of
  asn1_NOVALUE -> Res5;
  _ -> Res5#{roadSegments=>Term6}
end,
Res7 = case Term7 of
  asn1_NOVALUE -> Res6;
  _ -> Res6#{dataParameters=>Term7}
end,
Res8 = case Term8 of
  asn1_NOVALUE -> Res7;
  _ -> Res7#{restrictionList=>Term8}
end,
Res9 = case Term9 of
  asn1_NOVALUE -> Res8;
  _ -> Res8#{regional=>Term9}
end,
{Res9,Bytes13}.


dec_MapData_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components14(V1@Add2, V1@Buf1, []).


dec_MapData_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type15(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_NMEAcorrections(Val) ->
#{payload:=Input@5} = Val,
Input@1 = case Val of
  #{timeStamp:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{rev:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{msg:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{wdCount:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@6 = case Val of
  #{regional:=Input@6_0} -> Input@6_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@3 =:= asn1__MISSING_IN_MAP ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<0:1>>;
true ->
<<1:1>>
end,
begin
%% attribute timeStamp(1) with type INTEGER
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@1, Input@1 < 527041 ->
<<Input@1:20>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute rev(2) with type ENUMERATED
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
Input@2 =:= unknown ->
<<0:1,0:3>>;
Input@2 =:= reserved ->
<<0:1,1:3>>;
Input@2 =:= rev1 ->
<<0:1,2:3>>;
Input@2 =:= rev2 ->
<<0:1,3:3>>;
Input@2 =:= rev3 ->
<<0:1,4:3>>;
Input@2 =:= rev4 ->
<<0:1,5:3>>;
Input@2 =:= rev5 ->
<<0:1,6:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@2}}})
end
end,
begin
%% attribute msg(3) with type INTEGER
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
Input@3 bsr 15 =:= 0 ->
<<Input@3:15>>;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end,
begin
%% attribute wdCount(4) with type INTEGER
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
Input@4 bsr 10 =:= 0 ->
<<Input@4:10>>;
true ->
exit({error,{asn1,{illegal_integer,Input@4}}})
end
end,
begin
%% attribute payload(5) with type OCTET STRING
Enc10@len = byte_size(Input@5),
Enc10@len@sub = Enc10@len - 1,
if 0 =< Enc10@len@sub, Enc10@len@sub < 1023 ->
[<<Enc10@len@sub:10>>|Input@5]
end
end|begin
%% attribute regional(6) with type SEQUENCE OF
if Input@6 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_NMEAcorrections_regional(Input@6)
end
end].
enc_NMEAcorrections_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_NMEAcorrections_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_NMEAcorrections_regional_RegionalExtension(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_NMEAcorrections(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:5,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute timeStamp(1) with type INTEGER
{Term1,Bytes3} = case (Opt bsr 4) band 1 of
1 ->
begin
<<V3@V0:20,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute rev(2) with type ENUMERATED
{Term2,Bytes4} = case (Opt bsr 3) band 1 of
1 ->
begin
{V4@V0,V4@Buf1} = case Bytes3 of
<<0:1,V4@V3:3,V4@Buf4/bitstring>> ->
V4@Int5 = case V4@V3 of
0 -> unknown;
1 -> reserved;
2 -> rev1;
3 -> rev2;
4 -> rev3;
5 -> rev4;
6 -> rev5;
_ -> exit({error,{asn1,{decode_enumerated,V4@V3}}})
end,
{V4@Int5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:6,V4@Buf7/bitstring>> ->
{V4@V6,V4@Buf7};
<<1:1,V4@Buf5/bitstring>> ->
{V4@V6,V4@Buf7} = case V4@Buf5 of
<<0:1,V4@V9:7,V4@Buf10/bitstring>> when V4@V9 =/= 0 ->
{V4@V9,V4@Buf10};
<<1:1,0:1,V4@V10:14,V4@Buf11/bitstring>> when V4@V10 =/= 0 ->
{V4@V10,V4@Buf11}
end,
<<V4@V12:V4@V6/unit:8,V4@Buf13/bitstring>> = V4@Buf7,
{V4@V12,V4@Buf13}
end,
V4@Int14 = case V4@V3 of
_ -> {asn1_enum,V4@V3}
end,
{V4@Int14,V4@Buf4}
end,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute msg(3) with type INTEGER
{Term3,Bytes5} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V5@V0:15,V5@Buf1/bitstring>> = Bytes4,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute wdCount(4) with type INTEGER
{Term4,Bytes6} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V6@V0:10,V6@Buf1/bitstring>> = Bytes5,
{V6@V0,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute payload(5) with type OCTET STRING
{Term5,Bytes7} = begin
<<V7@V0:10,V7@Buf1/bitstring>> = Bytes6,
V7@Add2 = V7@V0 + 1,
<<V7@V3:V7@Add2/binary-unit:8,V7@Buf4/bitstring>> = V7@Buf1,
V7@Conv5 = binary:copy(V7@V3),
{V7@Conv5,V7@Buf4}
end,

%% attribute regional(6) with type SEQUENCE OF
{Term6,Bytes8} = case Opt band 1 of
1 ->
dec_NMEAcorrections_regional(Bytes7);
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% Extensions
{Extensions,Bytes9} = case Ext of
0 -> {<<>>,Bytes8};
1 ->
{V8@V0,V8@Buf1} = case Bytes8 of
<<0:1,V8@V3:6,V8@Buf4/bitstring>> ->
V8@Add5 = V8@V3 + 1,
{V8@Add5,V8@Buf4};
<<1:1,V8@Buf2/bitstring>> ->
{V8@V3,V8@Buf4} = case V8@Buf2 of
<<0:1,V8@V6:7,V8@Buf7/bitstring>> when V8@V6 =/= 0 ->
{V8@V6,V8@Buf7};
<<1:1,0:1,V8@V7:14,V8@Buf8/bitstring>> when V8@V7 =/= 0 ->
{V8@V7,V8@Buf8}
end,
{V8@V3,V8@Buf4}
end,
<<V8@V9:V8@V0/bitstring-unit:1,V8@Buf10/bitstring>> = V8@Buf1,
{V8@V9,V8@Buf10}
end,
Bytes10= skipextensions(Bytes9, 1, Extensions),
Res1 = #{payload=>Term5},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{timeStamp=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{rev=>Term2}
end,
Res4 = case Term3 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{msg=>Term3}
end,
Res5 = case Term4 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{wdCount=>Term4}
end,
Res6 = case Term6 of
  asn1_NOVALUE -> Res5;
  _ -> Res5#{regional=>Term6}
end,
{Res6,Bytes10}.


dec_NMEAcorrections_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components16(V1@Add2, V1@Buf1, []).


dec_NMEAcorrections_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_PersonalSafetyMessage(Val) ->
#{basicType:=Input@1,secMark:=Input@2,msgCnt:=Input@3,id:=Input@4,position:=Input@5,accuracy:=Input@6,speed:=Input@7,heading:=Input@8} = Val,
Input@9 = case Val of
  #{accelSet:=Input@9_0} -> Input@9_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@10 = case Val of
  #{pathHistory:=Input@10_0} -> Input@10_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@11 = case Val of
  #{pathPrediction:=Input@11_0} -> Input@11_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@12 = case Val of
  #{propulsion:=Input@12_0} -> Input@12_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@13 = case Val of
  #{useState:=Input@13_0} -> Input@13_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@14 = case Val of
  #{crossRequest:=Input@14_0} -> Input@14_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@15 = case Val of
  #{crossState:=Input@15_0} -> Input@15_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@16 = case Val of
  #{clusterSize:=Input@16_0} -> Input@16_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@17 = case Val of
  #{clusterRadius:=Input@17_0} -> Input@17_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@18 = case Val of
  #{eventResponderType:=Input@18_0} -> Input@18_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@19 = case Val of
  #{activityType:=Input@19_0} -> Input@19_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@20 = case Val of
  #{activitySubType:=Input@20_0} -> Input@20_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@21 = case Val of
  #{assistType:=Input@21_0} -> Input@21_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@22 = case Val of
  #{sizing:=Input@22_0} -> Input@22_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@23 = case Val of
  #{attachment:=Input@23_0} -> Input@23_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@24 = case Val of
  #{attachmentRadius:=Input@24_0} -> Input@24_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@25 = case Val of
  #{animalType:=Input@25_0} -> Input@25_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@26 = case Val of
  #{regional:=Input@26_0} -> Input@26_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@9 =:= asn1__MISSING_IN_MAP ->
if Input@10 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@10 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@11 =:= asn1__MISSING_IN_MAP ->
if Input@12 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@12 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@13 =:= asn1__MISSING_IN_MAP ->
if Input@14 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@14 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@15 =:= asn1__MISSING_IN_MAP ->
if Input@16 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@16 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@17 =:= asn1__MISSING_IN_MAP ->
if Input@18 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@18 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@19 =:= asn1__MISSING_IN_MAP ->
if Input@20 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@20 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@21 =:= asn1__MISSING_IN_MAP ->
if Input@22 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@22 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@23 =:= asn1__MISSING_IN_MAP ->
if Input@24 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@24 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@25 =:= asn1__MISSING_IN_MAP ->
if Input@26 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@26 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
begin
%% attribute basicType(1) with type ENUMERATED
if Input@1 =:= unavailable ->
<<0:1,0:3>>;
Input@1 =:= aPEDESTRIAN ->
<<0:1,1:3>>;
Input@1 =:= aPEDALCYCLIST ->
<<0:1,2:3>>;
Input@1 =:= aPUBLICSAFETYWORKER ->
<<0:1,3:3>>;
Input@1 =:= anANIMAL ->
<<0:1,4:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@1}}})
end
end,
begin
%% attribute secMark(2) with type INTEGER
if Input@2 bsr 16 =:= 0 ->
<<Input@2:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end,
begin
%% attribute msgCnt(3) with type INTEGER
if Input@3 bsr 7 =:= 0 ->
<<Input@3:7>>;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end,
begin
%% attribute id(4) with type OCTET STRING
enc_Binary_Id(Input@2)
end,
begin
%% attribute position(5) with type Position3D
enc_Position3D(Input@5)
end,
begin
%% attribute accuracy(6) with type PositionalAccuracy
enc_PositionalAccuracy(Input@6)
end,
begin
%% attribute speed(7) with type INTEGER
if Input@7 bsr 13 =:= 0 ->
<<Input@7:13>>;
true ->
exit({error,{asn1,{illegal_integer,Input@7}}})
end
end,
begin
%% attribute heading(8) with type INTEGER
if 0 =< Input@8, Input@8 < 28801 ->
<<Input@8:15>>;
true ->
exit({error,{asn1,{illegal_integer,Input@8}}})
end
end,
begin
%% attribute accelSet(9) with type AccelerationSet4Way
if Input@9 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_AccelerationSet4Way(Input@9)
end
end,
begin
%% attribute pathHistory(10) with type PathHistory
if Input@10 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_PathHistory(Input@10)
end
end,
begin
%% attribute pathPrediction(11) with type PathPrediction
if Input@11 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_PathPrediction(Input@11)
end
end,
begin
%% attribute propulsion(12) with type PropelledInformation
if Input@12 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_PropelledInformation(Input@12)
end
end,
begin
%% attribute useState(13) with type BIT STRING
if Input@13 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Enc12@bs = try bit_string_name2pos_17(Input@13) of
Enc12@positions ->
bitstring_from_positions(Enc12@positions, 9)
catch throw:invalid ->
adjust_trailing_zeroes(Input@13, 9)
end,
Enc12@bits = bit_size(Enc12@bs),
if Enc12@bits =:= 9 ->
[<<0:1>>|Enc12@bs];
Enc12@bits < 128 ->
[<<1:1,Enc12@bits:8>>|Enc12@bs];
Enc12@bits < 16384 ->
[<<1:1,2:2,Enc12@bits:14>>|Enc12@bs];
true ->
[<<1:1>>|encode_fragmented(Enc12@bs, 1)]
end
end
end
end,
begin
%% attribute crossRequest(14) with type BOOLEAN
if Input@14 =:= asn1__MISSING_IN_MAP ->
[];
Input@14 =:= false ->
<<0:1>>;
Input@14 =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Input@14}}})
end
end,
begin
%% attribute crossState(15) with type BOOLEAN
if Input@15 =:= asn1__MISSING_IN_MAP ->
[];
Input@15 =:= false ->
<<0:1>>;
Input@15 =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Input@15}}})
end
end,
begin
%% attribute clusterSize(16) with type ENUMERATED
if Input@16 =:= asn1__MISSING_IN_MAP ->
[];
Input@16 =:= unavailable ->
<<0:1,0:2>>;
Input@16 =:= small ->
<<0:1,1:2>>;
Input@16 =:= medium ->
<<0:1,2:2>>;
Input@16 =:= large ->
<<0:1,3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@16}}})
end
end,
begin
%% attribute clusterRadius(17) with type INTEGER
if Input@17 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@17, Input@17 < 101 ->
<<Input@17:7>>;
true ->
exit({error,{asn1,{illegal_integer,Input@17}}})
end
end,
begin
%% attribute eventResponderType(18) with type ENUMERATED
if Input@18 =:= asn1__MISSING_IN_MAP ->
[];
Input@18 =:= unavailable ->
<<0:1,0:3>>;
Input@18 =:= towOperater ->
<<0:1,1:3>>;
Input@18 =:= fireAndEMSWorker ->
<<0:1,2:3>>;
Input@18 =:= aDOTWorker ->
<<0:1,3:3>>;
Input@18 =:= lawEnforcement ->
<<0:1,4:3>>;
Input@18 =:= hazmatResponder ->
<<0:1,5:3>>;
Input@18 =:= animalControlWorker ->
<<0:1,6:3>>;
Input@18 =:= otherPersonnel ->
<<0:1,7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@18}}})
end
end,
begin
%% attribute activityType(19) with type BIT STRING
if Input@19 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Enc24@bs = try bit_string_name2pos_18(Input@19) of
Enc24@positions ->
bitstring_from_positions(Enc24@positions, 6)
catch throw:invalid ->
adjust_trailing_zeroes(Input@19, 6)
end,
Enc24@bits = bit_size(Enc24@bs),
if Enc24@bits =:= 6 ->
[<<0:1>>|Enc24@bs];
Enc24@bits < 128 ->
[<<1:1,Enc24@bits:8>>|Enc24@bs];
Enc24@bits < 16384 ->
[<<1:1,2:2,Enc24@bits:14>>|Enc24@bs];
true ->
[<<1:1>>|encode_fragmented(Enc24@bs, 1)]
end
end
end
end,
begin
%% attribute activitySubType(20) with type BIT STRING
if Input@20 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Enc26@bs = try bit_string_name2pos_19(Input@20) of
Enc26@positions ->
bitstring_from_positions(Enc26@positions, 7)
catch throw:invalid ->
adjust_trailing_zeroes(Input@20, 7)
end,
Enc26@bits = bit_size(Enc26@bs),
if Enc26@bits =:= 7 ->
[<<0:1>>|Enc26@bs];
Enc26@bits < 128 ->
[<<1:1,Enc26@bits:8>>|Enc26@bs];
Enc26@bits < 16384 ->
[<<1:1,2:2,Enc26@bits:14>>|Enc26@bs];
true ->
[<<1:1>>|encode_fragmented(Enc26@bs, 1)]
end
end
end
end,
begin
%% attribute assistType(21) with type BIT STRING
if Input@21 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Enc28@bs = try bit_string_name2pos_20(Input@21) of
Enc28@positions ->
bitstring_from_positions(Enc28@positions, 6)
catch throw:invalid ->
adjust_trailing_zeroes(Input@21, 6)
end,
Enc28@bits = bit_size(Enc28@bs),
if Enc28@bits =:= 6 ->
[<<0:1>>|Enc28@bs];
Enc28@bits < 128 ->
[<<1:1,Enc28@bits:8>>|Enc28@bs];
Enc28@bits < 16384 ->
[<<1:1,2:2,Enc28@bits:14>>|Enc28@bs];
true ->
[<<1:1>>|encode_fragmented(Enc28@bs, 1)]
end
end
end
end,
begin
%% attribute sizing(22) with type BIT STRING
if Input@22 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Enc30@bs = try bit_string_name2pos_21(Input@22) of
Enc30@positions ->
bitstring_from_positions(Enc30@positions, 5)
catch throw:invalid ->
adjust_trailing_zeroes(Input@22, 5)
end,
Enc30@bits = bit_size(Enc30@bs),
if Enc30@bits =:= 5 ->
[<<0:1>>|Enc30@bs];
Enc30@bits < 128 ->
[<<1:1,Enc30@bits:8>>|Enc30@bs];
Enc30@bits < 16384 ->
[<<1:1,2:2,Enc30@bits:14>>|Enc30@bs];
true ->
[<<1:1>>|encode_fragmented(Enc30@bs, 1)]
end
end
end
end,
begin
%% attribute attachment(23) with type ENUMERATED
if Input@23 =:= asn1__MISSING_IN_MAP ->
[];
Input@23 =:= unavailable ->
<<0:1,0:3>>;
Input@23 =:= stroller ->
<<0:1,1:3>>;
Input@23 =:= bicycleTrailer ->
<<0:1,2:3>>;
Input@23 =:= cart ->
<<0:1,3:3>>;
Input@23 =:= wheelchair ->
<<0:1,4:3>>;
Input@23 =:= otherWalkAssistAttachments ->
<<0:1,5:3>>;
Input@23 =:= pet ->
<<0:1,6:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@23}}})
end
end,
begin
%% attribute attachmentRadius(24) with type INTEGER
if Input@24 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@24, Input@24 < 201 ->
Input@24;
true ->
exit({error,{asn1,{illegal_integer,Input@24}}})
end
end,
begin
%% attribute animalType(25) with type ENUMERATED
if Input@25 =:= asn1__MISSING_IN_MAP ->
[];
Input@25 =:= unavailable ->
<<0:1,0:2>>;
Input@25 =:= serviceUse ->
<<0:1,1:2>>;
Input@25 =:= pet ->
<<0:1,2:2>>;
Input@25 =:= farm ->
<<0:1,3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@25}}})
end
end|begin
%% attribute regional(26) with type SEQUENCE OF
if Input@26 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_PersonalSafetyMessage_regional(Input@26)
end
end].
enc_PersonalSafetyMessage_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_PersonalSafetyMessage_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_PersonalSafetyMessage_regional_RegionalExtension(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_PersonalSafetyMessage(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:18,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute basicType(1) with type ENUMERATED
{Term1,Bytes3} = begin
{V3@V0,V3@Buf1} = case Bytes2 of
<<0:1,V3@V3:3,V3@Buf4/bitstring>> ->
V3@Int5 = case V3@V3 of
0 -> unavailable;
1 -> aPEDESTRIAN;
2 -> aPEDALCYCLIST;
3 -> aPUBLICSAFETYWORKER;
4 -> anANIMAL;
_ -> exit({error,{asn1,{decode_enumerated,V3@V3}}})
end,
{V3@Int5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:6,V3@Buf7/bitstring>> ->
{V3@V6,V3@Buf7};
<<1:1,V3@Buf5/bitstring>> ->
{V3@V6,V3@Buf7} = case V3@Buf5 of
<<0:1,V3@V9:7,V3@Buf10/bitstring>> when V3@V9 =/= 0 ->
{V3@V9,V3@Buf10};
<<1:1,0:1,V3@V10:14,V3@Buf11/bitstring>> when V3@V10 =/= 0 ->
{V3@V10,V3@Buf11}
end,
<<V3@V12:V3@V6/unit:8,V3@Buf13/bitstring>> = V3@Buf7,
{V3@V12,V3@Buf13}
end,
V3@Int14 = case V3@V3 of
_ -> {asn1_enum,V3@V3}
end,
{V3@Int14,V3@Buf4}
end,
{V3@V0,V3@Buf1}
end,

%% attribute secMark(2) with type INTEGER
{Term2,Bytes4} = begin
<<V4@V0:16,V4@Buf1/bitstring>> = Bytes3,
{V4@V0,V4@Buf1}
end,

%% attribute msgCnt(3) with type INTEGER
{Term3,Bytes5} = begin
<<V5@V0:7,V5@Buf1/bitstring>> = Bytes4,
{V5@V0,V5@Buf1}
end,

%% attribute id(4) with type OCTET STRING
{Term4,Bytes6} = begin
<<V6@V0:4/binary-unit:8,V6@Buf1/bitstring>> = Bytes5,
V6@Conv2 = binary:copy(V6@V0),
{dec_Binary_Id(V6@Conv2),V6@Buf1}
end,

%% attribute position(5) with type Position3D
{Term5,Bytes7} = dec_Position3D(Bytes6),

%% attribute accuracy(6) with type PositionalAccuracy
{Term6,Bytes8} = dec_PositionalAccuracy(Bytes7),

%% attribute speed(7) with type INTEGER
{Term7,Bytes9} = begin
<<V7@V0:13,V7@Buf1/bitstring>> = Bytes8,
{V7@V0,V7@Buf1}
end,

%% attribute heading(8) with type INTEGER
{Term8,Bytes10} = begin
<<V8@V0:15,V8@Buf1/bitstring>> = Bytes9,
{V8@V0,V8@Buf1}
end,

%% attribute accelSet(9) with type AccelerationSet4Way
{Term9,Bytes11} = case (Opt bsr 17) band 1 of
1 ->
dec_AccelerationSet4Way(Bytes10);
0 ->
{asn1_NOVALUE,Bytes10}
end,

%% attribute pathHistory(10) with type PathHistory
{Term10,Bytes12} = case (Opt bsr 16) band 1 of
1 ->
dec_PathHistory(Bytes11);
0 ->
{asn1_NOVALUE,Bytes11}
end,

%% attribute pathPrediction(11) with type PathPrediction
{Term11,Bytes13} = case (Opt bsr 15) band 1 of
1 ->
dec_PathPrediction(Bytes12);
0 ->
{asn1_NOVALUE,Bytes12}
end,

%% attribute propulsion(12) with type PropelledInformation
{Term12,Bytes14} = case (Opt bsr 14) band 1 of
1 ->
dec_PropelledInformation(Bytes13);
0 ->
{asn1_NOVALUE,Bytes13}
end,

%% attribute useState(13) with type BIT STRING
{Term13,Bytes15} = case (Opt bsr 13) band 1 of
1 ->
begin
{V9@V0,V9@Buf1} = case Bytes14 of
<<0:1,V9@V3:9/binary-unit:1,V9@Buf4/bitstring>> ->
{V9@V3,V9@Buf4};
<<1:1,V9@Buf2/bitstring>> ->
{V9@V3,V9@Buf4} = case V9@Buf2 of
<<0:1,V9@V6:7,V9@V8:V9@V6/binary-unit:1,V9@Buf9/bitstring>> ->
{V9@V8,V9@Buf9};
<<1:1,0:1,V9@V7:14,V9@V9:V9@V7/binary-unit:1,V9@Buf10/bitstring>> ->
{V9@V9,V9@Buf10};
<<1:1,1:1,V9@V7:6,V9@Buf8/bitstring>> ->
{V9@V9,V9@Buf10}  = decode_fragmented(V9@V7, V9@Buf8, 1),
{V9@V9,V9@Buf10}
end,
{V9@V3,V9@Buf4}
end,
{V9@V11,V9@Buf12}  = {decode_named_bit_string(V9@V0, [{unavailable,0},{other,1},{idle,2},{listeningToAudio,3},{typing,4},{calling,5},{playingGames,6},{reading,7},{viewing,8}]),V9@Buf1},
{V9@V11,V9@Buf12}
end;
0 ->
{asn1_NOVALUE,Bytes14}
end,

%% attribute crossRequest(14) with type BOOLEAN
{Term14,Bytes16} = case (Opt bsr 12) band 1 of
1 ->
begin
<<V10@V0:1,V10@Buf1/bitstring>> = Bytes15,
V10@Int2 = case V10@V0 of
0 -> false;
1 -> true
end,
{V10@Int2,V10@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes15}
end,

%% attribute crossState(15) with type BOOLEAN
{Term15,Bytes17} = case (Opt bsr 11) band 1 of
1 ->
begin
<<V11@V0:1,V11@Buf1/bitstring>> = Bytes16,
V11@Int2 = case V11@V0 of
0 -> false;
1 -> true
end,
{V11@Int2,V11@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes16}
end,

%% attribute clusterSize(16) with type ENUMERATED
{Term16,Bytes18} = case (Opt bsr 10) band 1 of
1 ->
begin
{V12@V0,V12@Buf1} = case Bytes17 of
<<0:1,V12@V3:2,V12@Buf4/bitstring>> ->
V12@Int5 = case V12@V3 of
0 -> unavailable;
1 -> small;
2 -> medium;
3 -> large
end,
{V12@Int5,V12@Buf4};
<<1:1,V12@Buf2/bitstring>> ->
{V12@V3,V12@Buf4} = case V12@Buf2 of
<<0:1,V12@V6:6,V12@Buf7/bitstring>> ->
{V12@V6,V12@Buf7};
<<1:1,V12@Buf5/bitstring>> ->
{V12@V6,V12@Buf7} = case V12@Buf5 of
<<0:1,V12@V9:7,V12@Buf10/bitstring>> when V12@V9 =/= 0 ->
{V12@V9,V12@Buf10};
<<1:1,0:1,V12@V10:14,V12@Buf11/bitstring>> when V12@V10 =/= 0 ->
{V12@V10,V12@Buf11}
end,
<<V12@V12:V12@V6/unit:8,V12@Buf13/bitstring>> = V12@Buf7,
{V12@V12,V12@Buf13}
end,
V12@Int14 = case V12@V3 of
_ -> {asn1_enum,V12@V3}
end,
{V12@Int14,V12@Buf4}
end,
{V12@V0,V12@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes17}
end,

%% attribute clusterRadius(17) with type INTEGER
{Term17,Bytes19} = case (Opt bsr 9) band 1 of
1 ->
begin
<<V13@V0:7,V13@Buf1/bitstring>> = Bytes18,
{V13@V0,V13@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes18}
end,

%% attribute eventResponderType(18) with type ENUMERATED
{Term18,Bytes20} = case (Opt bsr 8) band 1 of
1 ->
begin
{V14@V0,V14@Buf1} = case Bytes19 of
<<0:1,V14@V3:3,V14@Buf4/bitstring>> ->
V14@Int5 = case V14@V3 of
0 -> unavailable;
1 -> towOperater;
2 -> fireAndEMSWorker;
3 -> aDOTWorker;
4 -> lawEnforcement;
5 -> hazmatResponder;
6 -> animalControlWorker;
7 -> otherPersonnel
end,
{V14@Int5,V14@Buf4};
<<1:1,V14@Buf2/bitstring>> ->
{V14@V3,V14@Buf4} = case V14@Buf2 of
<<0:1,V14@V6:6,V14@Buf7/bitstring>> ->
{V14@V6,V14@Buf7};
<<1:1,V14@Buf5/bitstring>> ->
{V14@V6,V14@Buf7} = case V14@Buf5 of
<<0:1,V14@V9:7,V14@Buf10/bitstring>> when V14@V9 =/= 0 ->
{V14@V9,V14@Buf10};
<<1:1,0:1,V14@V10:14,V14@Buf11/bitstring>> when V14@V10 =/= 0 ->
{V14@V10,V14@Buf11}
end,
<<V14@V12:V14@V6/unit:8,V14@Buf13/bitstring>> = V14@Buf7,
{V14@V12,V14@Buf13}
end,
V14@Int14 = case V14@V3 of
_ -> {asn1_enum,V14@V3}
end,
{V14@Int14,V14@Buf4}
end,
{V14@V0,V14@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes19}
end,

%% attribute activityType(19) with type BIT STRING
{Term19,Bytes21} = case (Opt bsr 7) band 1 of
1 ->
begin
{V15@V0,V15@Buf1} = case Bytes20 of
<<0:1,V15@V3:6/binary-unit:1,V15@Buf4/bitstring>> ->
{V15@V3,V15@Buf4};
<<1:1,V15@Buf2/bitstring>> ->
{V15@V3,V15@Buf4} = case V15@Buf2 of
<<0:1,V15@V6:7,V15@V8:V15@V6/binary-unit:1,V15@Buf9/bitstring>> ->
{V15@V8,V15@Buf9};
<<1:1,0:1,V15@V7:14,V15@V9:V15@V7/binary-unit:1,V15@Buf10/bitstring>> ->
{V15@V9,V15@Buf10};
<<1:1,1:1,V15@V7:6,V15@Buf8/bitstring>> ->
{V15@V9,V15@Buf10}  = decode_fragmented(V15@V7, V15@Buf8, 1),
{V15@V9,V15@Buf10}
end,
{V15@V3,V15@Buf4}
end,
{V15@V11,V15@Buf12}  = {decode_named_bit_string(V15@V0, [{unavailable,0},{workingOnRoad,1},{settingUpClosures,2},{respondingToEvents,3},{directingTraffic,4},{otherActivities,5}]),V15@Buf1},
{V15@V11,V15@Buf12}
end;
0 ->
{asn1_NOVALUE,Bytes20}
end,

%% attribute activitySubType(20) with type BIT STRING
{Term20,Bytes22} = case (Opt bsr 6) band 1 of
1 ->
begin
{V16@V0,V16@Buf1} = case Bytes21 of
<<0:1,V16@V3:7/binary-unit:1,V16@Buf4/bitstring>> ->
{V16@V3,V16@Buf4};
<<1:1,V16@Buf2/bitstring>> ->
{V16@V3,V16@Buf4} = case V16@Buf2 of
<<0:1,V16@V6:7,V16@V8:V16@V6/binary-unit:1,V16@Buf9/bitstring>> ->
{V16@V8,V16@Buf9};
<<1:1,0:1,V16@V7:14,V16@V9:V16@V7/binary-unit:1,V16@Buf10/bitstring>> ->
{V16@V9,V16@Buf10};
<<1:1,1:1,V16@V7:6,V16@Buf8/bitstring>> ->
{V16@V9,V16@Buf10}  = decode_fragmented(V16@V7, V16@Buf8, 1),
{V16@V9,V16@Buf10}
end,
{V16@V3,V16@Buf4}
end,
{V16@V11,V16@Buf12}  = {decode_named_bit_string(V16@V0, [{unavailable,0},{policeAndTrafficOfficers,1},{trafficControlPersons,2},{railroadCrossingGuards,3},{civilDefenseNationalGuardMilitaryPolice,4},{emergencyOrganizationPersonnel,5},{highwayServiceVehiclePersonnel,6}]),V16@Buf1},
{V16@V11,V16@Buf12}
end;
0 ->
{asn1_NOVALUE,Bytes21}
end,

%% attribute assistType(21) with type BIT STRING
{Term21,Bytes23} = case (Opt bsr 5) band 1 of
1 ->
begin
{V17@V0,V17@Buf1} = case Bytes22 of
<<0:1,V17@V3:6/binary-unit:1,V17@Buf4/bitstring>> ->
{V17@V3,V17@Buf4};
<<1:1,V17@Buf2/bitstring>> ->
{V17@V3,V17@Buf4} = case V17@Buf2 of
<<0:1,V17@V6:7,V17@V8:V17@V6/binary-unit:1,V17@Buf9/bitstring>> ->
{V17@V8,V17@Buf9};
<<1:1,0:1,V17@V7:14,V17@V9:V17@V7/binary-unit:1,V17@Buf10/bitstring>> ->
{V17@V9,V17@Buf10};
<<1:1,1:1,V17@V7:6,V17@Buf8/bitstring>> ->
{V17@V9,V17@Buf10}  = decode_fragmented(V17@V7, V17@Buf8, 1),
{V17@V9,V17@Buf10}
end,
{V17@V3,V17@Buf4}
end,
{V17@V11,V17@Buf12}  = {decode_named_bit_string(V17@V0, [{unavailable,0},{otherType,1},{vision,2},{hearing,3},{movement,4},{cognition,5}]),V17@Buf1},
{V17@V11,V17@Buf12}
end;
0 ->
{asn1_NOVALUE,Bytes22}
end,

%% attribute sizing(22) with type BIT STRING
{Term22,Bytes24} = case (Opt bsr 4) band 1 of
1 ->
begin
{V18@V0,V18@Buf1} = case Bytes23 of
<<0:1,V18@V3:5/binary-unit:1,V18@Buf4/bitstring>> ->
{V18@V3,V18@Buf4};
<<1:1,V18@Buf2/bitstring>> ->
{V18@V3,V18@Buf4} = case V18@Buf2 of
<<0:1,V18@V6:7,V18@V8:V18@V6/binary-unit:1,V18@Buf9/bitstring>> ->
{V18@V8,V18@Buf9};
<<1:1,0:1,V18@V7:14,V18@V9:V18@V7/binary-unit:1,V18@Buf10/bitstring>> ->
{V18@V9,V18@Buf10};
<<1:1,1:1,V18@V7:6,V18@Buf8/bitstring>> ->
{V18@V9,V18@Buf10}  = decode_fragmented(V18@V7, V18@Buf8, 1),
{V18@V9,V18@Buf10}
end,
{V18@V3,V18@Buf4}
end,
{V18@V11,V18@Buf12}  = {decode_named_bit_string(V18@V0, [{unavailable,0},{smallStature,1},{largeStature,2},{erraticMoving,3},{slowMoving,4}]),V18@Buf1},
{V18@V11,V18@Buf12}
end;
0 ->
{asn1_NOVALUE,Bytes23}
end,

%% attribute attachment(23) with type ENUMERATED
{Term23,Bytes25} = case (Opt bsr 3) band 1 of
1 ->
begin
{V19@V0,V19@Buf1} = case Bytes24 of
<<0:1,V19@V3:3,V19@Buf4/bitstring>> ->
V19@Int5 = case V19@V3 of
0 -> unavailable;
1 -> stroller;
2 -> bicycleTrailer;
3 -> cart;
4 -> wheelchair;
5 -> otherWalkAssistAttachments;
6 -> pet;
_ -> exit({error,{asn1,{decode_enumerated,V19@V3}}})
end,
{V19@Int5,V19@Buf4};
<<1:1,V19@Buf2/bitstring>> ->
{V19@V3,V19@Buf4} = case V19@Buf2 of
<<0:1,V19@V6:6,V19@Buf7/bitstring>> ->
{V19@V6,V19@Buf7};
<<1:1,V19@Buf5/bitstring>> ->
{V19@V6,V19@Buf7} = case V19@Buf5 of
<<0:1,V19@V9:7,V19@Buf10/bitstring>> when V19@V9 =/= 0 ->
{V19@V9,V19@Buf10};
<<1:1,0:1,V19@V10:14,V19@Buf11/bitstring>> when V19@V10 =/= 0 ->
{V19@V10,V19@Buf11}
end,
<<V19@V12:V19@V6/unit:8,V19@Buf13/bitstring>> = V19@Buf7,
{V19@V12,V19@Buf13}
end,
V19@Int14 = case V19@V3 of
_ -> {asn1_enum,V19@V3}
end,
{V19@Int14,V19@Buf4}
end,
{V19@V0,V19@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes24}
end,

%% attribute attachmentRadius(24) with type INTEGER
{Term24,Bytes26} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V20@V0:8,V20@Buf1/bitstring>> = Bytes25,
{V20@V0,V20@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes25}
end,

%% attribute animalType(25) with type ENUMERATED
{Term25,Bytes27} = case (Opt bsr 1) band 1 of
1 ->
begin
{V21@V0,V21@Buf1} = case Bytes26 of
<<0:1,V21@V3:2,V21@Buf4/bitstring>> ->
V21@Int5 = case V21@V3 of
0 -> unavailable;
1 -> serviceUse;
2 -> pet;
3 -> farm
end,
{V21@Int5,V21@Buf4};
<<1:1,V21@Buf2/bitstring>> ->
{V21@V3,V21@Buf4} = case V21@Buf2 of
<<0:1,V21@V6:6,V21@Buf7/bitstring>> ->
{V21@V6,V21@Buf7};
<<1:1,V21@Buf5/bitstring>> ->
{V21@V6,V21@Buf7} = case V21@Buf5 of
<<0:1,V21@V9:7,V21@Buf10/bitstring>> when V21@V9 =/= 0 ->
{V21@V9,V21@Buf10};
<<1:1,0:1,V21@V10:14,V21@Buf11/bitstring>> when V21@V10 =/= 0 ->
{V21@V10,V21@Buf11}
end,
<<V21@V12:V21@V6/unit:8,V21@Buf13/bitstring>> = V21@Buf7,
{V21@V12,V21@Buf13}
end,
V21@Int14 = case V21@V3 of
_ -> {asn1_enum,V21@V3}
end,
{V21@Int14,V21@Buf4}
end,
{V21@V0,V21@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes26}
end,

%% attribute regional(26) with type SEQUENCE OF
{Term26,Bytes28} = case Opt band 1 of
1 ->
dec_PersonalSafetyMessage_regional(Bytes27);
0 ->
{asn1_NOVALUE,Bytes27}
end,

%% Extensions
{Extensions,Bytes29} = case Ext of
0 -> {<<>>,Bytes28};
1 ->
{V22@V0,V22@Buf1} = case Bytes28 of
<<0:1,V22@V3:6,V22@Buf4/bitstring>> ->
V22@Add5 = V22@V3 + 1,
{V22@Add5,V22@Buf4};
<<1:1,V22@Buf2/bitstring>> ->
{V22@V3,V22@Buf4} = case V22@Buf2 of
<<0:1,V22@V6:7,V22@Buf7/bitstring>> when V22@V6 =/= 0 ->
{V22@V6,V22@Buf7};
<<1:1,0:1,V22@V7:14,V22@Buf8/bitstring>> when V22@V7 =/= 0 ->
{V22@V7,V22@Buf8}
end,
{V22@V3,V22@Buf4}
end,
<<V22@V9:V22@V0/bitstring-unit:1,V22@Buf10/bitstring>> = V22@Buf1,
{V22@V9,V22@Buf10}
end,
Bytes30= skipextensions(Bytes29, 1, Extensions),
Res1 = #{basicType=>Term1,secMark=>Term2,msgCnt=>Term3,id=>Term4,position=>Term5,accuracy=>Term6,speed=>Term7,heading=>Term8},
Res2 = case Term9 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{accelSet=>Term9}
end,
Res3 = case Term10 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{pathHistory=>Term10}
end,
Res4 = case Term11 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{pathPrediction=>Term11}
end,
Res5 = case Term12 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{propulsion=>Term12}
end,
Res6 = case Term13 of
  asn1_NOVALUE -> Res5;
  _ -> Res5#{useState=>Term13}
end,
Res7 = case Term14 of
  asn1_NOVALUE -> Res6;
  _ -> Res6#{crossRequest=>Term14}
end,
Res8 = case Term15 of
  asn1_NOVALUE -> Res7;
  _ -> Res7#{crossState=>Term15}
end,
Res9 = case Term16 of
  asn1_NOVALUE -> Res8;
  _ -> Res8#{clusterSize=>Term16}
end,
Res10 = case Term17 of
  asn1_NOVALUE -> Res9;
  _ -> Res9#{clusterRadius=>Term17}
end,
Res11 = case Term18 of
  asn1_NOVALUE -> Res10;
  _ -> Res10#{eventResponderType=>Term18}
end,
Res12 = case Term19 of
  asn1_NOVALUE -> Res11;
  _ -> Res11#{activityType=>Term19}
end,
Res13 = case Term20 of
  asn1_NOVALUE -> Res12;
  _ -> Res12#{activitySubType=>Term20}
end,
Res14 = case Term21 of
  asn1_NOVALUE -> Res13;
  _ -> Res13#{assistType=>Term21}
end,
Res15 = case Term22 of
  asn1_NOVALUE -> Res14;
  _ -> Res14#{sizing=>Term22}
end,
Res16 = case Term23 of
  asn1_NOVALUE -> Res15;
  _ -> Res15#{attachment=>Term23}
end,
Res17 = case Term24 of
  asn1_NOVALUE -> Res16;
  _ -> Res16#{attachmentRadius=>Term24}
end,
Res18 = case Term25 of
  asn1_NOVALUE -> Res17;
  _ -> Res17#{animalType=>Term25}
end,
Res19 = case Term26 of
  asn1_NOVALUE -> Res18;
  _ -> Res18#{regional=>Term26}
end,
{Res19,Bytes30}.


dec_PersonalSafetyMessage_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components22(V1@Add2, V1@Buf1, []).


dec_PersonalSafetyMessage_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_ProbeDataManagement(Val) ->
#{sample:=Input@2,directions:=Input@3,term:=Input@4,snapshot:=Input@5,txInterval:=Input@6} = Val,
Input@1 = case Val of
  #{timeStamp:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@7 = case Val of
  #{dataElements:=Input@7_0} -> Input@7_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@8 = case Val of
  #{regional:=Input@8_0} -> Input@8_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@7 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@7 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@8 =:= asn1__MISSING_IN_MAP ->
<<0:1>>;
true ->
<<1:1>>
end,
begin
%% attribute timeStamp(1) with type INTEGER
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@1, Input@1 < 527041 ->
<<Input@1:20>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute sample(2) with type Sample
enc_Sample(Input@2)
end,
begin
%% attribute directions(3) with type BIT STRING
Enc4@bs = try bit_string_name2pos_23(Input@3) of
Enc4@positions ->
bitstring_from_positions(Enc4@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(Input@3, 16)
end,
Enc4@bits = bit_size(Enc4@bs),
if Enc4@bits =:= 16 ->
Enc4@bs
end
end,
begin
%% attribute term(4) with type CHOICE
enc_ProbeDataManagement_term(Input@4)
end,
begin
%% attribute snapshot(5) with type CHOICE
enc_ProbeDataManagement_snapshot(Input@5)
end,
begin
%% attribute txInterval(6) with type INTEGER
if 0 =< Input@6, Input@6 < 62 ->
<<Input@6:6>>;
true ->
exit({error,{asn1,{illegal_integer,Input@6}}})
end
end,
begin
%% attribute dataElements(7) with type VehicleStatusRequestList
if Input@7 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_VehicleStatusRequestList(Input@7)
end
end|begin
%% attribute regional(8) with type SEQUENCE OF
if Input@8 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_ProbeDataManagement_regional(Input@8)
end
end].
enc_ProbeDataManagement_term(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= termtime ->
begin
ChoiceVal@sub = ChoiceVal - 1,
if 0 =< ChoiceVal@sub, ChoiceVal@sub < 1800 ->
<<0:1,ChoiceVal@sub:11>>;
true ->
exit({error,{asn1,{illegal_integer,ChoiceVal}}})
end
end;
ChoiceTag =:= termDistance ->
begin
ChoiceVal@sub = ChoiceVal - 1,
if 0 =< ChoiceVal@sub, ChoiceVal@sub < 30000 ->
<<1:1,ChoiceVal@sub:15>>;
true ->
exit({error,{asn1,{illegal_integer,ChoiceVal}}})
end
end
end.
enc_ProbeDataManagement_snapshot(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= snapshotTime ->
[<<0:1>>|enc_SnapshotTime(ChoiceVal)];
ChoiceTag =:= snapshotDistance ->
[<<1:1>>|enc_SnapshotDistance(ChoiceVal)]
end.
enc_ProbeDataManagement_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_ProbeDataManagement_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_ProbeDataManagement_regional_RegionalExtension(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_ProbeDataManagement(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:3,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute timeStamp(1) with type INTEGER
{Term1,Bytes3} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V3@V0:20,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute sample(2) with type Sample
{Term2,Bytes4} = dec_Sample(Bytes3),

%% attribute directions(3) with type BIT STRING
{Term3,Bytes5} = begin
<<V4@V0:16/binary-unit:1,V4@Buf1/bitstring>> = Bytes4,
{V4@V2,V4@Buf3}  = {decode_named_bit_string(V4@V0, [{'from000-0to022-5degrees',0},{'from022-5to045-0degrees',1},{'from045-0to067-5degrees',2},{'from067-5to090-0degrees',3},{'from090-0to112-5degrees',4},{'from112-5to135-0degrees',5},{'from135-0to157-5degrees',6},{'from157-5to180-0degrees',7},{'from180-0to202-5degrees',8},{'from202-5to225-0degrees',9},{'from225-0to247-5degrees',10},{'from247-5to270-0degrees',11},{'from270-0to292-5degrees',12},{'from292-5to315-0degrees',13},{'from315-0to337-5degrees',14},{'from337-5to360-0degrees',15}]),V4@Buf1},
{V4@V2,V4@Buf3}
end,

%% attribute term(4) with type CHOICE
{Term4,Bytes6} = dec_ProbeDataManagement_term(Bytes5),

%% attribute snapshot(5) with type CHOICE
{Term5,Bytes7} = dec_ProbeDataManagement_snapshot(Bytes6),

%% attribute txInterval(6) with type INTEGER
{Term6,Bytes8} = begin
<<V5@V0:6,V5@Buf1/bitstring>> = Bytes7,
{V5@V0,V5@Buf1}
end,

%% attribute dataElements(7) with type VehicleStatusRequestList
{Term7,Bytes9} = case (Opt bsr 1) band 1 of
1 ->
dec_VehicleStatusRequestList(Bytes8);
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% attribute regional(8) with type SEQUENCE OF
{Term8,Bytes10} = case Opt band 1 of
1 ->
dec_ProbeDataManagement_regional(Bytes9);
0 ->
{asn1_NOVALUE,Bytes9}
end,

%% Extensions
{Extensions,Bytes11} = case Ext of
0 -> {<<>>,Bytes10};
1 ->
{V6@V0,V6@Buf1} = case Bytes10 of
<<0:1,V6@V3:6,V6@Buf4/bitstring>> ->
V6@Add5 = V6@V3 + 1,
{V6@Add5,V6@Buf4};
<<1:1,V6@Buf2/bitstring>> ->
{V6@V3,V6@Buf4} = case V6@Buf2 of
<<0:1,V6@V6:7,V6@Buf7/bitstring>> when V6@V6 =/= 0 ->
{V6@V6,V6@Buf7};
<<1:1,0:1,V6@V7:14,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
{V6@V7,V6@Buf8}
end,
{V6@V3,V6@Buf4}
end,
<<V6@V9:V6@V0/bitstring-unit:1,V6@Buf10/bitstring>> = V6@Buf1,
{V6@V9,V6@Buf10}
end,
Bytes12= skipextensions(Bytes11, 1, Extensions),
Res1 = #{sample=>Term2,directions=>Term3,term=>Term4,snapshot=>Term5,txInterval=>Term6},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{timeStamp=>Term1}
end,
Res3 = case Term7 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{dataElements=>Term7}
end,
Res4 = case Term8 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{regional=>Term8}
end,
{Res4,Bytes12}.


dec_ProbeDataManagement_term(Bytes) ->
{Choice,Bytes1} = 
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
begin
<<V2@V0:11,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + 1,
{V2@Add2,V2@Buf1}
end
end,
{{termtime,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
begin
<<V3@V0:15,V3@Buf1/bitstring>> = Bytes1,
V3@Add2 = V3@V0 + 1,
{V3@Add2,V3@Buf1}
end
end,
{{termDistance,Val},NewBytes}
end.

dec_ProbeDataManagement_snapshot(Bytes) ->
{Choice,Bytes1} = 
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
dec_SnapshotTime(Bytes1)
end,
{{snapshotTime,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
dec_SnapshotDistance(Bytes1)
end,
{{snapshotDistance,Val},NewBytes}
end.

dec_ProbeDataManagement_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components24(V1@Add2, V1@Buf1, []).


dec_ProbeDataManagement_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_ProbeVehicleData(Val) ->
#{startVector:=Input@4,vehicleType:=Input@5,snapshots:=Input@6} = Val,
Input@1 = case Val of
  #{timeStamp:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{segNum:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{probeID:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@7 = case Val of
  #{regional:=Input@7_0} -> Input@7_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@3 =:= asn1__MISSING_IN_MAP ->
if Input@7 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@7 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
begin
%% attribute timeStamp(1) with type INTEGER
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@1, Input@1 < 527041 ->
<<Input@1:20>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute segNum(2) with type INTEGER
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
Input@2 bsr 15 =:= 0 ->
<<Input@2:15>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end,
begin
%% attribute probeID(3) with type VehicleIdent
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_VehicleIdent(Input@3)
end
end,
begin
%% attribute startVector(4) with type FullPositionVector
enc_FullPositionVector(Input@4)
end,
begin
%% attribute vehicleType(5) with type VehicleClassification
enc_VehicleClassification(Input@5)
end,
begin
%% attribute snapshots(6) with type SEQUENCE OF
enc_ProbeVehicleData_snapshots(Input@6)
end|begin
%% attribute regional(7) with type SEQUENCE OF
if Input@7 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_ProbeVehicleData_regional(Input@7)
end
end].
enc_ProbeVehicleData_snapshots(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 5 =:= 0 ->
[<<Enc1@len@sub:5>>|[enc_Snapshot(Comp) || Comp <- Val]]
end.

enc_ProbeVehicleData_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_ProbeVehicleData_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_ProbeVehicleData_regional_RegionalExtension(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_ProbeVehicleData(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:4,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute timeStamp(1) with type INTEGER
{Term1,Bytes3} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V3@V0:20,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute segNum(2) with type INTEGER
{Term2,Bytes4} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V4@V0:15,V4@Buf1/bitstring>> = Bytes3,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute probeID(3) with type VehicleIdent
{Term3,Bytes5} = case (Opt bsr 1) band 1 of
1 ->
dec_VehicleIdent(Bytes4);
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute startVector(4) with type FullPositionVector
{Term4,Bytes6} = dec_FullPositionVector(Bytes5),

%% attribute vehicleType(5) with type VehicleClassification
{Term5,Bytes7} = dec_VehicleClassification(Bytes6),

%% attribute snapshots(6) with type SEQUENCE OF
{Term6,Bytes8} = dec_ProbeVehicleData_snapshots(Bytes7),

%% attribute regional(7) with type SEQUENCE OF
{Term7,Bytes9} = case Opt band 1 of
1 ->
dec_ProbeVehicleData_regional(Bytes8);
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% Extensions
{Extensions,Bytes10} = case Ext of
0 -> {<<>>,Bytes9};
1 ->
{V5@V0,V5@Buf1} = case Bytes9 of
<<0:1,V5@V3:6,V5@Buf4/bitstring>> ->
V5@Add5 = V5@V3 + 1,
{V5@Add5,V5@Buf4};
<<1:1,V5@Buf2/bitstring>> ->
{V5@V3,V5@Buf4} = case V5@Buf2 of
<<0:1,V5@V6:7,V5@Buf7/bitstring>> when V5@V6 =/= 0 ->
{V5@V6,V5@Buf7};
<<1:1,0:1,V5@V7:14,V5@Buf8/bitstring>> when V5@V7 =/= 0 ->
{V5@V7,V5@Buf8}
end,
{V5@V3,V5@Buf4}
end,
<<V5@V9:V5@V0/bitstring-unit:1,V5@Buf10/bitstring>> = V5@Buf1,
{V5@V9,V5@Buf10}
end,
Bytes11= skipextensions(Bytes10, 1, Extensions),
Res1 = #{startVector=>Term4,vehicleType=>Term5,snapshots=>Term6},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{timeStamp=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{segNum=>Term2}
end,
Res4 = case Term3 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{probeID=>Term3}
end,
Res5 = case Term7 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{regional=>Term7}
end,
{Res5,Bytes11}.


dec_ProbeVehicleData_snapshots(Bytes) ->
%% Length with constraint {1,32}
<<V1@V0:5,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components25(V1@Add2, V1@Buf1, []).


dec_ProbeVehicleData_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components26(V1@Add2, V1@Buf1, []).


dec_ProbeVehicleData_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_RoadSideAlert(Val) ->
#{msgCnt:=Input@1,typeEvent:=Input@3} = Val,
Input@2 = case Val of
  #{timeStamp:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{description:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{priority:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@6 = case Val of
  #{heading:=Input@6_0} -> Input@6_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@7 = case Val of
  #{extent:=Input@7_0} -> Input@7_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@8 = case Val of
  #{position:=Input@8_0} -> Input@8_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@9 = case Val of
  #{furtherInfoID:=Input@9_0} -> Input@9_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@10 = case Val of
  #{regional:=Input@10_0} -> Input@10_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@2 =:= asn1__MISSING_IN_MAP ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@5 =:= asn1__MISSING_IN_MAP ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@7 =:= asn1__MISSING_IN_MAP ->
if Input@8 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@8 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@9 =:= asn1__MISSING_IN_MAP ->
if Input@10 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@10 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
begin
%% attribute msgCnt(1) with type INTEGER
if Input@1 bsr 7 =:= 0 ->
<<Input@1:7>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute timeStamp(2) with type INTEGER
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@2, Input@2 < 527041 ->
<<Input@2:20>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end,
begin
%% attribute typeEvent(3) with type INTEGER
if Input@3 bsr 16 =:= 0 ->
<<Input@3:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end,
begin
%% attribute description(4) with type SEQUENCE OF
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_RoadSideAlert_description(Input@4)
end
end,
begin
%% attribute priority(5) with type OCTET STRING
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
enc_Binary_Id(Input@5, 1)
end
end
end,
begin
%% attribute heading(6) with type BIT STRING
if Input@6 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Enc9@bs = try bit_string_name2pos_23(Input@6) of
Enc9@positions ->
bitstring_from_positions(Enc9@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(Input@6, 16)
end,
Enc9@bits = bit_size(Enc9@bs),
if Enc9@bits =:= 16 ->
Enc9@bs
end
end
end
end,
begin
%% attribute extent(7) with type ENUMERATED
if Input@7 =:= asn1__MISSING_IN_MAP ->
[];
Input@7 =:= useInstantlyOnly ->
<<0:4>>;
Input@7 =:= useFor3meters ->
<<1:4>>;
Input@7 =:= useFor10meters ->
<<2:4>>;
Input@7 =:= useFor50meters ->
<<3:4>>;
Input@7 =:= useFor100meters ->
<<4:4>>;
Input@7 =:= useFor500meters ->
<<5:4>>;
Input@7 =:= useFor1000meters ->
<<6:4>>;
Input@7 =:= useFor5000meters ->
<<7:4>>;
Input@7 =:= useFor10000meters ->
<<8:4>>;
Input@7 =:= useFor50000meters ->
<<9:4>>;
Input@7 =:= useFor100000meters ->
<<10:4>>;
Input@7 =:= useFor500000meters ->
<<11:4>>;
Input@7 =:= useFor1000000meters ->
<<12:4>>;
Input@7 =:= useFor5000000meters ->
<<13:4>>;
Input@7 =:= useFor10000000meters ->
<<14:4>>;
Input@7 =:= forever ->
<<15:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@7}}})
end
end,
begin
%% attribute position(8) with type FullPositionVector
if Input@8 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_FullPositionVector(Input@8)
end
end,
begin
%% attribute furtherInfoID(9) with type OCTET STRING
if Input@9 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
enc_Binary_Id(Input@9, 2)
end
end
end|begin
%% attribute regional(10) with type SEQUENCE OF
if Input@10 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_RoadSideAlert_regional(Input@10)
end
end].
enc_RoadSideAlert_description(Val) ->
Enc2@len = length(Val),
Enc2@len@sub = Enc2@len - 1,
if Enc2@len@sub bsr 3 =:= 0 ->
[<<Enc2@len@sub:3>>|[if Comp bsr 16 =:= 0 ->
<<Comp:16>>;
true ->
exit({error,{asn1,{illegal_integer,Comp}}})
end || Comp <- Val]]
end.

enc_RoadSideAlert_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_RoadSideAlert_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_RoadSideAlert_regional_RegionalExtension(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_RoadSideAlert(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute msgCnt(1) with type INTEGER
{Term1,Bytes3} = begin
<<V3@V0:7,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute timeStamp(2) with type INTEGER
{Term2,Bytes4} = case (Opt bsr 7) band 1 of
1 ->
begin
<<V4@V0:20,V4@Buf1/bitstring>> = Bytes3,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute typeEvent(3) with type INTEGER
{Term3,Bytes5} = begin
<<V5@V0:16,V5@Buf1/bitstring>> = Bytes4,
{V5@V0,V5@Buf1}
end,

%% attribute description(4) with type SEQUENCE OF
{Term4,Bytes6} = case (Opt bsr 6) band 1 of
1 ->
dec_RoadSideAlert_description(Bytes5);
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute priority(5) with type OCTET STRING
{Term5,Bytes7} = case (Opt bsr 5) band 1 of
1 ->
begin
<<V6@V0:1/binary-unit:8,V6@Buf1/bitstring>> = Bytes6,
V6@Conv2 = binary:copy(V6@V0),
{V6@Conv2,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute heading(6) with type BIT STRING
{Term6,Bytes8} = case (Opt bsr 4) band 1 of
1 ->
begin
<<V7@V0:16/binary-unit:1,V7@Buf1/bitstring>> = Bytes7,
{V7@V2,V7@Buf3}  = {decode_named_bit_string(V7@V0, [{'from000-0to022-5degrees',0},{'from022-5to045-0degrees',1},{'from045-0to067-5degrees',2},{'from067-5to090-0degrees',3},{'from090-0to112-5degrees',4},{'from112-5to135-0degrees',5},{'from135-0to157-5degrees',6},{'from157-5to180-0degrees',7},{'from180-0to202-5degrees',8},{'from202-5to225-0degrees',9},{'from225-0to247-5degrees',10},{'from247-5to270-0degrees',11},{'from270-0to292-5degrees',12},{'from292-5to315-0degrees',13},{'from315-0to337-5degrees',14},{'from337-5to360-0degrees',15}]),V7@Buf1},
{V7@V2,V7@Buf3}
end;
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute extent(7) with type ENUMERATED
{Term7,Bytes9} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V8@V0:4,V8@Buf1/bitstring>> = Bytes8,
V8@Int2 = case V8@V0 of
0 -> useInstantlyOnly;
1 -> useFor3meters;
2 -> useFor10meters;
3 -> useFor50meters;
4 -> useFor100meters;
5 -> useFor500meters;
6 -> useFor1000meters;
7 -> useFor5000meters;
8 -> useFor10000meters;
9 -> useFor50000meters;
10 -> useFor100000meters;
11 -> useFor500000meters;
12 -> useFor1000000meters;
13 -> useFor5000000meters;
14 -> useFor10000000meters;
15 -> forever
end,
{V8@Int2,V8@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% attribute position(8) with type FullPositionVector
{Term8,Bytes10} = case (Opt bsr 2) band 1 of
1 ->
dec_FullPositionVector(Bytes9);
0 ->
{asn1_NOVALUE,Bytes9}
end,

%% attribute furtherInfoID(9) with type OCTET STRING
{Term9,Bytes11} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V9@V0:2/binary-unit:8,V9@Buf1/bitstring>> = Bytes10,
V9@Conv2 = binary:copy(V9@V0),
{dec_Binary_Id(V9@Conv2),V9@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes10}
end,

%% attribute regional(10) with type SEQUENCE OF
{Term10,Bytes12} = case Opt band 1 of
1 ->
dec_RoadSideAlert_regional(Bytes11);
0 ->
{asn1_NOVALUE,Bytes11}
end,

%% Extensions
{Extensions,Bytes13} = case Ext of
0 -> {<<>>,Bytes12};
1 ->
{V10@V0,V10@Buf1} = case Bytes12 of
<<0:1,V10@V3:6,V10@Buf4/bitstring>> ->
V10@Add5 = V10@V3 + 1,
{V10@Add5,V10@Buf4};
<<1:1,V10@Buf2/bitstring>> ->
{V10@V3,V10@Buf4} = case V10@Buf2 of
<<0:1,V10@V6:7,V10@Buf7/bitstring>> when V10@V6 =/= 0 ->
{V10@V6,V10@Buf7};
<<1:1,0:1,V10@V7:14,V10@Buf8/bitstring>> when V10@V7 =/= 0 ->
{V10@V7,V10@Buf8}
end,
{V10@V3,V10@Buf4}
end,
<<V10@V9:V10@V0/bitstring-unit:1,V10@Buf10/bitstring>> = V10@Buf1,
{V10@V9,V10@Buf10}
end,
Bytes14= skipextensions(Bytes13, 1, Extensions),
Res1 = #{msgCnt=>Term1,typeEvent=>Term3},
Res2 = case Term2 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{timeStamp=>Term2}
end,
Res3 = case Term4 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{description=>Term4}
end,
Res4 = case Term5 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{priority=>Term5}
end,
Res5 = case Term6 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{heading=>Term6}
end,
Res6 = case Term7 of
  asn1_NOVALUE -> Res5;
  _ -> Res5#{extent=>Term7}
end,
Res7 = case Term8 of
  asn1_NOVALUE -> Res6;
  _ -> Res6#{position=>Term8}
end,
Res8 = case Term9 of
  asn1_NOVALUE -> Res7;
  _ -> Res7#{furtherInfoID=>Term9}
end,
Res9 = case Term10 of
  asn1_NOVALUE -> Res8;
  _ -> Res8#{regional=>Term10}
end,
{Res9,Bytes14}.


dec_RoadSideAlert_description(Bytes) ->
%% Length with constraint {1,8}
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components27(V1@Add2, V1@Buf1, []).


dec_RoadSideAlert_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components28(V1@Add2, V1@Buf1, []).


dec_RoadSideAlert_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_RTCMcorrections(Val) ->
#{msgCnt:=Input@1,rev:=Input@2,msgs:=Input@6} = Val,
Input@3 = case Val of
  #{timeStamp:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{anchorPoint:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{rtcmHeader:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@7 = case Val of
  #{regional:=Input@7_0} -> Input@7_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@3 =:= asn1__MISSING_IN_MAP ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@5 =:= asn1__MISSING_IN_MAP ->
if Input@7 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@7 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
begin
%% attribute msgCnt(1) with type INTEGER
if Input@1 bsr 7 =:= 0 ->
<<Input@1:7>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute rev(2) with type ENUMERATED
if Input@2 =:= unknown ->
<<0:1,0:2>>;
Input@2 =:= rtcmRev2 ->
<<0:1,1:2>>;
Input@2 =:= rtcmRev3 ->
<<0:1,2:2>>;
Input@2 =:= reserved ->
<<0:1,3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@2}}})
end
end,
begin
%% attribute timeStamp(3) with type INTEGER
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@3, Input@3 < 527041 ->
<<Input@3:20>>;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end,
begin
%% attribute anchorPoint(4) with type FullPositionVector
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_FullPositionVector(Input@4)
end
end,
begin
%% attribute rtcmHeader(5) with type RTCMheader
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_RTCMheader(Input@5)
end
end,
begin
%% attribute msgs(6) with type RTCMmessageList
enc_RTCMmessageList(Input@6)
end|begin
%% attribute regional(7) with type SEQUENCE OF
if Input@7 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_RTCMcorrections_regional(Input@7)
end
end].
enc_RTCMcorrections_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_RTCMcorrections_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_RTCMcorrections_regional_RegionalExtension(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_RTCMcorrections(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:4,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute msgCnt(1) with type INTEGER
{Term1,Bytes3} = begin
<<V3@V0:7,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute rev(2) with type ENUMERATED
{Term2,Bytes4} = begin
{V4@V0,V4@Buf1} = case Bytes3 of
<<0:1,V4@V3:2,V4@Buf4/bitstring>> ->
V4@Int5 = case V4@V3 of
0 -> unknown;
1 -> rtcmRev2;
2 -> rtcmRev3;
3 -> reserved
end,
{V4@Int5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:6,V4@Buf7/bitstring>> ->
{V4@V6,V4@Buf7};
<<1:1,V4@Buf5/bitstring>> ->
{V4@V6,V4@Buf7} = case V4@Buf5 of
<<0:1,V4@V9:7,V4@Buf10/bitstring>> when V4@V9 =/= 0 ->
{V4@V9,V4@Buf10};
<<1:1,0:1,V4@V10:14,V4@Buf11/bitstring>> when V4@V10 =/= 0 ->
{V4@V10,V4@Buf11}
end,
<<V4@V12:V4@V6/unit:8,V4@Buf13/bitstring>> = V4@Buf7,
{V4@V12,V4@Buf13}
end,
V4@Int14 = case V4@V3 of
_ -> {asn1_enum,V4@V3}
end,
{V4@Int14,V4@Buf4}
end,
{V4@V0,V4@Buf1}
end,

%% attribute timeStamp(3) with type INTEGER
{Term3,Bytes5} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V5@V0:20,V5@Buf1/bitstring>> = Bytes4,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute anchorPoint(4) with type FullPositionVector
{Term4,Bytes6} = case (Opt bsr 2) band 1 of
1 ->
dec_FullPositionVector(Bytes5);
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute rtcmHeader(5) with type RTCMheader
{Term5,Bytes7} = case (Opt bsr 1) band 1 of
1 ->
dec_RTCMheader(Bytes6);
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute msgs(6) with type RTCMmessageList
{Term6,Bytes8} = dec_RTCMmessageList(Bytes7),

%% attribute regional(7) with type SEQUENCE OF
{Term7,Bytes9} = case Opt band 1 of
1 ->
dec_RTCMcorrections_regional(Bytes8);
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% Extensions
{Extensions,Bytes10} = case Ext of
0 -> {<<>>,Bytes9};
1 ->
{V6@V0,V6@Buf1} = case Bytes9 of
<<0:1,V6@V3:6,V6@Buf4/bitstring>> ->
V6@Add5 = V6@V3 + 1,
{V6@Add5,V6@Buf4};
<<1:1,V6@Buf2/bitstring>> ->
{V6@V3,V6@Buf4} = case V6@Buf2 of
<<0:1,V6@V6:7,V6@Buf7/bitstring>> when V6@V6 =/= 0 ->
{V6@V6,V6@Buf7};
<<1:1,0:1,V6@V7:14,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
{V6@V7,V6@Buf8}
end,
{V6@V3,V6@Buf4}
end,
<<V6@V9:V6@V0/bitstring-unit:1,V6@Buf10/bitstring>> = V6@Buf1,
{V6@V9,V6@Buf10}
end,
Bytes11= skipextensions(Bytes10, 1, Extensions),
Res1 = #{msgCnt=>Term1,rev=>Term2,msgs=>Term6},
Res2 = case Term3 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{timeStamp=>Term3}
end,
Res3 = case Term4 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{anchorPoint=>Term4}
end,
Res4 = case Term5 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{rtcmHeader=>Term5}
end,
Res5 = case Term7 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{regional=>Term7}
end,
{Res5,Bytes11}.


dec_RTCMcorrections_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components29(V1@Add2, V1@Buf1, []).


dec_RTCMcorrections_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_SPAT(Val) ->
#{intersections:=Input@3} = Val,
Input@1 = case Val of
  #{timeStamp:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{name:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{regional:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<0:1>>;
true ->
<<1:1>>
end,
begin
%% attribute timeStamp(1) with type INTEGER
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@1, Input@1 < 527041 ->
<<Input@1:20>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute name(2) with type IA5String
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Enc4@len = length(Input@2),
Enc4@bin = encode_chars(Input@2, 7),
Enc4@len@sub = Enc4@len - 1,
if 0 =< Enc4@len@sub, Enc4@len@sub < 63 ->
[<<Enc4@len@sub:6>>|Enc4@bin]
end
end
end
end,
begin
%% attribute intersections(3) with type IntersectionStateList
enc_IntersectionStateList(Input@3)
end|begin
%% attribute regional(4) with type SEQUENCE OF
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_SPAT_regional(Input@4)
end
end].
enc_SPAT_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_SPAT_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_SPAT_regional_RegionalExtension(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_SPAT(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:3,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute timeStamp(1) with type INTEGER
{Term1,Bytes3} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V3@V0:20,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute name(2) with type IA5String
{Term2,Bytes4} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V4@V0:6,V4@Buf1/bitstring>> = Bytes3,
V4@Add2 = V4@V0 + 1,
<<V4@V3:V4@Add2/binary-unit:7,V4@Buf4/bitstring>> = V4@Buf1,
{V4@V5,V4@Buf6}  = {decode_chars(V4@V3, 7),V4@Buf4},
{V4@V5,V4@Buf6}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute intersections(3) with type IntersectionStateList
{Term3,Bytes5} = dec_IntersectionStateList(Bytes4),

%% attribute regional(4) with type SEQUENCE OF
{Term4,Bytes6} = case Opt band 1 of
1 ->
dec_SPAT_regional(Bytes5);
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% Extensions
{Extensions,Bytes7} = case Ext of
0 -> {<<>>,Bytes6};
1 ->
{V5@V0,V5@Buf1} = case Bytes6 of
<<0:1,V5@V3:6,V5@Buf4/bitstring>> ->
V5@Add5 = V5@V3 + 1,
{V5@Add5,V5@Buf4};
<<1:1,V5@Buf2/bitstring>> ->
{V5@V3,V5@Buf4} = case V5@Buf2 of
<<0:1,V5@V6:7,V5@Buf7/bitstring>> when V5@V6 =/= 0 ->
{V5@V6,V5@Buf7};
<<1:1,0:1,V5@V7:14,V5@Buf8/bitstring>> when V5@V7 =/= 0 ->
{V5@V7,V5@Buf8}
end,
{V5@V3,V5@Buf4}
end,
<<V5@V9:V5@V0/bitstring-unit:1,V5@Buf10/bitstring>> = V5@Buf1,
{V5@V9,V5@Buf10}
end,
Bytes8= skipextensions(Bytes7, 1, Extensions),
Res1 = #{intersections=>Term3},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{timeStamp=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{name=>Term2}
end,
Res4 = case Term4 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{regional=>Term4}
end,
{Res4,Bytes8}.


dec_SPAT_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components30(V1@Add2, V1@Buf1, []).


dec_SPAT_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_SignalRequestMessage(Val) ->
#{second:=Input@2,requestor:=Input@5} = Val,
Input@1 = case Val of
  #{timeStamp:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{sequenceNumber:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{requests:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@6 = case Val of
  #{regional:=Input@6_0} -> Input@6_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@4 =:= asn1__MISSING_IN_MAP ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
begin
%% attribute timeStamp(1) with type INTEGER
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@1, Input@1 < 527041 ->
<<Input@1:20>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute second(2) with type INTEGER
if Input@2 bsr 16 =:= 0 ->
<<Input@2:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end,
begin
%% attribute sequenceNumber(3) with type INTEGER
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
Input@3 bsr 7 =:= 0 ->
<<Input@3:7>>;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end,
begin
%% attribute requests(4) with type SignalRequestList
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_SignalRequestList(Input@4)
end
end,
begin
%% attribute requestor(5) with type RequestorDescription
enc_RequestorDescription(Input@5)
end|begin
%% attribute regional(6) with type SEQUENCE OF
if Input@6 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_SignalRequestMessage_regional(Input@6)
end
end].
enc_SignalRequestMessage_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_SignalRequestMessage_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_SignalRequestMessage_regional_RegionalExtension(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_SignalRequestMessage(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:4,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute timeStamp(1) with type INTEGER
{Term1,Bytes3} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V3@V0:20,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute second(2) with type INTEGER
{Term2,Bytes4} = begin
<<V4@V0:16,V4@Buf1/bitstring>> = Bytes3,
{V4@V0,V4@Buf1}
end,

%% attribute sequenceNumber(3) with type INTEGER
{Term3,Bytes5} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V5@V0:7,V5@Buf1/bitstring>> = Bytes4,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute requests(4) with type SignalRequestList
{Term4,Bytes6} = case (Opt bsr 1) band 1 of
1 ->
dec_SignalRequestList(Bytes5);
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute requestor(5) with type RequestorDescription
{Term5,Bytes7} = dec_RequestorDescription(Bytes6),

%% attribute regional(6) with type SEQUENCE OF
{Term6,Bytes8} = case Opt band 1 of
1 ->
dec_SignalRequestMessage_regional(Bytes7);
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% Extensions
{Extensions,Bytes9} = case Ext of
0 -> {<<>>,Bytes8};
1 ->
{V6@V0,V6@Buf1} = case Bytes8 of
<<0:1,V6@V3:6,V6@Buf4/bitstring>> ->
V6@Add5 = V6@V3 + 1,
{V6@Add5,V6@Buf4};
<<1:1,V6@Buf2/bitstring>> ->
{V6@V3,V6@Buf4} = case V6@Buf2 of
<<0:1,V6@V6:7,V6@Buf7/bitstring>> when V6@V6 =/= 0 ->
{V6@V6,V6@Buf7};
<<1:1,0:1,V6@V7:14,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
{V6@V7,V6@Buf8}
end,
{V6@V3,V6@Buf4}
end,
<<V6@V9:V6@V0/bitstring-unit:1,V6@Buf10/bitstring>> = V6@Buf1,
{V6@V9,V6@Buf10}
end,
Bytes10= skipextensions(Bytes9, 1, Extensions),
Res1 = #{second=>Term2,requestor=>Term5},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{timeStamp=>Term1}
end,
Res3 = case Term3 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{sequenceNumber=>Term3}
end,
Res4 = case Term4 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{requests=>Term4}
end,
Res5 = case Term6 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{regional=>Term6}
end,
{Res5,Bytes10}.


dec_SignalRequestMessage_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components31(V1@Add2, V1@Buf1, []).


dec_SignalRequestMessage_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_SignalStatusMessage(Val) ->
#{second:=Input@2,status:=Input@4} = Val,
Input@1 = case Val of
  #{timeStamp:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{sequenceNumber:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{regional:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<0:1>>;
true ->
<<1:1>>
end,
begin
%% attribute timeStamp(1) with type INTEGER
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@1, Input@1 < 527041 ->
<<Input@1:20>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute second(2) with type INTEGER
if Input@2 bsr 16 =:= 0 ->
<<Input@2:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end,
begin
%% attribute sequenceNumber(3) with type INTEGER
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
Input@3 bsr 7 =:= 0 ->
<<Input@3:7>>;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end,
begin
%% attribute status(4) with type SignalStatusList
enc_SignalStatusList(Input@4)
end|begin
%% attribute regional(5) with type SEQUENCE OF
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_SignalStatusMessage_regional(Input@5)
end
end].
enc_SignalStatusMessage_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_SignalStatusMessage_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_SignalStatusMessage_regional_RegionalExtension(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_SignalStatusMessage(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:3,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute timeStamp(1) with type INTEGER
{Term1,Bytes3} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V3@V0:20,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute second(2) with type INTEGER
{Term2,Bytes4} = begin
<<V4@V0:16,V4@Buf1/bitstring>> = Bytes3,
{V4@V0,V4@Buf1}
end,

%% attribute sequenceNumber(3) with type INTEGER
{Term3,Bytes5} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V5@V0:7,V5@Buf1/bitstring>> = Bytes4,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute status(4) with type SignalStatusList
{Term4,Bytes6} = dec_SignalStatusList(Bytes5),

%% attribute regional(5) with type SEQUENCE OF
{Term5,Bytes7} = case Opt band 1 of
1 ->
dec_SignalStatusMessage_regional(Bytes6);
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% Extensions
{Extensions,Bytes8} = case Ext of
0 -> {<<>>,Bytes7};
1 ->
{V6@V0,V6@Buf1} = case Bytes7 of
<<0:1,V6@V3:6,V6@Buf4/bitstring>> ->
V6@Add5 = V6@V3 + 1,
{V6@Add5,V6@Buf4};
<<1:1,V6@Buf2/bitstring>> ->
{V6@V3,V6@Buf4} = case V6@Buf2 of
<<0:1,V6@V6:7,V6@Buf7/bitstring>> when V6@V6 =/= 0 ->
{V6@V6,V6@Buf7};
<<1:1,0:1,V6@V7:14,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
{V6@V7,V6@Buf8}
end,
{V6@V3,V6@Buf4}
end,
<<V6@V9:V6@V0/bitstring-unit:1,V6@Buf10/bitstring>> = V6@Buf1,
{V6@V9,V6@Buf10}
end,
Bytes9= skipextensions(Bytes8, 1, Extensions),
Res1 = #{second=>Term2,status=>Term4},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{timeStamp=>Term1}
end,
Res3 = case Term3 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{sequenceNumber=>Term3}
end,
Res4 = case Term5 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{regional=>Term5}
end,
{Res4,Bytes9}.


dec_SignalStatusMessage_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components32(V1@Add2, V1@Buf1, []).


dec_SignalStatusMessage_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_TravelerInformation(Val) ->
#{msgCnt:=Input@1,dataFrames:=Input@5} = Val,
Input@2 = case Val of
  #{timeStamp:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{packetID:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{urlB:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@6 = case Val of
  #{regional:=Input@6_0} -> Input@6_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@2 =:= asn1__MISSING_IN_MAP ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@4 =:= asn1__MISSING_IN_MAP ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
begin
%% attribute msgCnt(1) with type INTEGER
if Input@1 bsr 7 =:= 0 ->
<<Input@1:7>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute timeStamp(2) with type INTEGER
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@2, Input@2 < 527041 ->
<<Input@2:20>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end,
begin
%% attribute packetID(3) with type OCTET STRING
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
enc_Binary_Id(Input@3, 9)
end
end
end,
begin
%% attribute urlB(4) with type IA5String
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Enc7@len = length(Input@4),
Enc7@bin = encode_chars(Input@4, 7),
Enc7@len@sub = Enc7@len - 1,
if 0 =< Enc7@len@sub, Enc7@len@sub < 45 ->
[<<Enc7@len@sub:6>>|Enc7@bin]
end
end
end
end,
begin
%% attribute dataFrames(5) with type TravelerDataFrameList
enc_TravelerDataFrameList(Input@5)
end|begin
%% attribute regional(6) with type SEQUENCE OF
if Input@6 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_TravelerInformation_regional(Input@6)
end
end].
enc_TravelerInformation_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_TravelerInformation_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_TravelerInformation_regional_RegionalExtension(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_TravelerInformation(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:4,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute msgCnt(1) with type INTEGER
{Term1,Bytes3} = begin
<<V3@V0:7,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute timeStamp(2) with type INTEGER
{Term2,Bytes4} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V4@V0:20,V4@Buf1/bitstring>> = Bytes3,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute packetID(3) with type OCTET STRING
{Term3,Bytes5} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V5@V0:9/binary-unit:8,V5@Buf1/bitstring>> = Bytes4,
V5@Conv2 = binary:copy(V5@V0),
{dec_Binary_Id(V5@Conv2),V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute urlB(4) with type IA5String
{Term4,Bytes6} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V6@V0:6,V6@Buf1/bitstring>> = Bytes5,
V6@Add2 = V6@V0 + 1,
<<V6@V3:V6@Add2/binary-unit:7,V6@Buf4/bitstring>> = V6@Buf1,
{V6@V5,V6@Buf6}  = {decode_chars(V6@V3, 7),V6@Buf4},
{V6@V5,V6@Buf6}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute dataFrames(5) with type TravelerDataFrameList
{Term5,Bytes7} = dec_TravelerDataFrameList(Bytes6),

%% attribute regional(6) with type SEQUENCE OF
{Term6,Bytes8} = case Opt band 1 of
1 ->
dec_TravelerInformation_regional(Bytes7);
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% Extensions
{Extensions,Bytes9} = case Ext of
0 -> {<<>>,Bytes8};
1 ->
{V7@V0,V7@Buf1} = case Bytes8 of
<<0:1,V7@V3:6,V7@Buf4/bitstring>> ->
V7@Add5 = V7@V3 + 1,
{V7@Add5,V7@Buf4};
<<1:1,V7@Buf2/bitstring>> ->
{V7@V3,V7@Buf4} = case V7@Buf2 of
<<0:1,V7@V6:7,V7@Buf7/bitstring>> when V7@V6 =/= 0 ->
{V7@V6,V7@Buf7};
<<1:1,0:1,V7@V7:14,V7@Buf8/bitstring>> when V7@V7 =/= 0 ->
{V7@V7,V7@Buf8}
end,
{V7@V3,V7@Buf4}
end,
<<V7@V9:V7@V0/bitstring-unit:1,V7@Buf10/bitstring>> = V7@Buf1,
{V7@V9,V7@Buf10}
end,
Bytes10= skipextensions(Bytes9, 1, Extensions),
Res1 = #{msgCnt=>Term1,dataFrames=>Term5},
Res2 = case Term2 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{timeStamp=>Term2}
end,
Res3 = case Term3 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{packetID=>Term3}
end,
Res4 = case Term4 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{urlB=>Term4}
end,
Res5 = case Term6 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{regional=>Term6}
end,
{Res5,Bytes10}.


dec_TravelerInformation_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components33(V1@Add2, V1@Buf1, []).


dec_TravelerInformation_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_TestMessage00(Val) ->
Input@1 = case Val of
  #{header:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{regional:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
begin
%% attribute header(1) with type Header
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_Header(Input@1)
end
end|begin
%% attribute regional(2) with type SEQUENCE
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_TestMessage00_regional(Input@2)
end
end].
enc_TestMessage00_regional(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_TestMessage00(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute header(1) with type Header
{Term1,Bytes3} = case (Opt bsr 1) band 1 of
1 ->
dec_Header(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute regional(2) with type SEQUENCE
{Term2,Bytes4} = case Opt band 1 of
1 ->
dec_TestMessage00_regional(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V3@V0,V3@Buf1} = case Bytes4 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V9:V3@V0/bitstring-unit:1,V3@Buf10/bitstring>> = V3@Buf1,
{V3@V9,V3@Buf10}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = #{},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{header=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{regional=>Term2}
end,
{Res3,Bytes6}.


dec_TestMessage00_regional(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_TestMessage01(Val) ->
Input@1 = case Val of
  #{header:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{regional:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
begin
%% attribute header(1) with type Header
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_Header(Input@1)
end
end|begin
%% attribute regional(2) with type SEQUENCE
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_TestMessage01_regional(Input@2)
end
end].
enc_TestMessage01_regional(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_TestMessage01(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute header(1) with type Header
{Term1,Bytes3} = case (Opt bsr 1) band 1 of
1 ->
dec_Header(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute regional(2) with type SEQUENCE
{Term2,Bytes4} = case Opt band 1 of
1 ->
dec_TestMessage01_regional(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V3@V0,V3@Buf1} = case Bytes4 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V9:V3@V0/bitstring-unit:1,V3@Buf10/bitstring>> = V3@Buf1,
{V3@V9,V3@Buf10}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = #{},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{header=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{regional=>Term2}
end,
{Res3,Bytes6}.


dec_TestMessage01_regional(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_TestMessage02(Val) ->
Input@1 = case Val of
  #{header:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{regional:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
begin
%% attribute header(1) with type Header
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_Header(Input@1)
end
end|begin
%% attribute regional(2) with type SEQUENCE
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_TestMessage02_regional(Input@2)
end
end].
enc_TestMessage02_regional(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_TestMessage02(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute header(1) with type Header
{Term1,Bytes3} = case (Opt bsr 1) band 1 of
1 ->
dec_Header(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute regional(2) with type SEQUENCE
{Term2,Bytes4} = case Opt band 1 of
1 ->
dec_TestMessage02_regional(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V3@V0,V3@Buf1} = case Bytes4 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V9:V3@V0/bitstring-unit:1,V3@Buf10/bitstring>> = V3@Buf1,
{V3@V9,V3@Buf10}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = #{},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{header=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{regional=>Term2}
end,
{Res3,Bytes6}.


dec_TestMessage02_regional(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_TestMessage03(Val) ->
Input@1 = case Val of
  #{header:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{regional:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
begin
%% attribute header(1) with type Header
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_Header(Input@1)
end
end|begin
%% attribute regional(2) with type SEQUENCE
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_TestMessage03_regional(Input@2)
end
end].
enc_TestMessage03_regional(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_TestMessage03(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute header(1) with type Header
{Term1,Bytes3} = case (Opt bsr 1) band 1 of
1 ->
dec_Header(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute regional(2) with type SEQUENCE
{Term2,Bytes4} = case Opt band 1 of
1 ->
dec_TestMessage03_regional(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V3@V0,V3@Buf1} = case Bytes4 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V9:V3@V0/bitstring-unit:1,V3@Buf10/bitstring>> = V3@Buf1,
{V3@V9,V3@Buf10}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = #{},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{header=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{regional=>Term2}
end,
{Res3,Bytes6}.


dec_TestMessage03_regional(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_TestMessage04(Val) ->
Input@1 = case Val of
  #{header:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{regional:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
begin
%% attribute header(1) with type Header
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_Header(Input@1)
end
end|begin
%% attribute regional(2) with type SEQUENCE
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_TestMessage04_regional(Input@2)
end
end].
enc_TestMessage04_regional(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_TestMessage04(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute header(1) with type Header
{Term1,Bytes3} = case (Opt bsr 1) band 1 of
1 ->
dec_Header(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute regional(2) with type SEQUENCE
{Term2,Bytes4} = case Opt band 1 of
1 ->
dec_TestMessage04_regional(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V3@V0,V3@Buf1} = case Bytes4 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V9:V3@V0/bitstring-unit:1,V3@Buf10/bitstring>> = V3@Buf1,
{V3@V9,V3@Buf10}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = #{},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{header=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{regional=>Term2}
end,
{Res3,Bytes6}.


dec_TestMessage04_regional(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_TestMessage05(Val) ->
Input@1 = case Val of
  #{header:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{regional:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
begin
%% attribute header(1) with type Header
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_Header(Input@1)
end
end|begin
%% attribute regional(2) with type SEQUENCE
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_TestMessage05_regional(Input@2)
end
end].
enc_TestMessage05_regional(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_TestMessage05(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute header(1) with type Header
{Term1,Bytes3} = case (Opt bsr 1) band 1 of
1 ->
dec_Header(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute regional(2) with type SEQUENCE
{Term2,Bytes4} = case Opt band 1 of
1 ->
dec_TestMessage05_regional(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V3@V0,V3@Buf1} = case Bytes4 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V9:V3@V0/bitstring-unit:1,V3@Buf10/bitstring>> = V3@Buf1,
{V3@V9,V3@Buf10}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = #{},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{header=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{regional=>Term2}
end,
{Res3,Bytes6}.


dec_TestMessage05_regional(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_TestMessage06(Val) ->
Input@1 = case Val of
  #{header:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{regional:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
begin
%% attribute header(1) with type Header
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_Header(Input@1)
end
end|begin
%% attribute regional(2) with type SEQUENCE
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_TestMessage06_regional(Input@2)
end
end].
enc_TestMessage06_regional(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_TestMessage06(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute header(1) with type Header
{Term1,Bytes3} = case (Opt bsr 1) band 1 of
1 ->
dec_Header(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute regional(2) with type SEQUENCE
{Term2,Bytes4} = case Opt band 1 of
1 ->
dec_TestMessage06_regional(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V3@V0,V3@Buf1} = case Bytes4 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V9:V3@V0/bitstring-unit:1,V3@Buf10/bitstring>> = V3@Buf1,
{V3@V9,V3@Buf10}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = #{},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{header=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{regional=>Term2}
end,
{Res3,Bytes6}.


dec_TestMessage06_regional(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_TestMessage07(Val) ->
Input@1 = case Val of
  #{header:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{regional:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
begin
%% attribute header(1) with type Header
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_Header(Input@1)
end
end|begin
%% attribute regional(2) with type SEQUENCE
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_TestMessage07_regional(Input@2)
end
end].
enc_TestMessage07_regional(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_TestMessage07(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute header(1) with type Header
{Term1,Bytes3} = case (Opt bsr 1) band 1 of
1 ->
dec_Header(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute regional(2) with type SEQUENCE
{Term2,Bytes4} = case Opt band 1 of
1 ->
dec_TestMessage07_regional(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V3@V0,V3@Buf1} = case Bytes4 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V9:V3@V0/bitstring-unit:1,V3@Buf10/bitstring>> = V3@Buf1,
{V3@V9,V3@Buf10}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = #{},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{header=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{regional=>Term2}
end,
{Res3,Bytes6}.


dec_TestMessage07_regional(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_TestMessage08(Val) ->
Input@1 = case Val of
  #{header:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{regional:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
begin
%% attribute header(1) with type Header
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_Header(Input@1)
end
end|begin
%% attribute regional(2) with type SEQUENCE
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_TestMessage08_regional(Input@2)
end
end].
enc_TestMessage08_regional(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_TestMessage08(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute header(1) with type Header
{Term1,Bytes3} = case (Opt bsr 1) band 1 of
1 ->
dec_Header(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute regional(2) with type SEQUENCE
{Term2,Bytes4} = case Opt band 1 of
1 ->
dec_TestMessage08_regional(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V3@V0,V3@Buf1} = case Bytes4 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V9:V3@V0/bitstring-unit:1,V3@Buf10/bitstring>> = V3@Buf1,
{V3@V9,V3@Buf10}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = #{},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{header=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{regional=>Term2}
end,
{Res3,Bytes6}.


dec_TestMessage08_regional(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_TestMessage09(Val) ->
Input@1 = case Val of
  #{header:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{regional:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
begin
%% attribute header(1) with type Header
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_Header(Input@1)
end
end|begin
%% attribute regional(2) with type SEQUENCE
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_TestMessage09_regional(Input@2)
end
end].
enc_TestMessage09_regional(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_TestMessage09(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute header(1) with type Header
{Term1,Bytes3} = case (Opt bsr 1) band 1 of
1 ->
dec_Header(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute regional(2) with type SEQUENCE
{Term2,Bytes4} = case Opt band 1 of
1 ->
dec_TestMessage09_regional(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V3@V0,V3@Buf1} = case Bytes4 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V9:V3@V0/bitstring-unit:1,V3@Buf10/bitstring>> = V3@Buf1,
{V3@V9,V3@Buf10}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = #{},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{header=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{regional=>Term2}
end,
{Res3,Bytes6}.


dec_TestMessage09_regional(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_TestMessage10(Val) ->
Input@1 = case Val of
  #{header:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{regional:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
begin
%% attribute header(1) with type Header
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_Header(Input@1)
end
end|begin
%% attribute regional(2) with type SEQUENCE
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_TestMessage10_regional(Input@2)
end
end].
enc_TestMessage10_regional(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_TestMessage10(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute header(1) with type Header
{Term1,Bytes3} = case (Opt bsr 1) band 1 of
1 ->
dec_Header(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute regional(2) with type SEQUENCE
{Term2,Bytes4} = case Opt band 1 of
1 ->
dec_TestMessage10_regional(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V3@V0,V3@Buf1} = case Bytes4 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V9:V3@V0/bitstring-unit:1,V3@Buf10/bitstring>> = V3@Buf1,
{V3@V9,V3@Buf10}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = #{},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{header=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{regional=>Term2}
end,
{Res3,Bytes6}.


dec_TestMessage10_regional(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_TestMessage11(Val) ->
Input@1 = case Val of
  #{header:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{regional:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
begin
%% attribute header(1) with type Header
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_Header(Input@1)
end
end|begin
%% attribute regional(2) with type SEQUENCE
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_TestMessage11_regional(Input@2)
end
end].
enc_TestMessage11_regional(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_TestMessage11(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute header(1) with type Header
{Term1,Bytes3} = case (Opt bsr 1) band 1 of
1 ->
dec_Header(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute regional(2) with type SEQUENCE
{Term2,Bytes4} = case Opt band 1 of
1 ->
dec_TestMessage11_regional(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V3@V0,V3@Buf1} = case Bytes4 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V9:V3@V0/bitstring-unit:1,V3@Buf10/bitstring>> = V3@Buf1,
{V3@V9,V3@Buf10}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = #{},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{header=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{regional=>Term2}
end,
{Res3,Bytes6}.


dec_TestMessage11_regional(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_TestMessage12(Val) ->
Input@1 = case Val of
  #{header:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{regional:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
begin
%% attribute header(1) with type Header
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_Header(Input@1)
end
end|begin
%% attribute regional(2) with type SEQUENCE
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_TestMessage12_regional(Input@2)
end
end].
enc_TestMessage12_regional(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_TestMessage12(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute header(1) with type Header
{Term1,Bytes3} = case (Opt bsr 1) band 1 of
1 ->
dec_Header(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute regional(2) with type SEQUENCE
{Term2,Bytes4} = case Opt band 1 of
1 ->
dec_TestMessage12_regional(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V3@V0,V3@Buf1} = case Bytes4 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V9:V3@V0/bitstring-unit:1,V3@Buf10/bitstring>> = V3@Buf1,
{V3@V9,V3@Buf10}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = #{},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{header=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{regional=>Term2}
end,
{Res3,Bytes6}.


dec_TestMessage12_regional(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_TestMessage13(Val) ->
Input@1 = case Val of
  #{header:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{regional:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
begin
%% attribute header(1) with type Header
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_Header(Input@1)
end
end|begin
%% attribute regional(2) with type SEQUENCE
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_TestMessage13_regional(Input@2)
end
end].
enc_TestMessage13_regional(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_TestMessage13(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute header(1) with type Header
{Term1,Bytes3} = case (Opt bsr 1) band 1 of
1 ->
dec_Header(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute regional(2) with type SEQUENCE
{Term2,Bytes4} = case Opt band 1 of
1 ->
dec_TestMessage13_regional(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V3@V0,V3@Buf1} = case Bytes4 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V9:V3@V0/bitstring-unit:1,V3@Buf10/bitstring>> = V3@Buf1,
{V3@V9,V3@Buf10}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = #{},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{header=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{regional=>Term2}
end,
{Res3,Bytes6}.


dec_TestMessage13_regional(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_TestMessage14(Val) ->
Input@1 = case Val of
  #{header:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{regional:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
begin
%% attribute header(1) with type Header
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_Header(Input@1)
end
end|begin
%% attribute regional(2) with type SEQUENCE
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_TestMessage14_regional(Input@2)
end
end].
enc_TestMessage14_regional(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_TestMessage14(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute header(1) with type Header
{Term1,Bytes3} = case (Opt bsr 1) band 1 of
1 ->
dec_Header(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute regional(2) with type SEQUENCE
{Term2,Bytes4} = case Opt band 1 of
1 ->
dec_TestMessage14_regional(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V3@V0,V3@Buf1} = case Bytes4 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V9:V3@V0/bitstring-unit:1,V3@Buf10/bitstring>> = V3@Buf1,
{V3@V9,V3@Buf10}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = #{},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{header=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{regional=>Term2}
end,
{Res3,Bytes6}.


dec_TestMessage14_regional(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_TestMessage15(Val) ->
Input@1 = case Val of
  #{header:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{regional:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
begin
%% attribute header(1) with type Header
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_Header(Input@1)
end
end|begin
%% attribute regional(2) with type SEQUENCE
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_TestMessage15_regional(Input@2)
end
end].
enc_TestMessage15_regional(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_TestMessage15(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute header(1) with type Header
{Term1,Bytes3} = case (Opt bsr 1) band 1 of
1 ->
dec_Header(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute regional(2) with type SEQUENCE
{Term2,Bytes4} = case Opt band 1 of
1 ->
dec_TestMessage15_regional(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V3@V0,V3@Buf1} = case Bytes4 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V9:V3@V0/bitstring-unit:1,V3@Buf10/bitstring>> = V3@Buf1,
{V3@V9,V3@Buf10}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = #{},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{header=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{regional=>Term2}
end,
{Res3,Bytes6}.


dec_TestMessage15_regional(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_AccelerationSet4Way(Val) ->
#{long:=Input@1,lat:=Input@2,vert:=Input@3,yaw:=Input@4} = Val,
[begin
%% attribute long(1) with type INTEGER
Input@1@sub = Input@1 - -2000,
if 0 =< Input@1@sub, Input@1@sub < 4002 ->
<<Input@1@sub:12>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute lat(2) with type INTEGER
Input@2@sub = Input@2 - -2000,
if 0 =< Input@2@sub, Input@2@sub < 4002 ->
<<Input@2@sub:12>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end,
begin
%% attribute vert(3) with type INTEGER
Input@3@sub = Input@3 - -127,
if 0 =< Input@3@sub, Input@3@sub < 255 ->
Input@3@sub;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end|begin
%% attribute yaw(4) with type INTEGER
Input@4@sub = Input@4 - -32767,
if 0 =< Input@4@sub, Input@4@sub < 65535 ->
<<Input@4@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@4}}})
end
end].


dec_AccelerationSet4Way(Bytes) ->

%% attribute long(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:12,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -2000,
{V1@Add2,V1@Buf1}
end,

%% attribute lat(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:12,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + -2000,
{V2@Add2,V2@Buf1}
end,

%% attribute vert(3) with type INTEGER
{Term3,Bytes3} = begin
<<V3@V0:8,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + -127,
{V3@Add2,V3@Buf1}
end,

%% attribute yaw(4) with type INTEGER
{Term4,Bytes4} = begin
<<V4@V0:16,V4@Buf1/bitstring>> = Bytes3,
V4@Add2 = V4@V0 + -32767,
{V4@Add2,V4@Buf1}
end,
Res1 = #{long=>Term1,lat=>Term2,vert=>Term3,yaw=>Term4},
{Res1,Bytes4}.

enc_AccelSteerYawRateConfidence(Val) ->
#{yawRate:=Input@1,acceleration:=Input@2,steeringWheelAngle:=Input@3} = Val,
[begin
%% attribute yawRate(1) with type ENUMERATED
if Input@1 =:= unavailable ->
<<0:3>>;
Input@1 =:= 'degSec-100-00' ->
<<1:3>>;
Input@1 =:= 'degSec-010-00' ->
<<2:3>>;
Input@1 =:= 'degSec-005-00' ->
<<3:3>>;
Input@1 =:= 'degSec-001-00' ->
<<4:3>>;
Input@1 =:= 'degSec-000-10' ->
<<5:3>>;
Input@1 =:= 'degSec-000-05' ->
<<6:3>>;
Input@1 =:= 'degSec-000-01' ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@1}}})
end
end,
begin
%% attribute acceleration(2) with type ENUMERATED
if Input@2 =:= unavailable ->
<<0:3>>;
Input@2 =:= 'accl-100-00' ->
<<1:3>>;
Input@2 =:= 'accl-010-00' ->
<<2:3>>;
Input@2 =:= 'accl-005-00' ->
<<3:3>>;
Input@2 =:= 'accl-001-00' ->
<<4:3>>;
Input@2 =:= 'accl-000-10' ->
<<5:3>>;
Input@2 =:= 'accl-000-05' ->
<<6:3>>;
Input@2 =:= 'accl-000-01' ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@2}}})
end
end|begin
%% attribute steeringWheelAngle(3) with type ENUMERATED
if Input@3 =:= unavailable ->
<<0:2>>;
Input@3 =:= prec2deg ->
<<1:2>>;
Input@3 =:= prec1deg ->
<<2:2>>;
Input@3 =:= 'prec0-02deg' ->
<<3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@3}}})
end
end].


dec_AccelSteerYawRateConfidence(Bytes) ->

%% attribute yawRate(1) with type ENUMERATED
{Term1,Bytes1} = begin
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> unavailable;
1 -> 'degSec-100-00';
2 -> 'degSec-010-00';
3 -> 'degSec-005-00';
4 -> 'degSec-001-00';
5 -> 'degSec-000-10';
6 -> 'degSec-000-05';
7 -> 'degSec-000-01'
end,
{V1@Int2,V1@Buf1}
end,

%% attribute acceleration(2) with type ENUMERATED
{Term2,Bytes2} = begin
<<V2@V0:3,V2@Buf1/bitstring>> = Bytes1,
V2@Int2 = case V2@V0 of
0 -> unavailable;
1 -> 'accl-100-00';
2 -> 'accl-010-00';
3 -> 'accl-005-00';
4 -> 'accl-001-00';
5 -> 'accl-000-10';
6 -> 'accl-000-05';
7 -> 'accl-000-01'
end,
{V2@Int2,V2@Buf1}
end,

%% attribute steeringWheelAngle(3) with type ENUMERATED
{Term3,Bytes3} = begin
<<V3@V0:2,V3@Buf1/bitstring>> = Bytes2,
V3@Int2 = case V3@V0 of
0 -> unavailable;
1 -> prec2deg;
2 -> prec1deg;
3 -> 'prec0-02deg'
end,
{V3@Int2,V3@Buf1}
end,
Res1 = #{yawRate=>Term1,acceleration=>Term2,steeringWheelAngle=>Term3},
{Res1,Bytes3}.

enc_AdvisorySpeed(Val) ->
#{type:=Input@1} = Val,
Input@2 = case Val of
  #{speed:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{confidence:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{distance:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{class:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@6 = case Val of
  #{regional:=Input@6_0} -> Input@6_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@2 =:= asn1__MISSING_IN_MAP ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@4 =:= asn1__MISSING_IN_MAP ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<0:1>>;
true ->
<<1:1>>
end,
begin
%% attribute type(1) with type ENUMERATED
if Input@1 =:= none ->
<<0:1,0:2>>;
Input@1 =:= greenwave ->
<<0:1,1:2>>;
Input@1 =:= ecoDrive ->
<<0:1,2:2>>;
Input@1 =:= transit ->
<<0:1,3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@1}}})
end
end,
begin
%% attribute speed(2) with type INTEGER
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@2, Input@2 < 501 ->
<<Input@2:9>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end,
begin
%% attribute confidence(3) with type ENUMERATED
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
Input@3 =:= unavailable ->
<<0:3>>;
Input@3 =:= prec100ms ->
<<1:3>>;
Input@3 =:= prec10ms ->
<<2:3>>;
Input@3 =:= prec5ms ->
<<3:3>>;
Input@3 =:= prec1ms ->
<<4:3>>;
Input@3 =:= 'prec0-1ms' ->
<<5:3>>;
Input@3 =:= 'prec0-05ms' ->
<<6:3>>;
Input@3 =:= 'prec0-01ms' ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@3}}})
end
end,
begin
%% attribute distance(4) with type INTEGER
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@4, Input@4 < 10001 ->
<<Input@4:14>>;
true ->
exit({error,{asn1,{illegal_integer,Input@4}}})
end
end,
begin
%% attribute class(5) with type INTEGER
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
Input@5 bsr 8 =:= 0 ->
Input@5;
true ->
exit({error,{asn1,{illegal_integer,Input@5}}})
end
end|begin
%% attribute regional(6) with type SEQUENCE OF
if Input@6 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_AdvisorySpeed_regional(Input@6)
end
end].
enc_AdvisorySpeed_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_AdvisorySpeed_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_AdvisorySpeed_regional_RegionalExtension(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_AdvisorySpeed(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:5,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute type(1) with type ENUMERATED
{Term1,Bytes3} = begin
{V3@V0,V3@Buf1} = case Bytes2 of
<<0:1,V3@V3:2,V3@Buf4/bitstring>> ->
V3@Int5 = case V3@V3 of
0 -> none;
1 -> greenwave;
2 -> ecoDrive;
3 -> transit
end,
{V3@Int5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:6,V3@Buf7/bitstring>> ->
{V3@V6,V3@Buf7};
<<1:1,V3@Buf5/bitstring>> ->
{V3@V6,V3@Buf7} = case V3@Buf5 of
<<0:1,V3@V9:7,V3@Buf10/bitstring>> when V3@V9 =/= 0 ->
{V3@V9,V3@Buf10};
<<1:1,0:1,V3@V10:14,V3@Buf11/bitstring>> when V3@V10 =/= 0 ->
{V3@V10,V3@Buf11}
end,
<<V3@V12:V3@V6/unit:8,V3@Buf13/bitstring>> = V3@Buf7,
{V3@V12,V3@Buf13}
end,
V3@Int14 = case V3@V3 of
_ -> {asn1_enum,V3@V3}
end,
{V3@Int14,V3@Buf4}
end,
{V3@V0,V3@Buf1}
end,

%% attribute speed(2) with type INTEGER
{Term2,Bytes4} = case (Opt bsr 4) band 1 of
1 ->
begin
<<V4@V0:9,V4@Buf1/bitstring>> = Bytes3,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute confidence(3) with type ENUMERATED
{Term3,Bytes5} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V5@V0:3,V5@Buf1/bitstring>> = Bytes4,
V5@Int2 = case V5@V0 of
0 -> unavailable;
1 -> prec100ms;
2 -> prec10ms;
3 -> prec5ms;
4 -> prec1ms;
5 -> 'prec0-1ms';
6 -> 'prec0-05ms';
7 -> 'prec0-01ms'
end,
{V5@Int2,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute distance(4) with type INTEGER
{Term4,Bytes6} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V6@V0:14,V6@Buf1/bitstring>> = Bytes5,
{V6@V0,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute class(5) with type INTEGER
{Term5,Bytes7} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V7@V0:8,V7@Buf1/bitstring>> = Bytes6,
{V7@V0,V7@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute regional(6) with type SEQUENCE OF
{Term6,Bytes8} = case Opt band 1 of
1 ->
dec_AdvisorySpeed_regional(Bytes7);
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% Extensions
{Extensions,Bytes9} = case Ext of
0 -> {<<>>,Bytes8};
1 ->
{V8@V0,V8@Buf1} = case Bytes8 of
<<0:1,V8@V3:6,V8@Buf4/bitstring>> ->
V8@Add5 = V8@V3 + 1,
{V8@Add5,V8@Buf4};
<<1:1,V8@Buf2/bitstring>> ->
{V8@V3,V8@Buf4} = case V8@Buf2 of
<<0:1,V8@V6:7,V8@Buf7/bitstring>> when V8@V6 =/= 0 ->
{V8@V6,V8@Buf7};
<<1:1,0:1,V8@V7:14,V8@Buf8/bitstring>> when V8@V7 =/= 0 ->
{V8@V7,V8@Buf8}
end,
{V8@V3,V8@Buf4}
end,
<<V8@V9:V8@V0/bitstring-unit:1,V8@Buf10/bitstring>> = V8@Buf1,
{V8@V9,V8@Buf10}
end,
Bytes10= skipextensions(Bytes9, 1, Extensions),
Res1 = #{type=>Term1},
Res2 = case Term2 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{speed=>Term2}
end,
Res3 = case Term3 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{confidence=>Term3}
end,
Res4 = case Term4 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{distance=>Term4}
end,
Res5 = case Term5 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{class=>Term5}
end,
Res6 = case Term6 of
  asn1_NOVALUE -> Res5;
  _ -> Res5#{regional=>Term6}
end,
{Res6,Bytes10}.


dec_AdvisorySpeed_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components34(V1@Add2, V1@Buf1, []).


dec_AdvisorySpeed_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_AdvisorySpeedList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 4 =:= 0 ->
[<<Enc1@len@sub:4>>|[enc_AdvisorySpeed(Comp) || Comp <- Val]]
end.



dec_AdvisorySpeedList(Bytes) ->
%% Length with constraint {1,16}
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components35(V1@Add2, V1@Buf1, []).

enc_AntennaOffsetSet(Val) ->
#{antOffsetX:=Input@1,antOffsetY:=Input@2,antOffsetZ:=Input@3} = Val,
[begin
%% attribute antOffsetX(1) with type INTEGER
Input@1@sub = Input@1 - -2048,
if Input@1@sub bsr 12 =:= 0 ->
<<Input@1@sub:12>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute antOffsetY(2) with type INTEGER
Input@2@sub = Input@2 - -256,
if Input@2@sub bsr 9 =:= 0 ->
<<Input@2@sub:9>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end|begin
%% attribute antOffsetZ(3) with type INTEGER
Input@3@sub = Input@3 - -512,
if Input@3@sub bsr 10 =:= 0 ->
<<Input@3@sub:10>>;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end].


dec_AntennaOffsetSet(Bytes) ->

%% attribute antOffsetX(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:12,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -2048,
{V1@Add2,V1@Buf1}
end,

%% attribute antOffsetY(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:9,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + -256,
{V2@Add2,V2@Buf1}
end,

%% attribute antOffsetZ(3) with type INTEGER
{Term3,Bytes3} = begin
<<V3@V0:10,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + -512,
{V3@Add2,V3@Buf1}
end,
Res1 = #{antOffsetX=>Term1,antOffsetY=>Term2,antOffsetZ=>Term3},
{Res1,Bytes3}.

enc_ApproachOrLane(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= approach ->
if ChoiceVal bsr 4 =:= 0 ->
<<0:1,ChoiceVal:4>>;
true ->
exit({error,{asn1,{illegal_integer,ChoiceVal}}})
end;
ChoiceTag =:= lane ->
if ChoiceVal bsr 8 =:= 0 ->
[<<1:1,ChoiceVal:8>>];
true ->
exit({error,{asn1,{illegal_integer,ChoiceVal}}})
end
end.


dec_ApproachOrLane(Bytes) ->
{Choice,Bytes1} = 
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
begin
<<V2@V0:4,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end
end,
{{approach,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
begin
<<V3@V0:8,V3@Buf1/bitstring>> = Bytes1,
{V3@V0,V3@Buf1}
end
end,
{{lane,Val},NewBytes}
end.
enc_BrakeSystemStatus(Val) ->
#{wheelBrakes:=Input@1,traction:=Input@2,abs:=Input@3,scs:=Input@4,brakeBoost:=Input@5,auxBrakes:=Input@6} = Val,
[begin
%% attribute wheelBrakes(1) with type BIT STRING
Enc1@bs = try bit_string_name2pos_36(Input@1) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 5)
catch throw:invalid ->
adjust_trailing_zeroes(Input@1, 5)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 5 ->
Enc1@bs
end
end,
begin
%% attribute traction(2) with type ENUMERATED
if Input@2 =:= unavailable ->
<<0:2>>;
Input@2 =:= off ->
<<1:2>>;
Input@2 =:= on ->
<<2:2>>;
Input@2 =:= engaged ->
<<3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@2}}})
end
end,
begin
%% attribute abs(3) with type ENUMERATED
if Input@3 =:= unavailable ->
<<0:2>>;
Input@3 =:= off ->
<<1:2>>;
Input@3 =:= on ->
<<2:2>>;
Input@3 =:= engaged ->
<<3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@3}}})
end
end,
begin
%% attribute scs(4) with type ENUMERATED
if Input@4 =:= unavailable ->
<<0:2>>;
Input@4 =:= off ->
<<1:2>>;
Input@4 =:= on ->
<<2:2>>;
Input@4 =:= engaged ->
<<3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@4}}})
end
end,
begin
%% attribute brakeBoost(5) with type ENUMERATED
if Input@5 =:= unavailable ->
<<0:2>>;
Input@5 =:= off ->
<<1:2>>;
Input@5 =:= on ->
<<2:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@5}}})
end
end|begin
%% attribute auxBrakes(6) with type ENUMERATED
if Input@6 =:= unavailable ->
<<0:2>>;
Input@6 =:= off ->
<<1:2>>;
Input@6 =:= on ->
<<2:2>>;
Input@6 =:= reserved ->
<<3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@6}}})
end
end].


dec_BrakeSystemStatus(Bytes) ->

%% attribute wheelBrakes(1) with type BIT STRING
{Term1,Bytes1} = begin
<<V1@V0:5/binary-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V2,V1@Buf3}  = {decode_named_bit_string(V1@V0, [{unavailable,0},{leftFront,1},{leftRear,2},{rightFront,3},{rightRear,4}]),V1@Buf1},
{V1@V2,V1@Buf3}
end,

%% attribute traction(2) with type ENUMERATED
{Term2,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
V2@Int2 = case V2@V0 of
0 -> unavailable;
1 -> off;
2 -> on;
3 -> engaged
end,
{V2@Int2,V2@Buf1}
end,

%% attribute abs(3) with type ENUMERATED
{Term3,Bytes3} = begin
<<V3@V0:2,V3@Buf1/bitstring>> = Bytes2,
V3@Int2 = case V3@V0 of
0 -> unavailable;
1 -> off;
2 -> on;
3 -> engaged
end,
{V3@Int2,V3@Buf1}
end,

%% attribute scs(4) with type ENUMERATED
{Term4,Bytes4} = begin
<<V4@V0:2,V4@Buf1/bitstring>> = Bytes3,
V4@Int2 = case V4@V0 of
0 -> unavailable;
1 -> off;
2 -> on;
3 -> engaged
end,
{V4@Int2,V4@Buf1}
end,

%% attribute brakeBoost(5) with type ENUMERATED
{Term5,Bytes5} = begin
<<V5@V0:2,V5@Buf1/bitstring>> = Bytes4,
V5@Int2 = case V5@V0 of
0 -> unavailable;
1 -> off;
2 -> on;
_ -> exit({error,{asn1,{decode_enumerated,V5@V0}}})
end,
{V5@Int2,V5@Buf1}
end,

%% attribute auxBrakes(6) with type ENUMERATED
{Term6,Bytes6} = begin
<<V6@V0:2,V6@Buf1/bitstring>> = Bytes5,
V6@Int2 = case V6@V0 of
0 -> unavailable;
1 -> off;
2 -> on;
3 -> reserved
end,
{V6@Int2,V6@Buf1}
end,
Res1 = #{wheelBrakes=>Term1,traction=>Term2,abs=>Term3,scs=>Term4,brakeBoost=>Term5,auxBrakes=>Term6},
{Res1,Bytes6}.

enc_BSMcoreData(Val) ->
#{msgCnt:=Input@1,id:=Input@2,secMark:=Input@3,lat:=Input@4,long:=Input@5,elev:=Input@6,accuracy:=Input@7,transmission:=Input@8,speed:=Input@9,heading:=Input@10,angle:=Input@11,accelSet:=Input@12,brakes:=Input@13,size:=Input@14} = Val,
[begin
%% attribute msgCnt(1) with type INTEGER
if Input@1 bsr 7 =:= 0 ->
<<Input@1:7>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute id(2) with type OCTET STRING
enc_Binary_Id(Input@2)
end,
begin
%% attribute secMark(3) with type INTEGER
if Input@3 bsr 16 =:= 0 ->
<<Input@3:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end,
begin
%% attribute lat(4) with type INTEGER
Input@4@sub = Input@4 - -900000000,
if 0 =< Input@4@sub, Input@4@sub < 1800000002 ->
<<Input@4@sub:31>>;
true ->
exit({error,{asn1,{illegal_integer,Input@4}}})
end
end,
begin
%% attribute long(5) with type INTEGER
Input@5@sub = Input@5 - -1799999999,
if 0 =< Input@5@sub, Input@5@sub < 3600000001 ->
<<Input@5@sub:32>>;
true ->
exit({error,{asn1,{illegal_integer,Input@5}}})
end
end,
begin
%% attribute elev(6) with type INTEGER
Input@6@sub = Input@6 - -4096,
if Input@6@sub bsr 16 =:= 0 ->
<<Input@6@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@6}}})
end
end,
begin
%% attribute accuracy(7) with type PositionalAccuracy
enc_PositionalAccuracy(Input@7)
end,
begin
%% attribute transmission(8) with type ENUMERATED
if Input@8 =:= neutral ->
<<0:3>>;
Input@8 =:= park ->
<<1:3>>;
Input@8 =:= forwardGears ->
<<2:3>>;
Input@8 =:= reverseGears ->
<<3:3>>;
Input@8 =:= reserved1 ->
<<4:3>>;
Input@8 =:= reserved2 ->
<<5:3>>;
Input@8 =:= reserved3 ->
<<6:3>>;
Input@8 =:= unavailable ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@8}}})
end
end,
begin
%% attribute speed(9) with type INTEGER
if Input@9 bsr 13 =:= 0 ->
<<Input@9:13>>;
true ->
exit({error,{asn1,{illegal_integer,Input@9}}})
end
end,
begin
%% attribute heading(10) with type INTEGER
if 0 =< Input@10, Input@10 < 28801 ->
<<Input@10:15>>;
true ->
exit({error,{asn1,{illegal_integer,Input@10}}})
end
end,
begin
%% attribute angle(11) with type INTEGER
Input@11@sub = Input@11 - -126,
if 0 =< Input@11@sub, Input@11@sub < 254 ->
Input@11@sub;
true ->
exit({error,{asn1,{illegal_integer,Input@11}}})
end
end,
begin
%% attribute accelSet(12) with type AccelerationSet4Way
enc_AccelerationSet4Way(Input@12)
end,
begin
%% attribute brakes(13) with type BrakeSystemStatus
enc_BrakeSystemStatus(Input@13)
end|begin
%% attribute size(14) with type VehicleSize
enc_VehicleSize(Input@14)
end].


dec_BSMcoreData(Bytes) ->

%% attribute msgCnt(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:7,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute id(2) with type OCTET STRING
{Term2,Bytes2} = begin
<<V2@V0:4/binary-unit:8,V2@Buf1/bitstring>> = Bytes1,
V2@Conv2 = binary:copy(V2@V0),
{dec_Binary_Id(V2@Conv2), V2@Buf1}
end,

%% attribute secMark(3) with type INTEGER
{Term3,Bytes3} = begin
<<V3@V0:16,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute lat(4) with type INTEGER
{Term4,Bytes4} = begin
<<V4@V0:31,V4@Buf1/bitstring>> = Bytes3,
V4@Add2 = V4@V0 + -900000000,
{V4@Add2,V4@Buf1}
end,

%% attribute long(5) with type INTEGER
{Term5,Bytes5} = begin
<<V5@V0:32,V5@Buf1/bitstring>> = Bytes4,
V5@Add2 = V5@V0 + -1799999999,
{V5@Add2,V5@Buf1}
end,

%% attribute elev(6) with type INTEGER
{Term6,Bytes6} = begin
<<V6@V0:16,V6@Buf1/bitstring>> = Bytes5,
V6@Add2 = V6@V0 + -4096,
{V6@Add2,V6@Buf1}
end,

%% attribute accuracy(7) with type PositionalAccuracy
{Term7,Bytes7} = dec_PositionalAccuracy(Bytes6),

%% attribute transmission(8) with type ENUMERATED
{Term8,Bytes8} = begin
<<V7@V0:3,V7@Buf1/bitstring>> = Bytes7,
V7@Int2 = case V7@V0 of
0 -> neutral;
1 -> park;
2 -> forwardGears;
3 -> reverseGears;
4 -> reserved1;
5 -> reserved2;
6 -> reserved3;
7 -> unavailable
end,
{V7@Int2,V7@Buf1}
end,

%% attribute speed(9) with type INTEGER
{Term9,Bytes9} = begin
<<V8@V0:13,V8@Buf1/bitstring>> = Bytes8,
{V8@V0,V8@Buf1}
end,

%% attribute heading(10) with type INTEGER
{Term10,Bytes10} = begin
<<V9@V0:15,V9@Buf1/bitstring>> = Bytes9,
{V9@V0,V9@Buf1}
end,

%% attribute angle(11) with type INTEGER
{Term11,Bytes11} = begin
<<V10@V0:8,V10@Buf1/bitstring>> = Bytes10,
V10@Add2 = V10@V0 + -126,
{V10@Add2,V10@Buf1}
end,

%% attribute accelSet(12) with type AccelerationSet4Way
{Term12,Bytes12} = dec_AccelerationSet4Way(Bytes11),

%% attribute brakes(13) with type BrakeSystemStatus
{Term13,Bytes13} = dec_BrakeSystemStatus(Bytes12),

%% attribute size(14) with type VehicleSize
{Term14,Bytes14} = dec_VehicleSize(Bytes13),
Res1 = #{msgCnt=>Term1,id=>Term2,secMark=>Term3,lat=>Term4,long=>Term5,elev=>Term6,accuracy=>Term7,transmission=>Term8,speed=>Term9,heading=>Term10,angle=>Term11,accelSet=>Term12,brakes=>Term13,size=>Term14},
{Res1,Bytes14}.

enc_BumperHeights(Val) ->
#{front:=Input@1,rear:=Input@2} = Val,
[begin
%% attribute front(1) with type INTEGER
if Input@1 bsr 7 =:= 0 ->
<<Input@1:7>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute rear(2) with type INTEGER
if Input@2 bsr 7 =:= 0 ->
<<Input@2:7>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end].


dec_BumperHeights(Bytes) ->

%% attribute front(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:7,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute rear(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:7,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,
Res1 = #{front=>Term1,rear=>Term2},
{Res1,Bytes2}.

enc_Circle(Val) ->
#{center:=Input@1,radius:=Input@2,units:=Input@3} = Val,
[begin
%% attribute center(1) with type Position3D
enc_Position3D(Input@1)
end,
begin
%% attribute radius(2) with type INTEGER
if Input@2 bsr 12 =:= 0 ->
<<Input@2:12>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end|begin
%% attribute units(3) with type ENUMERATED
if Input@3 =:= centimeter ->
<<0:3>>;
Input@3 =:= 'cm2-5' ->
<<1:3>>;
Input@3 =:= decimeter ->
<<2:3>>;
Input@3 =:= meter ->
<<3:3>>;
Input@3 =:= kilometer ->
<<4:3>>;
Input@3 =:= foot ->
<<5:3>>;
Input@3 =:= yard ->
<<6:3>>;
Input@3 =:= mile ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@3}}})
end
end].


dec_Circle(Bytes) ->

%% attribute center(1) with type Position3D
{Term1,Bytes1} = dec_Position3D(Bytes),

%% attribute radius(2) with type INTEGER
{Term2,Bytes2} = begin
<<V1@V0:12,V1@Buf1/bitstring>> = Bytes1,
{V1@V0,V1@Buf1}
end,

%% attribute units(3) with type ENUMERATED
{Term3,Bytes3} = begin
<<V2@V0:3,V2@Buf1/bitstring>> = Bytes2,
V2@Int2 = case V2@V0 of
0 -> centimeter;
1 -> 'cm2-5';
2 -> decimeter;
3 -> meter;
4 -> kilometer;
5 -> foot;
6 -> yard;
7 -> mile
end,
{V2@Int2,V2@Buf1}
end,
Res1 = #{center=>Term1,radius=>Term2,units=>Term3},
{Res1,Bytes3}.

enc_ComputedLane(Val) ->
#{referenceLaneId:=Input@1,offsetXaxis:=Input@2,offsetYaxis:=Input@3} = Val,
Input@4 = case Val of
  #{rotateXY:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{scaleXaxis:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@6 = case Val of
  #{scaleYaxis:=Input@6_0} -> Input@6_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@7 = case Val of
  #{regional:=Input@7_0} -> Input@7_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@4 =:= asn1__MISSING_IN_MAP ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@6 =:= asn1__MISSING_IN_MAP ->
if Input@7 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@7 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
begin
%% attribute referenceLaneId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute offsetXaxis(2) with type CHOICE
enc_ComputedLane_offsetXaxis(Input@2)
end,
begin
%% attribute offsetYaxis(3) with type CHOICE
enc_ComputedLane_offsetYaxis(Input@3)
end,
begin
%% attribute rotateXY(4) with type INTEGER
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@4, Input@4 < 28801 ->
<<Input@4:15>>;
true ->
exit({error,{asn1,{illegal_integer,Input@4}}})
end
end,
begin
%% attribute scaleXaxis(5) with type INTEGER
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Input@5@sub = Input@5 - -2048,
if Input@5@sub bsr 12 =:= 0 ->
<<Input@5@sub:12>>;
true ->
exit({error,{asn1,{illegal_integer,Input@5}}})
end
end
end
end,
begin
%% attribute scaleYaxis(6) with type INTEGER
if Input@6 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Input@6@sub = Input@6 - -2048,
if Input@6@sub bsr 12 =:= 0 ->
<<Input@6@sub:12>>;
true ->
exit({error,{asn1,{illegal_integer,Input@6}}})
end
end
end
end|begin
%% attribute regional(7) with type SEQUENCE OF
if Input@7 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_ComputedLane_regional(Input@7)
end
end].
enc_ComputedLane_offsetXaxis(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= small ->
begin
ChoiceVal@sub = ChoiceVal - -2047,
if 0 =< ChoiceVal@sub, ChoiceVal@sub < 4095 ->
<<0:1,ChoiceVal@sub:12>>;
true ->
exit({error,{asn1,{illegal_integer,ChoiceVal}}})
end
end;
ChoiceTag =:= large ->
begin
ChoiceVal@sub = ChoiceVal - -32767,
if 0 =< ChoiceVal@sub, ChoiceVal@sub < 65535 ->
<<1:1,ChoiceVal@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,ChoiceVal}}})
end
end
end.
enc_ComputedLane_offsetYaxis(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= small ->
begin
ChoiceVal@sub = ChoiceVal - -2047,
if 0 =< ChoiceVal@sub, ChoiceVal@sub < 4095 ->
<<0:1,ChoiceVal@sub:12>>;
true ->
exit({error,{asn1,{illegal_integer,ChoiceVal}}})
end
end;
ChoiceTag =:= large ->
begin
ChoiceVal@sub = ChoiceVal - -32767,
if 0 =< ChoiceVal@sub, ChoiceVal@sub < 65535 ->
<<1:1,ChoiceVal@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,ChoiceVal}}})
end
end
end.
enc_ComputedLane_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_ComputedLane_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_ComputedLane_regional_RegionalExtension(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_ComputedLane(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:4,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute referenceLaneId(1) with type INTEGER
{Term1,Bytes3} = begin
<<V3@V0:8,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute offsetXaxis(2) with type CHOICE
{Term2,Bytes4} = dec_ComputedLane_offsetXaxis(Bytes3),

%% attribute offsetYaxis(3) with type CHOICE
{Term3,Bytes5} = dec_ComputedLane_offsetYaxis(Bytes4),

%% attribute rotateXY(4) with type INTEGER
{Term4,Bytes6} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V4@V0:15,V4@Buf1/bitstring>> = Bytes5,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute scaleXaxis(5) with type INTEGER
{Term5,Bytes7} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V5@V0:12,V5@Buf1/bitstring>> = Bytes6,
V5@Add2 = V5@V0 + -2048,
{V5@Add2,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute scaleYaxis(6) with type INTEGER
{Term6,Bytes8} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V6@V0:12,V6@Buf1/bitstring>> = Bytes7,
V6@Add2 = V6@V0 + -2048,
{V6@Add2,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute regional(7) with type SEQUENCE OF
{Term7,Bytes9} = case Opt band 1 of
1 ->
dec_ComputedLane_regional(Bytes8);
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% Extensions
{Extensions,Bytes10} = case Ext of
0 -> {<<>>,Bytes9};
1 ->
{V7@V0,V7@Buf1} = case Bytes9 of
<<0:1,V7@V3:6,V7@Buf4/bitstring>> ->
V7@Add5 = V7@V3 + 1,
{V7@Add5,V7@Buf4};
<<1:1,V7@Buf2/bitstring>> ->
{V7@V3,V7@Buf4} = case V7@Buf2 of
<<0:1,V7@V6:7,V7@Buf7/bitstring>> when V7@V6 =/= 0 ->
{V7@V6,V7@Buf7};
<<1:1,0:1,V7@V7:14,V7@Buf8/bitstring>> when V7@V7 =/= 0 ->
{V7@V7,V7@Buf8}
end,
{V7@V3,V7@Buf4}
end,
<<V7@V9:V7@V0/bitstring-unit:1,V7@Buf10/bitstring>> = V7@Buf1,
{V7@V9,V7@Buf10}
end,
Bytes11= skipextensions(Bytes10, 1, Extensions),
Res1 = #{referenceLaneId=>Term1,offsetXaxis=>Term2,offsetYaxis=>Term3},
Res2 = case Term4 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{rotateXY=>Term4}
end,
Res3 = case Term5 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{scaleXaxis=>Term5}
end,
Res4 = case Term6 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{scaleYaxis=>Term6}
end,
Res5 = case Term7 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{regional=>Term7}
end,
{Res5,Bytes11}.


dec_ComputedLane_offsetXaxis(Bytes) ->
{Choice,Bytes1} = 
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
begin
<<V2@V0:12,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + -2047,
{V2@Add2,V2@Buf1}
end
end,
{{small,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
begin
<<V3@V0:16,V3@Buf1/bitstring>> = Bytes1,
V3@Add2 = V3@V0 + -32767,
{V3@Add2,V3@Buf1}
end
end,
{{large,Val},NewBytes}
end.

dec_ComputedLane_offsetYaxis(Bytes) ->
{Choice,Bytes1} = 
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
begin
<<V2@V0:12,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + -2047,
{V2@Add2,V2@Buf1}
end
end,
{{small,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
begin
<<V3@V0:16,V3@Buf1/bitstring>> = Bytes1,
V3@Add2 = V3@V0 + -32767,
{V3@Add2,V3@Buf1}
end
end,
{{large,Val},NewBytes}
end.

dec_ComputedLane_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components37(V1@Add2, V1@Buf1, []).


dec_ComputedLane_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_ConfidenceSet(Val) ->
Input@1 = case Val of
  #{accelConfidence:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{speedConfidence:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{timeConfidence:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{posConfidence:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{steerConfidence:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@6 = case Val of
  #{headingConfidence:=Input@6_0} -> Input@6_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@7 = case Val of
  #{throttleConfidence:=Input@7_0} -> Input@7_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@3 =:= asn1__MISSING_IN_MAP ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@5 =:= asn1__MISSING_IN_MAP ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@7 =:= asn1__MISSING_IN_MAP ->
<<0:1>>;
true ->
<<1:1>>
end,
begin
%% attribute accelConfidence(1) with type AccelSteerYawRateConfidence
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_AccelSteerYawRateConfidence(Input@1)
end
end,
begin
%% attribute speedConfidence(2) with type SpeedandHeadingandThrottleConfidence
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_SpeedandHeadingandThrottleConfidence(Input@2)
end
end,
begin
%% attribute timeConfidence(3) with type ENUMERATED
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
Input@3 =:= unavailable ->
<<0:6>>;
Input@3 =:= 'time-100-000' ->
<<1:6>>;
Input@3 =:= 'time-050-000' ->
<<2:6>>;
Input@3 =:= 'time-020-000' ->
<<3:6>>;
Input@3 =:= 'time-010-000' ->
<<4:6>>;
Input@3 =:= 'time-002-000' ->
<<5:6>>;
Input@3 =:= 'time-001-000' ->
<<6:6>>;
Input@3 =:= 'time-000-500' ->
<<7:6>>;
Input@3 =:= 'time-000-200' ->
<<8:6>>;
Input@3 =:= 'time-000-100' ->
<<9:6>>;
Input@3 =:= 'time-000-050' ->
<<10:6>>;
Input@3 =:= 'time-000-020' ->
<<11:6>>;
Input@3 =:= 'time-000-010' ->
<<12:6>>;
Input@3 =:= 'time-000-005' ->
<<13:6>>;
Input@3 =:= 'time-000-002' ->
<<14:6>>;
Input@3 =:= 'time-000-001' ->
<<15:6>>;
Input@3 =:= 'time-000-000-5' ->
<<16:6>>;
Input@3 =:= 'time-000-000-2' ->
<<17:6>>;
Input@3 =:= 'time-000-000-1' ->
<<18:6>>;
Input@3 =:= 'time-000-000-05' ->
<<19:6>>;
Input@3 =:= 'time-000-000-02' ->
<<20:6>>;
Input@3 =:= 'time-000-000-01' ->
<<21:6>>;
Input@3 =:= 'time-000-000-005' ->
<<22:6>>;
Input@3 =:= 'time-000-000-002' ->
<<23:6>>;
Input@3 =:= 'time-000-000-001' ->
<<24:6>>;
Input@3 =:= 'time-000-000-000-5' ->
<<25:6>>;
Input@3 =:= 'time-000-000-000-2' ->
<<26:6>>;
Input@3 =:= 'time-000-000-000-1' ->
<<27:6>>;
Input@3 =:= 'time-000-000-000-05' ->
<<28:6>>;
Input@3 =:= 'time-000-000-000-02' ->
<<29:6>>;
Input@3 =:= 'time-000-000-000-01' ->
<<30:6>>;
Input@3 =:= 'time-000-000-000-005' ->
<<31:6>>;
Input@3 =:= 'time-000-000-000-002' ->
<<32:6>>;
Input@3 =:= 'time-000-000-000-001' ->
<<33:6>>;
Input@3 =:= 'time-000-000-000-000-5' ->
<<34:6>>;
Input@3 =:= 'time-000-000-000-000-2' ->
<<35:6>>;
Input@3 =:= 'time-000-000-000-000-1' ->
<<36:6>>;
Input@3 =:= 'time-000-000-000-000-05' ->
<<37:6>>;
Input@3 =:= 'time-000-000-000-000-02' ->
<<38:6>>;
Input@3 =:= 'time-000-000-000-000-01' ->
<<39:6>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@3}}})
end
end,
begin
%% attribute posConfidence(4) with type PositionConfidenceSet
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_PositionConfidenceSet(Input@4)
end
end,
begin
%% attribute steerConfidence(5) with type ENUMERATED
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
Input@5 =:= unavailable ->
<<0:2>>;
Input@5 =:= prec2deg ->
<<1:2>>;
Input@5 =:= prec1deg ->
<<2:2>>;
Input@5 =:= 'prec0-02deg' ->
<<3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@5}}})
end
end,
begin
%% attribute headingConfidence(6) with type ENUMERATED
if Input@6 =:= asn1__MISSING_IN_MAP ->
[];
Input@6 =:= unavailable ->
<<0:3>>;
Input@6 =:= prec10deg ->
<<1:3>>;
Input@6 =:= prec05deg ->
<<2:3>>;
Input@6 =:= prec01deg ->
<<3:3>>;
Input@6 =:= 'prec0-1deg' ->
<<4:3>>;
Input@6 =:= 'prec0-05deg' ->
<<5:3>>;
Input@6 =:= 'prec0-01deg' ->
<<6:3>>;
Input@6 =:= 'prec0-0125deg' ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@6}}})
end
end|begin
%% attribute throttleConfidence(7) with type ENUMERATED
if Input@7 =:= asn1__MISSING_IN_MAP ->
[];
Input@7 =:= unavailable ->
<<0:2>>;
Input@7 =:= prec10percent ->
<<1:2>>;
Input@7 =:= prec1percent ->
<<2:2>>;
Input@7 =:= 'prec0-5percent' ->
<<3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@7}}})
end
end].


dec_ConfidenceSet(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:7,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute accelConfidence(1) with type AccelSteerYawRateConfidence
{Term1,Bytes3} = case (Opt bsr 6) band 1 of
1 ->
dec_AccelSteerYawRateConfidence(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute speedConfidence(2) with type SpeedandHeadingandThrottleConfidence
{Term2,Bytes4} = case (Opt bsr 5) band 1 of
1 ->
dec_SpeedandHeadingandThrottleConfidence(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute timeConfidence(3) with type ENUMERATED
{Term3,Bytes5} = case (Opt bsr 4) band 1 of
1 ->
begin
<<V3@V0:6,V3@Buf1/bitstring>> = Bytes4,
V3@Int2 = case V3@V0 of
0 -> unavailable;
1 -> 'time-100-000';
2 -> 'time-050-000';
3 -> 'time-020-000';
4 -> 'time-010-000';
5 -> 'time-002-000';
6 -> 'time-001-000';
7 -> 'time-000-500';
8 -> 'time-000-200';
9 -> 'time-000-100';
10 -> 'time-000-050';
11 -> 'time-000-020';
12 -> 'time-000-010';
13 -> 'time-000-005';
14 -> 'time-000-002';
15 -> 'time-000-001';
16 -> 'time-000-000-5';
17 -> 'time-000-000-2';
18 -> 'time-000-000-1';
19 -> 'time-000-000-05';
20 -> 'time-000-000-02';
21 -> 'time-000-000-01';
22 -> 'time-000-000-005';
23 -> 'time-000-000-002';
24 -> 'time-000-000-001';
25 -> 'time-000-000-000-5';
26 -> 'time-000-000-000-2';
27 -> 'time-000-000-000-1';
28 -> 'time-000-000-000-05';
29 -> 'time-000-000-000-02';
30 -> 'time-000-000-000-01';
31 -> 'time-000-000-000-005';
32 -> 'time-000-000-000-002';
33 -> 'time-000-000-000-001';
34 -> 'time-000-000-000-000-5';
35 -> 'time-000-000-000-000-2';
36 -> 'time-000-000-000-000-1';
37 -> 'time-000-000-000-000-05';
38 -> 'time-000-000-000-000-02';
39 -> 'time-000-000-000-000-01';
_ -> exit({error,{asn1,{decode_enumerated,V3@V0}}})
end,
{V3@Int2,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute posConfidence(4) with type PositionConfidenceSet
{Term4,Bytes6} = case (Opt bsr 3) band 1 of
1 ->
dec_PositionConfidenceSet(Bytes5);
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute steerConfidence(5) with type ENUMERATED
{Term5,Bytes7} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V4@V0:2,V4@Buf1/bitstring>> = Bytes6,
V4@Int2 = case V4@V0 of
0 -> unavailable;
1 -> prec2deg;
2 -> prec1deg;
3 -> 'prec0-02deg'
end,
{V4@Int2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute headingConfidence(6) with type ENUMERATED
{Term6,Bytes8} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V5@V0:3,V5@Buf1/bitstring>> = Bytes7,
V5@Int2 = case V5@V0 of
0 -> unavailable;
1 -> prec10deg;
2 -> prec05deg;
3 -> prec01deg;
4 -> 'prec0-1deg';
5 -> 'prec0-05deg';
6 -> 'prec0-01deg';
7 -> 'prec0-0125deg'
end,
{V5@Int2,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute throttleConfidence(7) with type ENUMERATED
{Term7,Bytes9} = case Opt band 1 of
1 ->
begin
<<V6@V0:2,V6@Buf1/bitstring>> = Bytes8,
V6@Int2 = case V6@V0 of
0 -> unavailable;
1 -> prec10percent;
2 -> prec1percent;
3 -> 'prec0-5percent'
end,
{V6@Int2,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% Extensions
{Extensions,Bytes10} = case Ext of
0 -> {<<>>,Bytes9};
1 ->
{V7@V0,V7@Buf1} = case Bytes9 of
<<0:1,V7@V3:6,V7@Buf4/bitstring>> ->
V7@Add5 = V7@V3 + 1,
{V7@Add5,V7@Buf4};
<<1:1,V7@Buf2/bitstring>> ->
{V7@V3,V7@Buf4} = case V7@Buf2 of
<<0:1,V7@V6:7,V7@Buf7/bitstring>> when V7@V6 =/= 0 ->
{V7@V6,V7@Buf7};
<<1:1,0:1,V7@V7:14,V7@Buf8/bitstring>> when V7@V7 =/= 0 ->
{V7@V7,V7@Buf8}
end,
{V7@V3,V7@Buf4}
end,
<<V7@V9:V7@V0/bitstring-unit:1,V7@Buf10/bitstring>> = V7@Buf1,
{V7@V9,V7@Buf10}
end,
Bytes11= skipextensions(Bytes10, 1, Extensions),
Res1 = #{},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{accelConfidence=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{speedConfidence=>Term2}
end,
Res4 = case Term3 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{timeConfidence=>Term3}
end,
Res5 = case Term4 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{posConfidence=>Term4}
end,
Res6 = case Term5 of
  asn1_NOVALUE -> Res5;
  _ -> Res5#{steerConfidence=>Term5}
end,
Res7 = case Term6 of
  asn1_NOVALUE -> Res6;
  _ -> Res6#{headingConfidence=>Term6}
end,
Res8 = case Term7 of
  asn1_NOVALUE -> Res7;
  _ -> Res7#{throttleConfidence=>Term7}
end,
{Res8,Bytes11}.

enc_ConnectingLane(Val) ->
#{lane:=Input@1} = Val,
Input@2 = case Val of
  #{maneuver:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1>>;
true ->
<<1:1>>
end,
begin
%% attribute lane(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute maneuver(2) with type BIT STRING
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Enc2@bs = try bit_string_name2pos_38(Input@2) of
Enc2@positions ->
bitstring_from_positions(Enc2@positions, 12)
catch throw:invalid ->
adjust_trailing_zeroes(Input@2, 12)
end,
Enc2@bits = bit_size(Enc2@bs),
if Enc2@bits =:= 12 ->
Enc2@bs
end
end
end
end].


dec_ConnectingLane(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute lane(1) with type INTEGER
{Term1,Bytes2} = begin
<<V2@V0:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute maneuver(2) with type BIT STRING
{Term2,Bytes3} = case Opt band 1 of
1 ->
begin
<<V3@V0:12/binary-unit:1,V3@Buf1/bitstring>> = Bytes2,
{V3@V2,V3@Buf3}  = {decode_named_bit_string(V3@V0, [{maneuverStraightAllowed,0},{maneuverLeftAllowed,1},{maneuverRightAllowed,2},{maneuverUTurnAllowed,3},{maneuverLeftTurnOnRedAllowed,4},{maneuverRightTurnOnRedAllowed,5},{maneuverLaneChangeAllowed,6},{maneuverNoStoppingAllowed,7},{yieldAllwaysRequired,8},{goWithHalt,9},{caution,10},{reserved1,11}]),V3@Buf1},
{V3@V2,V3@Buf3}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,
Res1 = #{lane=>Term1},
Res2 = case Term2 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{maneuver=>Term2}
end,
{Res2,Bytes3}.

enc_Connection(Val) ->
#{connectingLane:=Input@1} = Val,
Input@2 = case Val of
  #{remoteIntersection:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{signalGroup:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{userClass:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{connectionID:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@2 =:= asn1__MISSING_IN_MAP ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@4 =:= asn1__MISSING_IN_MAP ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
begin
%% attribute connectingLane(1) with type ConnectingLane
enc_ConnectingLane(Input@1)
end,
begin
%% attribute remoteIntersection(2) with type IntersectionReferenceID
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_IntersectionReferenceID(Input@2)
end
end,
begin
%% attribute signalGroup(3) with type INTEGER
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
Input@3 bsr 8 =:= 0 ->
Input@3;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end,
begin
%% attribute userClass(4) with type INTEGER
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
Input@4 bsr 8 =:= 0 ->
Input@4;
true ->
exit({error,{asn1,{illegal_integer,Input@4}}})
end
end|begin
%% attribute connectionID(5) with type INTEGER
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
Input@5 bsr 8 =:= 0 ->
[Input@5];
true ->
exit({error,{asn1,{illegal_integer,Input@5}}})
end
end].


dec_Connection(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute connectingLane(1) with type ConnectingLane
{Term1,Bytes2} = dec_ConnectingLane(Bytes1),

%% attribute remoteIntersection(2) with type IntersectionReferenceID
{Term2,Bytes3} = case (Opt bsr 3) band 1 of
1 ->
dec_IntersectionReferenceID(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute signalGroup(3) with type INTEGER
{Term3,Bytes4} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V2@V0:8,V2@Buf1/bitstring>> = Bytes3,
{V2@V0,V2@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute userClass(4) with type INTEGER
{Term4,Bytes5} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V3@V0:8,V3@Buf1/bitstring>> = Bytes4,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute connectionID(5) with type INTEGER
{Term5,Bytes6} = case Opt band 1 of
1 ->
begin
<<V4@V0:8,V4@Buf1/bitstring>> = Bytes5,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,
Res1 = #{connectingLane=>Term1},
Res2 = case Term2 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{remoteIntersection=>Term2}
end,
Res3 = case Term3 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{signalGroup=>Term3}
end,
Res4 = case Term4 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{userClass=>Term4}
end,
Res5 = case Term5 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{connectionID=>Term5}
end,
{Res5,Bytes6}.

enc_ConnectionManeuverAssist(Val) ->
#{connectionID:=Input@1} = Val,
Input@2 = case Val of
  #{queueLength:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{availableStorageLength:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{waitOnStop:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{pedBicycleDetect:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@6 = case Val of
  #{regional:=Input@6_0} -> Input@6_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@2 =:= asn1__MISSING_IN_MAP ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@4 =:= asn1__MISSING_IN_MAP ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<0:1>>;
true ->
<<1:1>>
end,
begin
%% attribute connectionID(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute queueLength(2) with type INTEGER
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@2, Input@2 < 10001 ->
<<Input@2:14>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end,
begin
%% attribute availableStorageLength(3) with type INTEGER
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@3, Input@3 < 10001 ->
<<Input@3:14>>;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end,
begin
%% attribute waitOnStop(4) with type BOOLEAN
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
Input@4 =:= false ->
<<0:1>>;
Input@4 =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Input@4}}})
end
end,
begin
%% attribute pedBicycleDetect(5) with type BOOLEAN
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
Input@5 =:= false ->
<<0:1>>;
Input@5 =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Input@5}}})
end
end|begin
%% attribute regional(6) with type SEQUENCE OF
if Input@6 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_ConnectionManeuverAssist_regional(Input@6)
end
end].
enc_ConnectionManeuverAssist_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_ConnectionManeuverAssist_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_ConnectionManeuverAssist_regional_RegionalExtension(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type39(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_ConnectionManeuverAssist(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:5,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute connectionID(1) with type INTEGER
{Term1,Bytes3} = begin
<<V3@V0:8,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute queueLength(2) with type INTEGER
{Term2,Bytes4} = case (Opt bsr 4) band 1 of
1 ->
begin
<<V4@V0:14,V4@Buf1/bitstring>> = Bytes3,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute availableStorageLength(3) with type INTEGER
{Term3,Bytes5} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V5@V0:14,V5@Buf1/bitstring>> = Bytes4,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute waitOnStop(4) with type BOOLEAN
{Term4,Bytes6} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V6@V0:1,V6@Buf1/bitstring>> = Bytes5,
V6@Int2 = case V6@V0 of
0 -> false;
1 -> true
end,
{V6@Int2,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute pedBicycleDetect(5) with type BOOLEAN
{Term5,Bytes7} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V7@V0:1,V7@Buf1/bitstring>> = Bytes6,
V7@Int2 = case V7@V0 of
0 -> false;
1 -> true
end,
{V7@Int2,V7@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute regional(6) with type SEQUENCE OF
{Term6,Bytes8} = case Opt band 1 of
1 ->
dec_ConnectionManeuverAssist_regional(Bytes7);
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% Extensions
{Extensions,Bytes9} = case Ext of
0 -> {<<>>,Bytes8};
1 ->
{V8@V0,V8@Buf1} = case Bytes8 of
<<0:1,V8@V3:6,V8@Buf4/bitstring>> ->
V8@Add5 = V8@V3 + 1,
{V8@Add5,V8@Buf4};
<<1:1,V8@Buf2/bitstring>> ->
{V8@V3,V8@Buf4} = case V8@Buf2 of
<<0:1,V8@V6:7,V8@Buf7/bitstring>> when V8@V6 =/= 0 ->
{V8@V6,V8@Buf7};
<<1:1,0:1,V8@V7:14,V8@Buf8/bitstring>> when V8@V7 =/= 0 ->
{V8@V7,V8@Buf8}
end,
{V8@V3,V8@Buf4}
end,
<<V8@V9:V8@V0/bitstring-unit:1,V8@Buf10/bitstring>> = V8@Buf1,
{V8@V9,V8@Buf10}
end,
Bytes10= skipextensions(Bytes9, 1, Extensions),
Res1 = #{connectionID=>Term1},
Res2 = case Term2 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{queueLength=>Term2}
end,
Res3 = case Term3 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{availableStorageLength=>Term3}
end,
Res4 = case Term4 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{waitOnStop=>Term4}
end,
Res5 = case Term5 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{pedBicycleDetect=>Term5}
end,
Res6 = case Term6 of
  asn1_NOVALUE -> Res5;
  _ -> Res5#{regional=>Term6}
end,
{Res6,Bytes10}.


dec_ConnectionManeuverAssist_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components40(V1@Add2, V1@Buf1, []).


dec_ConnectionManeuverAssist_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type41(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_ConnectsToList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 4 =:= 0 ->
[<<Enc1@len@sub:4>>|[enc_Connection(Comp) || Comp <- Val]]
end.



dec_ConnectsToList(Bytes) ->
%% Length with constraint {1,16}
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components42(V1@Add2, V1@Buf1, []).

enc_DataParameters(Val) ->
Input@1 = case Val of
  #{processMethod:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{processAgency:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{lastCheckedDate:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{geoidUsed:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@3 =:= asn1__MISSING_IN_MAP ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
begin
%% attribute processMethod(1) with type IA5String
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Enc2@len = length(Input@1),
Enc2@bin = encode_chars(Input@1, 7),
Enc2@len@sub = Enc2@len - 1,
if 0 =< Enc2@len@sub, Enc2@len@sub < 255 ->
[Enc2@len@sub|Enc2@bin]
end
end
end
end,
begin
%% attribute processAgency(2) with type IA5String
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Enc4@len = length(Input@2),
Enc4@bin = encode_chars(Input@2, 7),
Enc4@len@sub = Enc4@len - 1,
if 0 =< Enc4@len@sub, Enc4@len@sub < 255 ->
[Enc4@len@sub|Enc4@bin]
end
end
end
end,
begin
%% attribute lastCheckedDate(3) with type IA5String
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Enc6@len = length(Input@3),
Enc6@bin = encode_chars(Input@3, 7),
Enc6@len@sub = Enc6@len - 1,
if 0 =< Enc6@len@sub, Enc6@len@sub < 255 ->
[Enc6@len@sub|Enc6@bin]
end
end
end
end|begin
%% attribute geoidUsed(4) with type IA5String
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Enc8@len = length(Input@4),
Enc8@bin = encode_chars(Input@4, 7),
Enc8@len@sub = Enc8@len - 1,
if 0 =< Enc8@len@sub, Enc8@len@sub < 255 ->
[Enc8@len@sub|Enc8@bin]
end
end
end
end].


dec_DataParameters(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:4,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute processMethod(1) with type IA5String
{Term1,Bytes3} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V3@V0:8,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + 1,
<<V3@V3:V3@Add2/binary-unit:7,V3@Buf4/bitstring>> = V3@Buf1,
{V3@V5,V3@Buf6}  = {decode_chars(V3@V3, 7),V3@Buf4},
{V3@V5,V3@Buf6}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute processAgency(2) with type IA5String
{Term2,Bytes4} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V4@V0:8,V4@Buf1/bitstring>> = Bytes3,
V4@Add2 = V4@V0 + 1,
<<V4@V3:V4@Add2/binary-unit:7,V4@Buf4/bitstring>> = V4@Buf1,
{V4@V5,V4@Buf6}  = {decode_chars(V4@V3, 7),V4@Buf4},
{V4@V5,V4@Buf6}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute lastCheckedDate(3) with type IA5String
{Term3,Bytes5} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V5@V0:8,V5@Buf1/bitstring>> = Bytes4,
V5@Add2 = V5@V0 + 1,
<<V5@V3:V5@Add2/binary-unit:7,V5@Buf4/bitstring>> = V5@Buf1,
{V5@V5,V5@Buf6}  = {decode_chars(V5@V3, 7),V5@Buf4},
{V5@V5,V5@Buf6}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute geoidUsed(4) with type IA5String
{Term4,Bytes6} = case Opt band 1 of
1 ->
begin
<<V6@V0:8,V6@Buf1/bitstring>> = Bytes5,
V6@Add2 = V6@V0 + 1,
<<V6@V3:V6@Add2/binary-unit:7,V6@Buf4/bitstring>> = V6@Buf1,
{V6@V5,V6@Buf6}  = {decode_chars(V6@V3, 7),V6@Buf4},
{V6@V5,V6@Buf6}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% Extensions
{Extensions,Bytes7} = case Ext of
0 -> {<<>>,Bytes6};
1 ->
{V7@V0,V7@Buf1} = case Bytes6 of
<<0:1,V7@V3:6,V7@Buf4/bitstring>> ->
V7@Add5 = V7@V3 + 1,
{V7@Add5,V7@Buf4};
<<1:1,V7@Buf2/bitstring>> ->
{V7@V3,V7@Buf4} = case V7@Buf2 of
<<0:1,V7@V6:7,V7@Buf7/bitstring>> when V7@V6 =/= 0 ->
{V7@V6,V7@Buf7};
<<1:1,0:1,V7@V7:14,V7@Buf8/bitstring>> when V7@V7 =/= 0 ->
{V7@V7,V7@Buf8}
end,
{V7@V3,V7@Buf4}
end,
<<V7@V9:V7@V0/bitstring-unit:1,V7@Buf10/bitstring>> = V7@Buf1,
{V7@V9,V7@Buf10}
end,
Bytes8= skipextensions(Bytes7, 1, Extensions),
Res1 = #{},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{processMethod=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{processAgency=>Term2}
end,
Res4 = case Term3 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{lastCheckedDate=>Term3}
end,
Res5 = case Term4 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{geoidUsed=>Term4}
end,
{Res5,Bytes8}.

enc_DDate(Val) ->
#{year:=Input@1,month:=Input@2,day:=Input@3} = Val,
[begin
%% attribute year(1) with type INTEGER
if Input@1 bsr 12 =:= 0 ->
<<Input@1:12>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute month(2) with type INTEGER
if 0 =< Input@2, Input@2 < 13 ->
<<Input@2:4>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end|begin
%% attribute day(3) with type INTEGER
if Input@3 bsr 5 =:= 0 ->
<<Input@3:5>>;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end].


dec_DDate(Bytes) ->

%% attribute year(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:12,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute month(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:4,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute day(3) with type INTEGER
{Term3,Bytes3} = begin
<<V3@V0:5,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,
Res1 = #{year=>Term1,month=>Term2,day=>Term3},
{Res1,Bytes3}.

enc_DDateTime(Val) ->
Input@1 = case Val of
  #{year:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{month:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{day:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{hour:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{minute:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@6 = case Val of
  #{second:=Input@6_0} -> Input@6_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@7 = case Val of
  #{offset:=Input@7_0} -> Input@7_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@3 =:= asn1__MISSING_IN_MAP ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@5 =:= asn1__MISSING_IN_MAP ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@7 =:= asn1__MISSING_IN_MAP ->
<<0:1>>;
true ->
<<1:1>>
end,
begin
%% attribute year(1) with type INTEGER
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
Input@1 bsr 12 =:= 0 ->
<<Input@1:12>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute month(2) with type INTEGER
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@2, Input@2 < 13 ->
<<Input@2:4>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end,
begin
%% attribute day(3) with type INTEGER
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
Input@3 bsr 5 =:= 0 ->
<<Input@3:5>>;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end,
begin
%% attribute hour(4) with type INTEGER
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
Input@4 bsr 5 =:= 0 ->
<<Input@4:5>>;
true ->
exit({error,{asn1,{illegal_integer,Input@4}}})
end
end,
begin
%% attribute minute(5) with type INTEGER
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@5, Input@5 < 61 ->
<<Input@5:6>>;
true ->
exit({error,{asn1,{illegal_integer,Input@5}}})
end
end,
begin
%% attribute second(6) with type INTEGER
if Input@6 =:= asn1__MISSING_IN_MAP ->
[];
Input@6 bsr 16 =:= 0 ->
<<Input@6:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@6}}})
end
end|begin
%% attribute offset(7) with type INTEGER
if Input@7 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Input@7@sub = Input@7 - -840,
if 0 =< Input@7@sub, Input@7@sub < 1681 ->
<<Input@7@sub:11>>;
true ->
exit({error,{asn1,{illegal_integer,Input@7}}})
end
end
end
end].


dec_DDateTime(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:7,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute year(1) with type INTEGER
{Term1,Bytes2} = case (Opt bsr 6) band 1 of
1 ->
begin
<<V2@V0:12,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes1}
end,

%% attribute month(2) with type INTEGER
{Term2,Bytes3} = case (Opt bsr 5) band 1 of
1 ->
begin
<<V3@V0:4,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute day(3) with type INTEGER
{Term3,Bytes4} = case (Opt bsr 4) band 1 of
1 ->
begin
<<V4@V0:5,V4@Buf1/bitstring>> = Bytes3,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute hour(4) with type INTEGER
{Term4,Bytes5} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V5@V0:5,V5@Buf1/bitstring>> = Bytes4,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute minute(5) with type INTEGER
{Term5,Bytes6} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V6@V0:6,V6@Buf1/bitstring>> = Bytes5,
{V6@V0,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute second(6) with type INTEGER
{Term6,Bytes7} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V7@V0:16,V7@Buf1/bitstring>> = Bytes6,
{V7@V0,V7@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute offset(7) with type INTEGER
{Term7,Bytes8} = case Opt band 1 of
1 ->
begin
<<V8@V0:11,V8@Buf1/bitstring>> = Bytes7,
V8@Add2 = V8@V0 + -840,
{V8@Add2,V8@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes7}
end,
Res1 = #{},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{year=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{month=>Term2}
end,
Res4 = case Term3 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{day=>Term3}
end,
Res5 = case Term4 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{hour=>Term4}
end,
Res6 = case Term5 of
  asn1_NOVALUE -> Res5;
  _ -> Res5#{minute=>Term5}
end,
Res7 = case Term6 of
  asn1_NOVALUE -> Res6;
  _ -> Res6#{second=>Term6}
end,
Res8 = case Term7 of
  asn1_NOVALUE -> Res7;
  _ -> Res7#{offset=>Term7}
end,
{Res8,Bytes8}.

enc_DFullTime(Val) ->
#{year:=Input@1,month:=Input@2,day:=Input@3,hour:=Input@4,minute:=Input@5} = Val,
[begin
%% attribute year(1) with type INTEGER
if Input@1 bsr 12 =:= 0 ->
<<Input@1:12>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute month(2) with type INTEGER
if 0 =< Input@2, Input@2 < 13 ->
<<Input@2:4>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end,
begin
%% attribute day(3) with type INTEGER
if Input@3 bsr 5 =:= 0 ->
<<Input@3:5>>;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end,
begin
%% attribute hour(4) with type INTEGER
if Input@4 bsr 5 =:= 0 ->
<<Input@4:5>>;
true ->
exit({error,{asn1,{illegal_integer,Input@4}}})
end
end|begin
%% attribute minute(5) with type INTEGER
if 0 =< Input@5, Input@5 < 61 ->
<<Input@5:6>>;
true ->
exit({error,{asn1,{illegal_integer,Input@5}}})
end
end].


dec_DFullTime(Bytes) ->

%% attribute year(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:12,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute month(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:4,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute day(3) with type INTEGER
{Term3,Bytes3} = begin
<<V3@V0:5,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute hour(4) with type INTEGER
{Term4,Bytes4} = begin
<<V4@V0:5,V4@Buf1/bitstring>> = Bytes3,
{V4@V0,V4@Buf1}
end,

%% attribute minute(5) with type INTEGER
{Term5,Bytes5} = begin
<<V5@V0:6,V5@Buf1/bitstring>> = Bytes4,
{V5@V0,V5@Buf1}
end,
Res1 = #{year=>Term1,month=>Term2,day=>Term3,hour=>Term4,minute=>Term5},
{Res1,Bytes5}.

enc_DMonthDay(Val) ->
#{month:=Input@1,day:=Input@2} = Val,
[begin
%% attribute month(1) with type INTEGER
if 0 =< Input@1, Input@1 < 13 ->
<<Input@1:4>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute day(2) with type INTEGER
if Input@2 bsr 5 =:= 0 ->
<<Input@2:5>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end].


dec_DMonthDay(Bytes) ->

%% attribute month(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute day(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:5,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,
Res1 = #{month=>Term1,day=>Term2},
{Res1,Bytes2}.

enc_DTime(Val) ->
#{hour:=Input@1,minute:=Input@2,second:=Input@3} = Val,
Input@4 = case Val of
  #{offset:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@4 =:= asn1__MISSING_IN_MAP ->
<<0:1>>;
true ->
<<1:1>>
end,
begin
%% attribute hour(1) with type INTEGER
if Input@1 bsr 5 =:= 0 ->
<<Input@1:5>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute minute(2) with type INTEGER
if 0 =< Input@2, Input@2 < 61 ->
<<Input@2:6>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end,
begin
%% attribute second(3) with type INTEGER
if Input@3 bsr 16 =:= 0 ->
<<Input@3:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end|begin
%% attribute offset(4) with type INTEGER
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Input@4@sub = Input@4 - -840,
if 0 =< Input@4@sub, Input@4@sub < 1681 ->
<<Input@4@sub:11>>;
true ->
exit({error,{asn1,{illegal_integer,Input@4}}})
end
end
end
end].


dec_DTime(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute hour(1) with type INTEGER
{Term1,Bytes2} = begin
<<V2@V0:5,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute minute(2) with type INTEGER
{Term2,Bytes3} = begin
<<V3@V0:6,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute second(3) with type INTEGER
{Term3,Bytes4} = begin
<<V4@V0:16,V4@Buf1/bitstring>> = Bytes3,
{V4@V0,V4@Buf1}
end,

%% attribute offset(4) with type INTEGER
{Term4,Bytes5} = case Opt band 1 of
1 ->
begin
<<V5@V0:11,V5@Buf1/bitstring>> = Bytes4,
V5@Add2 = V5@V0 + -840,
{V5@Add2,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,
Res1 = #{hour=>Term1,minute=>Term2,second=>Term3},
Res2 = case Term4 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{offset=>Term4}
end,
{Res2,Bytes5}.

enc_DYearMonth(Val) ->
#{year:=Input@1,month:=Input@2} = Val,
[begin
%% attribute year(1) with type INTEGER
if Input@1 bsr 12 =:= 0 ->
<<Input@1:12>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute month(2) with type INTEGER
if 0 =< Input@2, Input@2 < 13 ->
<<Input@2:4>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end].


dec_DYearMonth(Bytes) ->

%% attribute year(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:12,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute month(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:4,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,
Res1 = #{year=>Term1,month=>Term2},
{Res1,Bytes2}.

enc_DisabledVehicle(Val) ->
#{statusDetails:=Input@1} = Val,
Input@2 = case Val of
  #{locationDetails:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end,
begin
%% attribute statusDetails(1) with type INTEGER
if Input@1 bsr 16 =:= 0 ->
<<Input@1:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute locationDetails(2) with type ENUMERATED
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
Input@2 =:= 'on-bridges' ->
<<0:1,0:7>>;
Input@2 =:= 'in-tunnels' ->
<<0:1,1:7>>;
Input@2 =:= 'entering-or-leaving-tunnels' ->
<<0:1,2:7>>;
Input@2 =:= 'on-ramps' ->
<<0:1,3:7>>;
Input@2 =:= 'in-road-construction-area' ->
<<0:1,4:7>>;
Input@2 =:= 'around-a-curve' ->
<<0:1,5:7>>;
Input@2 =:= 'on-minor-roads' ->
<<0:1,6:7>>;
Input@2 =:= 'in-the-opposing-lanes' ->
<<0:1,7:7>>;
Input@2 =:= 'adjacent-to-roadway' ->
<<0:1,8:7>>;
Input@2 =:= 'on-bend' ->
<<0:1,9:7>>;
Input@2 =:= 'entire-intersection' ->
<<0:1,10:7>>;
Input@2 =:= 'in-the-median' ->
<<0:1,11:7>>;
Input@2 =:= 'moved-to-side-of-road' ->
<<0:1,12:7>>;
Input@2 =:= 'moved-to-shoulder' ->
<<0:1,13:7>>;
Input@2 =:= 'on-the-roadway' ->
<<0:1,14:7>>;
Input@2 =:= 'in-shaded-areas' ->
<<0:1,15:7>>;
Input@2 =:= 'in-low-lying-areas' ->
<<0:1,16:7>>;
Input@2 =:= 'in-the-downtown-area' ->
<<0:1,17:7>>;
Input@2 =:= 'in-the-inner-city-area' ->
<<0:1,18:7>>;
Input@2 =:= 'in-parts' ->
<<0:1,19:7>>;
Input@2 =:= 'in-some-places' ->
<<0:1,20:7>>;
Input@2 =:= 'in-the-ditch' ->
<<0:1,21:7>>;
Input@2 =:= 'in-the-valley' ->
<<0:1,22:7>>;
Input@2 =:= 'on-hill-top' ->
<<0:1,23:7>>;
Input@2 =:= 'near-the-foothills' ->
<<0:1,24:7>>;
Input@2 =:= 'at-high-altitudes' ->
<<0:1,25:7>>;
Input@2 =:= 'near-the-lake' ->
<<0:1,26:7>>;
Input@2 =:= 'near-the-shore' ->
<<0:1,27:7>>;
Input@2 =:= 'over-the-crest-of-a-hill' ->
<<0:1,28:7>>;
Input@2 =:= 'other-than-on-the-roadway' ->
<<0:1,29:7>>;
Input@2 =:= 'near-the-beach' ->
<<0:1,30:7>>;
Input@2 =:= 'near-beach-access-point' ->
<<0:1,31:7>>;
Input@2 =:= 'lower-level' ->
<<0:1,32:7>>;
Input@2 =:= 'upper-level' ->
<<0:1,33:7>>;
Input@2 =:= airport ->
<<0:1,34:7>>;
Input@2 =:= concourse ->
<<0:1,35:7>>;
Input@2 =:= gate ->
<<0:1,36:7>>;
Input@2 =:= 'baggage-claim' ->
<<0:1,37:7>>;
Input@2 =:= 'customs-point' ->
<<0:1,38:7>>;
Input@2 =:= station ->
<<0:1,39:7>>;
Input@2 =:= platform ->
<<0:1,40:7>>;
Input@2 =:= dock ->
<<0:1,41:7>>;
Input@2 =:= depot ->
<<0:1,42:7>>;
Input@2 =:= 'ev-charging-point' ->
<<0:1,43:7>>;
Input@2 =:= 'information-welcome-point' ->
<<0:1,44:7>>;
Input@2 =:= 'at-rest-area' ->
<<0:1,45:7>>;
Input@2 =:= 'at-service-area' ->
<<0:1,46:7>>;
Input@2 =:= 'at-weigh-station' ->
<<0:1,47:7>>;
Input@2 =:= 'picnic-areas' ->
<<0:1,48:7>>;
Input@2 =:= 'rest-area' ->
<<0:1,49:7>>;
Input@2 =:= 'service-stations' ->
<<0:1,50:7>>;
Input@2 =:= toilets ->
<<0:1,51:7>>;
Input@2 =:= 'on-the-right' ->
<<0:1,52:7>>;
Input@2 =:= 'on-the-left' ->
<<0:1,53:7>>;
Input@2 =:= 'in-the-center' ->
<<0:1,54:7>>;
Input@2 =:= 'in-the-opposite-direction' ->
<<0:1,55:7>>;
Input@2 =:= 'cross-traffic' ->
<<0:1,56:7>>;
Input@2 =:= 'northbound-traffic' ->
<<0:1,57:7>>;
Input@2 =:= 'eastbound-traffic' ->
<<0:1,58:7>>;
Input@2 =:= 'southbound-traffic' ->
<<0:1,59:7>>;
Input@2 =:= 'westbound-traffic' ->
<<0:1,60:7>>;
Input@2 =:= north ->
<<0:1,61:7>>;
Input@2 =:= south ->
<<0:1,62:7>>;
Input@2 =:= east ->
<<0:1,63:7>>;
Input@2 =:= west ->
<<0:1,64:7>>;
Input@2 =:= northeast ->
<<0:1,65:7>>;
Input@2 =:= northwest ->
<<0:1,66:7>>;
Input@2 =:= southeast ->
<<0:1,67:7>>;
Input@2 =:= southwest ->
<<0:1,68:7>>;
Input@2 =:= 'mountain-pass' ->
<<0:1,69:7>>;
Input@2 =:= 'reservation-center' ->
<<0:1,70:7>>;
Input@2 =:= 'nearby-basin' ->
<<0:1,71:7>>;
Input@2 =:= 'on-tracks' ->
<<0:1,72:7>>;
Input@2 =:= dip ->
<<0:1,73:7>>;
Input@2 =:= 'traffic-circle' ->
<<0:1,74:7>>;
Input@2 =:= 'park-and-ride-lot' ->
<<0:1,75:7>>;
Input@2 =:= to ->
<<0:1,76:7>>;
Input@2 =:= by ->
<<0:1,77:7>>;
Input@2 =:= through ->
<<0:1,78:7>>;
Input@2 =:= 'area-of' ->
<<0:1,79:7>>;
Input@2 =:= under ->
<<0:1,80:7>>;
Input@2 =:= over ->
<<0:1,81:7>>;
Input@2 =:= from ->
<<0:1,82:7>>;
Input@2 =:= approaching ->
<<0:1,83:7>>;
Input@2 =:= 'entering-at' ->
<<0:1,84:7>>;
Input@2 =:= 'exiting-at' ->
<<0:1,85:7>>;
Input@2 =:= 'across-tracks' ->
<<0:1,86:7>>;
Input@2 =:= 'in-street' ->
<<0:1,87:7>>;
Input@2 =:= 'on-curve' ->
<<0:1,88:7>>;
Input@2 =:= shoulder ->
<<0:1,89:7>>;
Input@2 =:= crossover ->
<<0:1,90:7>>;
Input@2 =:= 'cross-road' ->
<<0:1,91:7>>;
Input@2 =:= 'side-road' ->
<<0:1,92:7>>;
Input@2 =:= 'bus-stop' ->
<<0:1,93:7>>;
Input@2 =:= intersection ->
<<0:1,94:7>>;
Input@2 =:= 'roadside-park' ->
<<0:1,95:7>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@2}}})
end
end].


dec_DisabledVehicle(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:1,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute statusDetails(1) with type INTEGER
{Term1,Bytes3} = begin
<<V3@V0:16,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute locationDetails(2) with type ENUMERATED
{Term2,Bytes4} = case Opt band 1 of
1 ->
begin
{V4@V0,V4@Buf1} = case Bytes3 of
<<0:1,V4@V3:7,V4@Buf4/bitstring>> ->
V4@Int5 = case V4@V3 of
0 -> 'on-bridges';
1 -> 'in-tunnels';
2 -> 'entering-or-leaving-tunnels';
3 -> 'on-ramps';
4 -> 'in-road-construction-area';
5 -> 'around-a-curve';
6 -> 'on-minor-roads';
7 -> 'in-the-opposing-lanes';
8 -> 'adjacent-to-roadway';
9 -> 'on-bend';
10 -> 'entire-intersection';
11 -> 'in-the-median';
12 -> 'moved-to-side-of-road';
13 -> 'moved-to-shoulder';
14 -> 'on-the-roadway';
15 -> 'in-shaded-areas';
16 -> 'in-low-lying-areas';
17 -> 'in-the-downtown-area';
18 -> 'in-the-inner-city-area';
19 -> 'in-parts';
20 -> 'in-some-places';
21 -> 'in-the-ditch';
22 -> 'in-the-valley';
23 -> 'on-hill-top';
24 -> 'near-the-foothills';
25 -> 'at-high-altitudes';
26 -> 'near-the-lake';
27 -> 'near-the-shore';
28 -> 'over-the-crest-of-a-hill';
29 -> 'other-than-on-the-roadway';
30 -> 'near-the-beach';
31 -> 'near-beach-access-point';
32 -> 'lower-level';
33 -> 'upper-level';
34 -> airport;
35 -> concourse;
36 -> gate;
37 -> 'baggage-claim';
38 -> 'customs-point';
39 -> station;
40 -> platform;
41 -> dock;
42 -> depot;
43 -> 'ev-charging-point';
44 -> 'information-welcome-point';
45 -> 'at-rest-area';
46 -> 'at-service-area';
47 -> 'at-weigh-station';
48 -> 'picnic-areas';
49 -> 'rest-area';
50 -> 'service-stations';
51 -> toilets;
52 -> 'on-the-right';
53 -> 'on-the-left';
54 -> 'in-the-center';
55 -> 'in-the-opposite-direction';
56 -> 'cross-traffic';
57 -> 'northbound-traffic';
58 -> 'eastbound-traffic';
59 -> 'southbound-traffic';
60 -> 'westbound-traffic';
61 -> north;
62 -> south;
63 -> east;
64 -> west;
65 -> northeast;
66 -> northwest;
67 -> southeast;
68 -> southwest;
69 -> 'mountain-pass';
70 -> 'reservation-center';
71 -> 'nearby-basin';
72 -> 'on-tracks';
73 -> dip;
74 -> 'traffic-circle';
75 -> 'park-and-ride-lot';
76 -> to;
77 -> by;
78 -> through;
79 -> 'area-of';
80 -> under;
81 -> over;
82 -> from;
83 -> approaching;
84 -> 'entering-at';
85 -> 'exiting-at';
86 -> 'across-tracks';
87 -> 'in-street';
88 -> 'on-curve';
89 -> shoulder;
90 -> crossover;
91 -> 'cross-road';
92 -> 'side-road';
93 -> 'bus-stop';
94 -> intersection;
95 -> 'roadside-park';
_ -> exit({error,{asn1,{decode_enumerated,V4@V3}}})
end,
{V4@Int5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:6,V4@Buf7/bitstring>> ->
{V4@V6,V4@Buf7};
<<1:1,V4@Buf5/bitstring>> ->
{V4@V6,V4@Buf7} = case V4@Buf5 of
<<0:1,V4@V9:7,V4@Buf10/bitstring>> when V4@V9 =/= 0 ->
{V4@V9,V4@Buf10};
<<1:1,0:1,V4@V10:14,V4@Buf11/bitstring>> when V4@V10 =/= 0 ->
{V4@V10,V4@Buf11}
end,
<<V4@V12:V4@V6/unit:8,V4@Buf13/bitstring>> = V4@Buf7,
{V4@V12,V4@Buf13}
end,
V4@Int14 = case V4@V3 of
_ -> {asn1_enum,V4@V3}
end,
{V4@Int14,V4@Buf4}
end,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V5@V0,V5@Buf1} = case Bytes4 of
<<0:1,V5@V3:6,V5@Buf4/bitstring>> ->
V5@Add5 = V5@V3 + 1,
{V5@Add5,V5@Buf4};
<<1:1,V5@Buf2/bitstring>> ->
{V5@V3,V5@Buf4} = case V5@Buf2 of
<<0:1,V5@V6:7,V5@Buf7/bitstring>> when V5@V6 =/= 0 ->
{V5@V6,V5@Buf7};
<<1:1,0:1,V5@V7:14,V5@Buf8/bitstring>> when V5@V7 =/= 0 ->
{V5@V7,V5@Buf8}
end,
{V5@V3,V5@Buf4}
end,
<<V5@V9:V5@V0/bitstring-unit:1,V5@Buf10/bitstring>> = V5@Buf1,
{V5@V9,V5@Buf10}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = #{statusDetails=>Term1},
Res2 = case Term2 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{locationDetails=>Term2}
end,
{Res2,Bytes6}.

enc_EmergencyDetails(Val) ->
#{sspRights:=Input@1,sirenUse:=Input@2,lightsUse:=Input@3,multi:=Input@4} = Val,
Input@5 = case Val of
  #{events:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@6 = case Val of
  #{responseType:=Input@6_0} -> Input@6_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@5 =:= asn1__MISSING_IN_MAP ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
begin
%% attribute sspRights(1) with type INTEGER
if Input@1 bsr 5 =:= 0 ->
<<Input@1:5>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute sirenUse(2) with type ENUMERATED
if Input@2 =:= unavailable ->
<<0:2>>;
Input@2 =:= notInUse ->
<<1:2>>;
Input@2 =:= inUse ->
<<2:2>>;
Input@2 =:= reserved ->
<<3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@2}}})
end
end,
begin
%% attribute lightsUse(3) with type ENUMERATED
if Input@3 =:= unavailable ->
<<0:3>>;
Input@3 =:= notInUse ->
<<1:3>>;
Input@3 =:= inUse ->
<<2:3>>;
Input@3 =:= yellowCautionLights ->
<<3:3>>;
Input@3 =:= schooldBusLights ->
<<4:3>>;
Input@3 =:= arrowSignsActive ->
<<5:3>>;
Input@3 =:= slowMovingVehicle ->
<<6:3>>;
Input@3 =:= freqStops ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@3}}})
end
end,
begin
%% attribute multi(4) with type ENUMERATED
if Input@4 =:= unavailable ->
<<0:2>>;
Input@4 =:= singleVehicle ->
<<1:2>>;
Input@4 =:= multiVehicle ->
<<2:2>>;
Input@4 =:= reserved ->
<<3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@4}}})
end
end,
begin
%% attribute events(5) with type PrivilegedEvents
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_PrivilegedEvents(Input@5)
end
end|begin
%% attribute responseType(6) with type ENUMERATED
if Input@6 =:= asn1__MISSING_IN_MAP ->
[];
Input@6 =:= notInUseOrNotEquipped ->
<<0:1,0:3>>;
Input@6 =:= emergency ->
<<0:1,1:3>>;
Input@6 =:= nonEmergency ->
<<0:1,2:3>>;
Input@6 =:= pursuit ->
<<0:1,3:3>>;
Input@6 =:= stationary ->
<<0:1,4:3>>;
Input@6 =:= slowMoving ->
<<0:1,5:3>>;
Input@6 =:= stopAndGoMovement ->
<<0:1,6:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@6}}})
end
end].


dec_EmergencyDetails(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute sspRights(1) with type INTEGER
{Term1,Bytes3} = begin
<<V3@V0:5,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute sirenUse(2) with type ENUMERATED
{Term2,Bytes4} = begin
<<V4@V0:2,V4@Buf1/bitstring>> = Bytes3,
V4@Int2 = case V4@V0 of
0 -> unavailable;
1 -> notInUse;
2 -> inUse;
3 -> reserved
end,
{V4@Int2,V4@Buf1}
end,

%% attribute lightsUse(3) with type ENUMERATED
{Term3,Bytes5} = begin
<<V5@V0:3,V5@Buf1/bitstring>> = Bytes4,
V5@Int2 = case V5@V0 of
0 -> unavailable;
1 -> notInUse;
2 -> inUse;
3 -> yellowCautionLights;
4 -> schooldBusLights;
5 -> arrowSignsActive;
6 -> slowMovingVehicle;
7 -> freqStops
end,
{V5@Int2,V5@Buf1}
end,

%% attribute multi(4) with type ENUMERATED
{Term4,Bytes6} = begin
<<V6@V0:2,V6@Buf1/bitstring>> = Bytes5,
V6@Int2 = case V6@V0 of
0 -> unavailable;
1 -> singleVehicle;
2 -> multiVehicle;
3 -> reserved
end,
{V6@Int2,V6@Buf1}
end,

%% attribute events(5) with type PrivilegedEvents
{Term5,Bytes7} = case (Opt bsr 1) band 1 of
1 ->
dec_PrivilegedEvents(Bytes6);
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute responseType(6) with type ENUMERATED
{Term6,Bytes8} = case Opt band 1 of
1 ->
begin
{V7@V0,V7@Buf1} = case Bytes7 of
<<0:1,V7@V3:3,V7@Buf4/bitstring>> ->
V7@Int5 = case V7@V3 of
0 -> notInUseOrNotEquipped;
1 -> emergency;
2 -> nonEmergency;
3 -> pursuit;
4 -> stationary;
5 -> slowMoving;
6 -> stopAndGoMovement;
_ -> exit({error,{asn1,{decode_enumerated,V7@V3}}})
end,
{V7@Int5,V7@Buf4};
<<1:1,V7@Buf2/bitstring>> ->
{V7@V3,V7@Buf4} = case V7@Buf2 of
<<0:1,V7@V6:6,V7@Buf7/bitstring>> ->
{V7@V6,V7@Buf7};
<<1:1,V7@Buf5/bitstring>> ->
{V7@V6,V7@Buf7} = case V7@Buf5 of
<<0:1,V7@V9:7,V7@Buf10/bitstring>> when V7@V9 =/= 0 ->
{V7@V9,V7@Buf10};
<<1:1,0:1,V7@V10:14,V7@Buf11/bitstring>> when V7@V10 =/= 0 ->
{V7@V10,V7@Buf11}
end,
<<V7@V12:V7@V6/unit:8,V7@Buf13/bitstring>> = V7@Buf7,
{V7@V12,V7@Buf13}
end,
V7@Int14 = case V7@V3 of
_ -> {asn1_enum,V7@V3}
end,
{V7@Int14,V7@Buf4}
end,
{V7@V0,V7@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% Extensions
{Extensions,Bytes9} = case Ext of
0 -> {<<>>,Bytes8};
1 ->
{V8@V0,V8@Buf1} = case Bytes8 of
<<0:1,V8@V3:6,V8@Buf4/bitstring>> ->
V8@Add5 = V8@V3 + 1,
{V8@Add5,V8@Buf4};
<<1:1,V8@Buf2/bitstring>> ->
{V8@V3,V8@Buf4} = case V8@Buf2 of
<<0:1,V8@V6:7,V8@Buf7/bitstring>> when V8@V6 =/= 0 ->
{V8@V6,V8@Buf7};
<<1:1,0:1,V8@V7:14,V8@Buf8/bitstring>> when V8@V7 =/= 0 ->
{V8@V7,V8@Buf8}
end,
{V8@V3,V8@Buf4}
end,
<<V8@V9:V8@V0/bitstring-unit:1,V8@Buf10/bitstring>> = V8@Buf1,
{V8@V9,V8@Buf10}
end,
Bytes10= skipextensions(Bytes9, 1, Extensions),
Res1 = #{sspRights=>Term1,sirenUse=>Term2,lightsUse=>Term3,multi=>Term4},
Res2 = case Term5 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{events=>Term5}
end,
Res3 = case Term6 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{responseType=>Term6}
end,
{Res3,Bytes10}.

enc_EnabledLaneList(Val) ->
Enc2@len = length(Val),
Enc2@len@sub = Enc2@len - 1,
if Enc2@len@sub bsr 4 =:= 0 ->
[<<Enc2@len@sub:4>>|[if Comp bsr 8 =:= 0 ->
[Comp];
true ->
exit({error,{asn1,{illegal_integer,Comp}}})
end || Comp <- Val]]
end.



dec_EnabledLaneList(Bytes) ->
%% Length with constraint {1,16}
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components43(V1@Add2, V1@Buf1, []).

enc_EventDescription(Val) ->
#{typeEvent:=Input@1} = Val,
Input@2 = case Val of
  #{description:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{priority:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{heading:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{extent:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@6 = case Val of
  #{regional:=Input@6_0} -> Input@6_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@2 =:= asn1__MISSING_IN_MAP ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@4 =:= asn1__MISSING_IN_MAP ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<0:1>>;
true ->
<<1:1>>
end,
begin
%% attribute typeEvent(1) with type INTEGER
if Input@1 bsr 16 =:= 0 ->
<<Input@1:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute description(2) with type SEQUENCE OF
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_EventDescription_description(Input@2)
end
end,
begin
%% attribute priority(3) with type OCTET STRING
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
enc_Binary_Id(Input@3, 1)
end
end
end,
begin
%% attribute heading(4) with type BIT STRING
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Enc6@bs = try bit_string_name2pos_23(Input@4) of
Enc6@positions ->
bitstring_from_positions(Enc6@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(Input@4, 16)
end,
Enc6@bits = bit_size(Enc6@bs),
if Enc6@bits =:= 16 ->
Enc6@bs
end
end
end
end,
begin
%% attribute extent(5) with type ENUMERATED
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
Input@5 =:= useInstantlyOnly ->
<<0:4>>;
Input@5 =:= useFor3meters ->
<<1:4>>;
Input@5 =:= useFor10meters ->
<<2:4>>;
Input@5 =:= useFor50meters ->
<<3:4>>;
Input@5 =:= useFor100meters ->
<<4:4>>;
Input@5 =:= useFor500meters ->
<<5:4>>;
Input@5 =:= useFor1000meters ->
<<6:4>>;
Input@5 =:= useFor5000meters ->
<<7:4>>;
Input@5 =:= useFor10000meters ->
<<8:4>>;
Input@5 =:= useFor50000meters ->
<<9:4>>;
Input@5 =:= useFor100000meters ->
<<10:4>>;
Input@5 =:= useFor500000meters ->
<<11:4>>;
Input@5 =:= useFor1000000meters ->
<<12:4>>;
Input@5 =:= useFor5000000meters ->
<<13:4>>;
Input@5 =:= useFor10000000meters ->
<<14:4>>;
Input@5 =:= forever ->
<<15:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@5}}})
end
end|begin
%% attribute regional(6) with type SEQUENCE OF
if Input@6 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_EventDescription_regional(Input@6)
end
end].
enc_EventDescription_description(Val) ->
Enc2@len = length(Val),
Enc2@len@sub = Enc2@len - 1,
if Enc2@len@sub bsr 3 =:= 0 ->
[<<Enc2@len@sub:3>>|[if Comp bsr 16 =:= 0 ->
<<Comp:16>>;
true ->
exit({error,{asn1,{illegal_integer,Comp}}})
end || Comp <- Val]]
end.

enc_EventDescription_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_EventDescription_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_EventDescription_regional_RegionalExtension(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_EventDescription(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:5,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute typeEvent(1) with type INTEGER
{Term1,Bytes3} = begin
<<V3@V0:16,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute description(2) with type SEQUENCE OF
{Term2,Bytes4} = case (Opt bsr 4) band 1 of
1 ->
dec_EventDescription_description(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute priority(3) with type OCTET STRING
{Term3,Bytes5} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V4@V0:1/binary-unit:8,V4@Buf1/bitstring>> = Bytes4,
V4@Conv2 = binary:copy(V4@V0),
{dec_Binary_Id(V4@Conv2),V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute heading(4) with type BIT STRING
{Term4,Bytes6} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V5@V0:16/binary-unit:1,V5@Buf1/bitstring>> = Bytes5,
{V5@V2,V5@Buf3}  = {decode_named_bit_string(V5@V0, [{'from000-0to022-5degrees',0},{'from022-5to045-0degrees',1},{'from045-0to067-5degrees',2},{'from067-5to090-0degrees',3},{'from090-0to112-5degrees',4},{'from112-5to135-0degrees',5},{'from135-0to157-5degrees',6},{'from157-5to180-0degrees',7},{'from180-0to202-5degrees',8},{'from202-5to225-0degrees',9},{'from225-0to247-5degrees',10},{'from247-5to270-0degrees',11},{'from270-0to292-5degrees',12},{'from292-5to315-0degrees',13},{'from315-0to337-5degrees',14},{'from337-5to360-0degrees',15}]),V5@Buf1},
{V5@V2,V5@Buf3}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute extent(5) with type ENUMERATED
{Term5,Bytes7} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V6@V0:4,V6@Buf1/bitstring>> = Bytes6,
V6@Int2 = case V6@V0 of
0 -> useInstantlyOnly;
1 -> useFor3meters;
2 -> useFor10meters;
3 -> useFor50meters;
4 -> useFor100meters;
5 -> useFor500meters;
6 -> useFor1000meters;
7 -> useFor5000meters;
8 -> useFor10000meters;
9 -> useFor50000meters;
10 -> useFor100000meters;
11 -> useFor500000meters;
12 -> useFor1000000meters;
13 -> useFor5000000meters;
14 -> useFor10000000meters;
15 -> forever
end,
{V6@Int2,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute regional(6) with type SEQUENCE OF
{Term6,Bytes8} = case Opt band 1 of
1 ->
dec_EventDescription_regional(Bytes7);
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% Extensions
{Extensions,Bytes9} = case Ext of
0 -> {<<>>,Bytes8};
1 ->
{V7@V0,V7@Buf1} = case Bytes8 of
<<0:1,V7@V3:6,V7@Buf4/bitstring>> ->
V7@Add5 = V7@V3 + 1,
{V7@Add5,V7@Buf4};
<<1:1,V7@Buf2/bitstring>> ->
{V7@V3,V7@Buf4} = case V7@Buf2 of
<<0:1,V7@V6:7,V7@Buf7/bitstring>> when V7@V6 =/= 0 ->
{V7@V6,V7@Buf7};
<<1:1,0:1,V7@V7:14,V7@Buf8/bitstring>> when V7@V7 =/= 0 ->
{V7@V7,V7@Buf8}
end,
{V7@V3,V7@Buf4}
end,
<<V7@V9:V7@V0/bitstring-unit:1,V7@Buf10/bitstring>> = V7@Buf1,
{V7@V9,V7@Buf10}
end,
Bytes10= skipextensions(Bytes9, 1, Extensions),
Res1 = #{typeEvent=>Term1},
Res2 = case Term2 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{description=>Term2}
end,
Res3 = case Term3 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{priority=>Term3}
end,
Res4 = case Term4 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{heading=>Term4}
end,
Res5 = case Term5 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{extent=>Term5}
end,
Res6 = case Term6 of
  asn1_NOVALUE -> Res5;
  _ -> Res5#{regional=>Term6}
end,
{Res6,Bytes10}.


dec_EventDescription_description(Bytes) ->
%% Length with constraint {1,8}
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components44(V1@Add2, V1@Buf1, []).


dec_EventDescription_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components45(V1@Add2, V1@Buf1, []).


dec_EventDescription_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_FullPositionVector(Val) ->
#{long:=Input@2,lat:=Input@3} = Val,
Input@1 = case Val of
  #{utcTime:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{elevation:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{heading:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@6 = case Val of
  #{speed:=Input@6_0} -> Input@6_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@7 = case Val of
  #{posAccuracy:=Input@7_0} -> Input@7_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@8 = case Val of
  #{timeConfidence:=Input@8_0} -> Input@8_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@9 = case Val of
  #{posConfidence:=Input@9_0} -> Input@9_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@10 = case Val of
  #{speedConfidence:=Input@10_0} -> Input@10_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@5 =:= asn1__MISSING_IN_MAP ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@7 =:= asn1__MISSING_IN_MAP ->
if Input@8 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@8 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@9 =:= asn1__MISSING_IN_MAP ->
if Input@10 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@10 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
begin
%% attribute utcTime(1) with type DDateTime
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_DDateTime(Input@1)
end
end,
begin
%% attribute long(2) with type INTEGER
Input@2@sub = Input@2 - -1799999999,
if 0 =< Input@2@sub, Input@2@sub < 3600000001 ->
<<Input@2@sub:32>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end,
begin
%% attribute lat(3) with type INTEGER
Input@3@sub = Input@3 - -900000000,
if 0 =< Input@3@sub, Input@3@sub < 1800000002 ->
<<Input@3@sub:31>>;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end,
begin
%% attribute elevation(4) with type INTEGER
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Input@4@sub = Input@4 - -4096,
if Input@4@sub bsr 16 =:= 0 ->
<<Input@4@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@4}}})
end
end
end
end,
begin
%% attribute heading(5) with type INTEGER
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@5, Input@5 < 28801 ->
<<Input@5:15>>;
true ->
exit({error,{asn1,{illegal_integer,Input@5}}})
end
end,
begin
%% attribute speed(6) with type TransmissionAndSpeed
if Input@6 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_TransmissionAndSpeed(Input@6)
end
end,
begin
%% attribute posAccuracy(7) with type PositionalAccuracy
if Input@7 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_PositionalAccuracy(Input@7)
end
end,
begin
%% attribute timeConfidence(8) with type ENUMERATED
if Input@8 =:= asn1__MISSING_IN_MAP ->
[];
Input@8 =:= unavailable ->
<<0:6>>;
Input@8 =:= 'time-100-000' ->
<<1:6>>;
Input@8 =:= 'time-050-000' ->
<<2:6>>;
Input@8 =:= 'time-020-000' ->
<<3:6>>;
Input@8 =:= 'time-010-000' ->
<<4:6>>;
Input@8 =:= 'time-002-000' ->
<<5:6>>;
Input@8 =:= 'time-001-000' ->
<<6:6>>;
Input@8 =:= 'time-000-500' ->
<<7:6>>;
Input@8 =:= 'time-000-200' ->
<<8:6>>;
Input@8 =:= 'time-000-100' ->
<<9:6>>;
Input@8 =:= 'time-000-050' ->
<<10:6>>;
Input@8 =:= 'time-000-020' ->
<<11:6>>;
Input@8 =:= 'time-000-010' ->
<<12:6>>;
Input@8 =:= 'time-000-005' ->
<<13:6>>;
Input@8 =:= 'time-000-002' ->
<<14:6>>;
Input@8 =:= 'time-000-001' ->
<<15:6>>;
Input@8 =:= 'time-000-000-5' ->
<<16:6>>;
Input@8 =:= 'time-000-000-2' ->
<<17:6>>;
Input@8 =:= 'time-000-000-1' ->
<<18:6>>;
Input@8 =:= 'time-000-000-05' ->
<<19:6>>;
Input@8 =:= 'time-000-000-02' ->
<<20:6>>;
Input@8 =:= 'time-000-000-01' ->
<<21:6>>;
Input@8 =:= 'time-000-000-005' ->
<<22:6>>;
Input@8 =:= 'time-000-000-002' ->
<<23:6>>;
Input@8 =:= 'time-000-000-001' ->
<<24:6>>;
Input@8 =:= 'time-000-000-000-5' ->
<<25:6>>;
Input@8 =:= 'time-000-000-000-2' ->
<<26:6>>;
Input@8 =:= 'time-000-000-000-1' ->
<<27:6>>;
Input@8 =:= 'time-000-000-000-05' ->
<<28:6>>;
Input@8 =:= 'time-000-000-000-02' ->
<<29:6>>;
Input@8 =:= 'time-000-000-000-01' ->
<<30:6>>;
Input@8 =:= 'time-000-000-000-005' ->
<<31:6>>;
Input@8 =:= 'time-000-000-000-002' ->
<<32:6>>;
Input@8 =:= 'time-000-000-000-001' ->
<<33:6>>;
Input@8 =:= 'time-000-000-000-000-5' ->
<<34:6>>;
Input@8 =:= 'time-000-000-000-000-2' ->
<<35:6>>;
Input@8 =:= 'time-000-000-000-000-1' ->
<<36:6>>;
Input@8 =:= 'time-000-000-000-000-05' ->
<<37:6>>;
Input@8 =:= 'time-000-000-000-000-02' ->
<<38:6>>;
Input@8 =:= 'time-000-000-000-000-01' ->
<<39:6>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@8}}})
end
end,
begin
%% attribute posConfidence(9) with type PositionConfidenceSet
if Input@9 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_PositionConfidenceSet(Input@9)
end
end|begin
%% attribute speedConfidence(10) with type SpeedandHeadingandThrottleConfidence
if Input@10 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_SpeedandHeadingandThrottleConfidence(Input@10)
end
end].


dec_FullPositionVector(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute utcTime(1) with type DDateTime
{Term1,Bytes3} = case (Opt bsr 7) band 1 of
1 ->
dec_DDateTime(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute long(2) with type INTEGER
{Term2,Bytes4} = begin
<<V3@V0:32,V3@Buf1/bitstring>> = Bytes3,
V3@Add2 = V3@V0 + -1799999999,
{V3@Add2,V3@Buf1}
end,

%% attribute lat(3) with type INTEGER
{Term3,Bytes5} = begin
<<V4@V0:31,V4@Buf1/bitstring>> = Bytes4,
V4@Add2 = V4@V0 + -900000000,
{V4@Add2,V4@Buf1}
end,

%% attribute elevation(4) with type INTEGER
{Term4,Bytes6} = case (Opt bsr 6) band 1 of
1 ->
begin
<<V5@V0:16,V5@Buf1/bitstring>> = Bytes5,
V5@Add2 = V5@V0 + -4096,
{V5@Add2,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute heading(5) with type INTEGER
{Term5,Bytes7} = case (Opt bsr 5) band 1 of
1 ->
begin
<<V6@V0:15,V6@Buf1/bitstring>> = Bytes6,
{V6@V0,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute speed(6) with type TransmissionAndSpeed
{Term6,Bytes8} = case (Opt bsr 4) band 1 of
1 ->
dec_TransmissionAndSpeed(Bytes7);
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute posAccuracy(7) with type PositionalAccuracy
{Term7,Bytes9} = case (Opt bsr 3) band 1 of
1 ->
dec_PositionalAccuracy(Bytes8);
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% attribute timeConfidence(8) with type ENUMERATED
{Term8,Bytes10} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V7@V0:6,V7@Buf1/bitstring>> = Bytes9,
V7@Int2 = case V7@V0 of
0 -> unavailable;
1 -> 'time-100-000';
2 -> 'time-050-000';
3 -> 'time-020-000';
4 -> 'time-010-000';
5 -> 'time-002-000';
6 -> 'time-001-000';
7 -> 'time-000-500';
8 -> 'time-000-200';
9 -> 'time-000-100';
10 -> 'time-000-050';
11 -> 'time-000-020';
12 -> 'time-000-010';
13 -> 'time-000-005';
14 -> 'time-000-002';
15 -> 'time-000-001';
16 -> 'time-000-000-5';
17 -> 'time-000-000-2';
18 -> 'time-000-000-1';
19 -> 'time-000-000-05';
20 -> 'time-000-000-02';
21 -> 'time-000-000-01';
22 -> 'time-000-000-005';
23 -> 'time-000-000-002';
24 -> 'time-000-000-001';
25 -> 'time-000-000-000-5';
26 -> 'time-000-000-000-2';
27 -> 'time-000-000-000-1';
28 -> 'time-000-000-000-05';
29 -> 'time-000-000-000-02';
30 -> 'time-000-000-000-01';
31 -> 'time-000-000-000-005';
32 -> 'time-000-000-000-002';
33 -> 'time-000-000-000-001';
34 -> 'time-000-000-000-000-5';
35 -> 'time-000-000-000-000-2';
36 -> 'time-000-000-000-000-1';
37 -> 'time-000-000-000-000-05';
38 -> 'time-000-000-000-000-02';
39 -> 'time-000-000-000-000-01';
_ -> exit({error,{asn1,{decode_enumerated,V7@V0}}})
end,
{V7@Int2,V7@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes9}
end,

%% attribute posConfidence(9) with type PositionConfidenceSet
{Term9,Bytes11} = case (Opt bsr 1) band 1 of
1 ->
dec_PositionConfidenceSet(Bytes10);
0 ->
{asn1_NOVALUE,Bytes10}
end,

%% attribute speedConfidence(10) with type SpeedandHeadingandThrottleConfidence
{Term10,Bytes12} = case Opt band 1 of
1 ->
dec_SpeedandHeadingandThrottleConfidence(Bytes11);
0 ->
{asn1_NOVALUE,Bytes11}
end,

%% Extensions
{Extensions,Bytes13} = case Ext of
0 -> {<<>>,Bytes12};
1 ->
{V8@V0,V8@Buf1} = case Bytes12 of
<<0:1,V8@V3:6,V8@Buf4/bitstring>> ->
V8@Add5 = V8@V3 + 1,
{V8@Add5,V8@Buf4};
<<1:1,V8@Buf2/bitstring>> ->
{V8@V3,V8@Buf4} = case V8@Buf2 of
<<0:1,V8@V6:7,V8@Buf7/bitstring>> when V8@V6 =/= 0 ->
{V8@V6,V8@Buf7};
<<1:1,0:1,V8@V7:14,V8@Buf8/bitstring>> when V8@V7 =/= 0 ->
{V8@V7,V8@Buf8}
end,
{V8@V3,V8@Buf4}
end,
<<V8@V9:V8@V0/bitstring-unit:1,V8@Buf10/bitstring>> = V8@Buf1,
{V8@V9,V8@Buf10}
end,
Bytes14= skipextensions(Bytes13, 1, Extensions),
Res1 = #{long=>Term2,lat=>Term3},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{utcTime=>Term1}
end,
Res3 = case Term4 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{elevation=>Term4}
end,
Res4 = case Term5 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{heading=>Term5}
end,
Res5 = case Term6 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{speed=>Term6}
end,
Res6 = case Term7 of
  asn1_NOVALUE -> Res5;
  _ -> Res5#{posAccuracy=>Term7}
end,
Res7 = case Term8 of
  asn1_NOVALUE -> Res6;
  _ -> Res6#{timeConfidence=>Term8}
end,
Res8 = case Term9 of
  asn1_NOVALUE -> Res7;
  _ -> Res7#{posConfidence=>Term9}
end,
Res9 = case Term10 of
  asn1_NOVALUE -> Res8;
  _ -> Res8#{speedConfidence=>Term10}
end,
{Res9,Bytes14}.

enc_GenericLane(Val) ->
#{laneID:=Input@1,laneAttributes:=Input@5,nodeList:=Input@7} = Val,
Input@2 = case Val of
  #{name:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{ingressApproach:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{egressApproach:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@6 = case Val of
  #{maneuvers:=Input@6_0} -> Input@6_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@8 = case Val of
  #{connectsTo:=Input@8_0} -> Input@8_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@9 = case Val of
  #{overlays:=Input@9_0} -> Input@9_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@10 = case Val of
  #{regional:=Input@10_0} -> Input@10_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@2 =:= asn1__MISSING_IN_MAP ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@4 =:= asn1__MISSING_IN_MAP ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@8 =:= asn1__MISSING_IN_MAP ->
if Input@9 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@9 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@10 =:= asn1__MISSING_IN_MAP ->
<<0:1>>;
true ->
<<1:1>>
end,
begin
%% attribute laneID(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute name(2) with type IA5String
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Enc3@len = length(Input@2),
Enc3@bin = encode_chars(Input@2, 7),
Enc3@len@sub = Enc3@len - 1,
if 0 =< Enc3@len@sub, Enc3@len@sub < 63 ->
[<<Enc3@len@sub:6>>|Enc3@bin]
end
end
end
end,
begin
%% attribute ingressApproach(3) with type INTEGER
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
Input@3 bsr 4 =:= 0 ->
<<Input@3:4>>;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end,
begin
%% attribute egressApproach(4) with type INTEGER
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
Input@4 bsr 4 =:= 0 ->
<<Input@4:4>>;
true ->
exit({error,{asn1,{illegal_integer,Input@4}}})
end
end,
begin
%% attribute laneAttributes(5) with type LaneAttributes
enc_LaneAttributes(Input@5)
end,
begin
%% attribute maneuvers(6) with type BIT STRING
if Input@6 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Enc9@bs = try bit_string_name2pos_38(Input@6) of
Enc9@positions ->
bitstring_from_positions(Enc9@positions, 12)
catch throw:invalid ->
adjust_trailing_zeroes(Input@6, 12)
end,
Enc9@bits = bit_size(Enc9@bs),
if Enc9@bits =:= 12 ->
Enc9@bs
end
end
end
end,
begin
%% attribute nodeList(7) with type NodeListXY
enc_NodeListXY(Input@7)
end,
begin
%% attribute connectsTo(8) with type ConnectsToList
if Input@8 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_ConnectsToList(Input@8)
end
end,
begin
%% attribute overlays(9) with type OverlayLaneList
if Input@9 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_OverlayLaneList(Input@9)
end
end|begin
%% attribute regional(10) with type SEQUENCE OF
if Input@10 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_GenericLane_regional(Input@10)
end
end].
enc_GenericLane_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_GenericLane_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_GenericLane_regional_RegionalExtension(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_GenericLane(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:7,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute laneID(1) with type INTEGER
{Term1,Bytes3} = begin
<<V3@V0:8,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute name(2) with type IA5String
{Term2,Bytes4} = case (Opt bsr 6) band 1 of
1 ->
begin
<<V4@V0:6,V4@Buf1/bitstring>> = Bytes3,
V4@Add2 = V4@V0 + 1,
<<V4@V3:V4@Add2/binary-unit:7,V4@Buf4/bitstring>> = V4@Buf1,
{V4@V5,V4@Buf6}  = {decode_chars(V4@V3, 7),V4@Buf4},
{V4@V5,V4@Buf6}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute ingressApproach(3) with type INTEGER
{Term3,Bytes5} = case (Opt bsr 5) band 1 of
1 ->
begin
<<V5@V0:4,V5@Buf1/bitstring>> = Bytes4,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute egressApproach(4) with type INTEGER
{Term4,Bytes6} = case (Opt bsr 4) band 1 of
1 ->
begin
<<V6@V0:4,V6@Buf1/bitstring>> = Bytes5,
{V6@V0,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute laneAttributes(5) with type LaneAttributes
{Term5,Bytes7} = dec_LaneAttributes(Bytes6),

%% attribute maneuvers(6) with type BIT STRING
{Term6,Bytes8} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V7@V0:12/binary-unit:1,V7@Buf1/bitstring>> = Bytes7,
{V7@V2,V7@Buf3}  = {decode_named_bit_string(V7@V0, [{maneuverStraightAllowed,0},{maneuverLeftAllowed,1},{maneuverRightAllowed,2},{maneuverUTurnAllowed,3},{maneuverLeftTurnOnRedAllowed,4},{maneuverRightTurnOnRedAllowed,5},{maneuverLaneChangeAllowed,6},{maneuverNoStoppingAllowed,7},{yieldAllwaysRequired,8},{goWithHalt,9},{caution,10},{reserved1,11}]),V7@Buf1},
{V7@V2,V7@Buf3}
end;
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute nodeList(7) with type NodeListXY
{Term7,Bytes9} = dec_NodeListXY(Bytes8),

%% attribute connectsTo(8) with type ConnectsToList
{Term8,Bytes10} = case (Opt bsr 2) band 1 of
1 ->
dec_ConnectsToList(Bytes9);
0 ->
{asn1_NOVALUE,Bytes9}
end,

%% attribute overlays(9) with type OverlayLaneList
{Term9,Bytes11} = case (Opt bsr 1) band 1 of
1 ->
dec_OverlayLaneList(Bytes10);
0 ->
{asn1_NOVALUE,Bytes10}
end,

%% attribute regional(10) with type SEQUENCE OF
{Term10,Bytes12} = case Opt band 1 of
1 ->
dec_GenericLane_regional(Bytes11);
0 ->
{asn1_NOVALUE,Bytes11}
end,

%% Extensions
{Extensions,Bytes13} = case Ext of
0 -> {<<>>,Bytes12};
1 ->
{V8@V0,V8@Buf1} = case Bytes12 of
<<0:1,V8@V3:6,V8@Buf4/bitstring>> ->
V8@Add5 = V8@V3 + 1,
{V8@Add5,V8@Buf4};
<<1:1,V8@Buf2/bitstring>> ->
{V8@V3,V8@Buf4} = case V8@Buf2 of
<<0:1,V8@V6:7,V8@Buf7/bitstring>> when V8@V6 =/= 0 ->
{V8@V6,V8@Buf7};
<<1:1,0:1,V8@V7:14,V8@Buf8/bitstring>> when V8@V7 =/= 0 ->
{V8@V7,V8@Buf8}
end,
{V8@V3,V8@Buf4}
end,
<<V8@V9:V8@V0/bitstring-unit:1,V8@Buf10/bitstring>> = V8@Buf1,
{V8@V9,V8@Buf10}
end,
Bytes14= skipextensions(Bytes13, 1, Extensions),
Res1 = #{laneID=>Term1,laneAttributes=>Term5,nodeList=>Term7},
Res2 = case Term2 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{name=>Term2}
end,
Res3 = case Term3 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{ingressApproach=>Term3}
end,
Res4 = case Term4 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{egressApproach=>Term4}
end,
Res5 = case Term6 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{maneuvers=>Term6}
end,
Res6 = case Term8 of
  asn1_NOVALUE -> Res5;
  _ -> Res5#{connectsTo=>Term8}
end,
Res7 = case Term9 of
  asn1_NOVALUE -> Res6;
  _ -> Res6#{overlays=>Term9}
end,
Res8 = case Term10 of
  asn1_NOVALUE -> Res7;
  _ -> Res7#{regional=>Term10}
end,
{Res8,Bytes14}.


dec_GenericLane_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components46(V1@Add2, V1@Buf1, []).


dec_GenericLane_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_GeographicalPath(Val) ->
Input@1 = case Val of
  #{name:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{id:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{anchor:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{laneWidth:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{directionality:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@6 = case Val of
  #{closedPath:=Input@6_0} -> Input@6_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@7 = case Val of
  #{direction:=Input@7_0} -> Input@7_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@8 = case Val of
  #{description:=Input@8_0} -> Input@8_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@9 = case Val of
  #{regional:=Input@9_0} -> Input@9_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@3 =:= asn1__MISSING_IN_MAP ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@5 =:= asn1__MISSING_IN_MAP ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@7 =:= asn1__MISSING_IN_MAP ->
if Input@8 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@8 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@9 =:= asn1__MISSING_IN_MAP ->
<<0:1>>;
true ->
<<1:1>>
end,
begin
%% attribute name(1) with type IA5String
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Enc2@len = length(Input@1),
Enc2@bin = encode_chars(Input@1, 7),
Enc2@len@sub = Enc2@len - 1,
if 0 =< Enc2@len@sub, Enc2@len@sub < 63 ->
[<<Enc2@len@sub:6>>|Enc2@bin]
end
end
end
end,
begin
%% attribute id(2) with type RoadSegmentReferenceID
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_RoadSegmentReferenceID(Input@2)
end
end,
begin
%% attribute anchor(3) with type Position3D
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_Position3D(Input@3)
end
end,
begin
%% attribute laneWidth(4) with type INTEGER
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
Input@4 bsr 15 =:= 0 ->
<<Input@4:15>>;
true ->
exit({error,{asn1,{illegal_integer,Input@4}}})
end
end,
begin
%% attribute directionality(5) with type ENUMERATED
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
Input@5 =:= unavailable ->
<<0:2>>;
Input@5 =:= forward ->
<<1:2>>;
Input@5 =:= reverse ->
<<2:2>>;
Input@5 =:= both ->
<<3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@5}}})
end
end,
begin
%% attribute closedPath(6) with type BOOLEAN
if Input@6 =:= asn1__MISSING_IN_MAP ->
[];
Input@6 =:= false ->
<<0:1>>;
Input@6 =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Input@6}}})
end
end,
begin
%% attribute direction(7) with type BIT STRING
if Input@7 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Enc12@bs = try bit_string_name2pos_23(Input@7) of
Enc12@positions ->
bitstring_from_positions(Enc12@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(Input@7, 16)
end,
Enc12@bits = bit_size(Enc12@bs),
if Enc12@bits =:= 16 ->
Enc12@bs
end
end
end
end,
begin
%% attribute description(8) with type CHOICE
if Input@8 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_GeographicalPath_description(Input@8)
end
end|begin
%% attribute regional(9) with type SEQUENCE OF
if Input@9 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_GeographicalPath_regional(Input@9)
end
end].
enc_GeographicalPath_description(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= path ->
[<<0:1,0:2>>|enc_OffsetSystem(ChoiceVal)];
ChoiceTag =:= geometry ->
[<<0:1,1:2>>|enc_GeometricProjection(ChoiceVal)];
ChoiceTag =:= oldRegion ->
[<<0:1,2:2>>|enc_ValidRegion(ChoiceVal)]
end.
enc_GeographicalPath_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_GeographicalPath_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_GeographicalPath_regional_RegionalExtension(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_GeographicalPath(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:9,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute name(1) with type IA5String
{Term1,Bytes3} = case (Opt bsr 8) band 1 of
1 ->
begin
<<V3@V0:6,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + 1,
<<V3@V3:V3@Add2/binary-unit:7,V3@Buf4/bitstring>> = V3@Buf1,
{V3@V5,V3@Buf6}  = {decode_chars(V3@V3, 7),V3@Buf4},
{V3@V5,V3@Buf6}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute id(2) with type RoadSegmentReferenceID
{Term2,Bytes4} = case (Opt bsr 7) band 1 of
1 ->
dec_RoadSegmentReferenceID(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute anchor(3) with type Position3D
{Term3,Bytes5} = case (Opt bsr 6) band 1 of
1 ->
dec_Position3D(Bytes4);
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute laneWidth(4) with type INTEGER
{Term4,Bytes6} = case (Opt bsr 5) band 1 of
1 ->
begin
<<V4@V0:15,V4@Buf1/bitstring>> = Bytes5,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute directionality(5) with type ENUMERATED
{Term5,Bytes7} = case (Opt bsr 4) band 1 of
1 ->
begin
<<V5@V0:2,V5@Buf1/bitstring>> = Bytes6,
V5@Int2 = case V5@V0 of
0 -> unavailable;
1 -> forward;
2 -> reverse;
3 -> both
end,
{V5@Int2,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute closedPath(6) with type BOOLEAN
{Term6,Bytes8} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V6@V0:1,V6@Buf1/bitstring>> = Bytes7,
V6@Int2 = case V6@V0 of
0 -> false;
1 -> true
end,
{V6@Int2,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute direction(7) with type BIT STRING
{Term7,Bytes9} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V7@V0:16/binary-unit:1,V7@Buf1/bitstring>> = Bytes8,
{V7@V2,V7@Buf3}  = {decode_named_bit_string(V7@V0, [{'from000-0to022-5degrees',0},{'from022-5to045-0degrees',1},{'from045-0to067-5degrees',2},{'from067-5to090-0degrees',3},{'from090-0to112-5degrees',4},{'from112-5to135-0degrees',5},{'from135-0to157-5degrees',6},{'from157-5to180-0degrees',7},{'from180-0to202-5degrees',8},{'from202-5to225-0degrees',9},{'from225-0to247-5degrees',10},{'from247-5to270-0degrees',11},{'from270-0to292-5degrees',12},{'from292-5to315-0degrees',13},{'from315-0to337-5degrees',14},{'from337-5to360-0degrees',15}]),V7@Buf1},
{V7@V2,V7@Buf3}
end;
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% attribute description(8) with type CHOICE
{Term8,Bytes10} = case (Opt bsr 1) band 1 of
1 ->
dec_GeographicalPath_description(Bytes9);
0 ->
{asn1_NOVALUE,Bytes9}
end,

%% attribute regional(9) with type SEQUENCE OF
{Term9,Bytes11} = case Opt band 1 of
1 ->
dec_GeographicalPath_regional(Bytes10);
0 ->
{asn1_NOVALUE,Bytes10}
end,

%% Extensions
{Extensions,Bytes12} = case Ext of
0 -> {<<>>,Bytes11};
1 ->
{V8@V0,V8@Buf1} = case Bytes11 of
<<0:1,V8@V3:6,V8@Buf4/bitstring>> ->
V8@Add5 = V8@V3 + 1,
{V8@Add5,V8@Buf4};
<<1:1,V8@Buf2/bitstring>> ->
{V8@V3,V8@Buf4} = case V8@Buf2 of
<<0:1,V8@V6:7,V8@Buf7/bitstring>> when V8@V6 =/= 0 ->
{V8@V6,V8@Buf7};
<<1:1,0:1,V8@V7:14,V8@Buf8/bitstring>> when V8@V7 =/= 0 ->
{V8@V7,V8@Buf8}
end,
{V8@V3,V8@Buf4}
end,
<<V8@V9:V8@V0/bitstring-unit:1,V8@Buf10/bitstring>> = V8@Buf1,
{V8@V9,V8@Buf10}
end,
Bytes13= skipextensions(Bytes12, 1, Extensions),
Res1 = #{},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{name=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{id=>Term2}
end,
Res4 = case Term3 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{anchor=>Term3}
end,
Res5 = case Term4 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{laneWidth=>Term4}
end,
Res6 = case Term5 of
  asn1_NOVALUE -> Res5;
  _ -> Res5#{directionality=>Term5}
end,
Res7 = case Term6 of
  asn1_NOVALUE -> Res6;
  _ -> Res6#{closedPath=>Term6}
end,
Res8 = case Term7 of
  asn1_NOVALUE -> Res7;
  _ -> Res7#{direction=>Term7}
end,
Res9 = case Term8 of
  asn1_NOVALUE -> Res8;
  _ -> Res8#{description=>Term8}
end,
Res10 = case Term9 of
  asn1_NOVALUE -> Res9;
  _ -> Res9#{regional=>Term9}
end,
{Res10,Bytes13}.


dec_GeographicalPath_description(Bytes) ->
case Bytes of
<<0:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes1,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
dec_OffsetSystem(Bytes2)
end,
{{path,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
dec_GeometricProjection(Bytes2)
end,
{{geometry,Val},NewBytes};
2 ->
{Val,NewBytes} = begin
dec_ValidRegion(Bytes2)
end,
{{oldRegion,Val},NewBytes}
end;

<<1:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
{V1@V0,V1@Buf1} = case Bytes1 of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> when V1@V6 =/= 0 ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
{V1@V7,V1@Buf8}
end,
<<V1@V9:V1@V3/unit:8,V1@Buf10/bitstring>> = V1@Buf4,
{V1@V9,V1@Buf10}
end,
{V1@V0,V1@Buf1}
end,
begin
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end
end,
case Choice of
_ ->
{{asn1_ExtAlt,V2@V0},V2@Buf1}
end
end.

dec_GeographicalPath_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components47(V1@Add2, V1@Buf1, []).


dec_GeographicalPath_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_GeometricProjection(Val) ->
#{direction:=Input@1,circle:=Input@4} = Val,
Input@2 = case Val of
  #{extent:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{laneWidth:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{regional:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@2 =:= asn1__MISSING_IN_MAP ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<0:1>>;
true ->
<<1:1>>
end,
begin
%% attribute direction(1) with type BIT STRING
Enc2@bs = try bit_string_name2pos_23(Input@1) of
Enc2@positions ->
bitstring_from_positions(Enc2@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(Input@1, 16)
end,
Enc2@bits = bit_size(Enc2@bs),
if Enc2@bits =:= 16 ->
Enc2@bs
end
end,
begin
%% attribute extent(2) with type ENUMERATED
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
Input@2 =:= useInstantlyOnly ->
<<0:4>>;
Input@2 =:= useFor3meters ->
<<1:4>>;
Input@2 =:= useFor10meters ->
<<2:4>>;
Input@2 =:= useFor50meters ->
<<3:4>>;
Input@2 =:= useFor100meters ->
<<4:4>>;
Input@2 =:= useFor500meters ->
<<5:4>>;
Input@2 =:= useFor1000meters ->
<<6:4>>;
Input@2 =:= useFor5000meters ->
<<7:4>>;
Input@2 =:= useFor10000meters ->
<<8:4>>;
Input@2 =:= useFor50000meters ->
<<9:4>>;
Input@2 =:= useFor100000meters ->
<<10:4>>;
Input@2 =:= useFor500000meters ->
<<11:4>>;
Input@2 =:= useFor1000000meters ->
<<12:4>>;
Input@2 =:= useFor5000000meters ->
<<13:4>>;
Input@2 =:= useFor10000000meters ->
<<14:4>>;
Input@2 =:= forever ->
<<15:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@2}}})
end
end,
begin
%% attribute laneWidth(3) with type INTEGER
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
Input@3 bsr 15 =:= 0 ->
<<Input@3:15>>;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end,
begin
%% attribute circle(4) with type Circle
enc_Circle(Input@4)
end|begin
%% attribute regional(5) with type SEQUENCE OF
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_GeometricProjection_regional(Input@5)
end
end].
enc_GeometricProjection_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_GeometricProjection_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_GeometricProjection_regional_RegionalExtension(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_GeometricProjection(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:3,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute direction(1) with type BIT STRING
{Term1,Bytes3} = begin
<<V3@V0:16/binary-unit:1,V3@Buf1/bitstring>> = Bytes2,
{V3@V2,V3@Buf3}  = {decode_named_bit_string(V3@V0, [{'from000-0to022-5degrees',0},{'from022-5to045-0degrees',1},{'from045-0to067-5degrees',2},{'from067-5to090-0degrees',3},{'from090-0to112-5degrees',4},{'from112-5to135-0degrees',5},{'from135-0to157-5degrees',6},{'from157-5to180-0degrees',7},{'from180-0to202-5degrees',8},{'from202-5to225-0degrees',9},{'from225-0to247-5degrees',10},{'from247-5to270-0degrees',11},{'from270-0to292-5degrees',12},{'from292-5to315-0degrees',13},{'from315-0to337-5degrees',14},{'from337-5to360-0degrees',15}]),V3@Buf1},
{V3@V2,V3@Buf3}
end,

%% attribute extent(2) with type ENUMERATED
{Term2,Bytes4} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V4@V0:4,V4@Buf1/bitstring>> = Bytes3,
V4@Int2 = case V4@V0 of
0 -> useInstantlyOnly;
1 -> useFor3meters;
2 -> useFor10meters;
3 -> useFor50meters;
4 -> useFor100meters;
5 -> useFor500meters;
6 -> useFor1000meters;
7 -> useFor5000meters;
8 -> useFor10000meters;
9 -> useFor50000meters;
10 -> useFor100000meters;
11 -> useFor500000meters;
12 -> useFor1000000meters;
13 -> useFor5000000meters;
14 -> useFor10000000meters;
15 -> forever
end,
{V4@Int2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute laneWidth(3) with type INTEGER
{Term3,Bytes5} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V5@V0:15,V5@Buf1/bitstring>> = Bytes4,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute circle(4) with type Circle
{Term4,Bytes6} = dec_Circle(Bytes5),

%% attribute regional(5) with type SEQUENCE OF
{Term5,Bytes7} = case Opt band 1 of
1 ->
dec_GeometricProjection_regional(Bytes6);
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% Extensions
{Extensions,Bytes8} = case Ext of
0 -> {<<>>,Bytes7};
1 ->
{V6@V0,V6@Buf1} = case Bytes7 of
<<0:1,V6@V3:6,V6@Buf4/bitstring>> ->
V6@Add5 = V6@V3 + 1,
{V6@Add5,V6@Buf4};
<<1:1,V6@Buf2/bitstring>> ->
{V6@V3,V6@Buf4} = case V6@Buf2 of
<<0:1,V6@V6:7,V6@Buf7/bitstring>> when V6@V6 =/= 0 ->
{V6@V6,V6@Buf7};
<<1:1,0:1,V6@V7:14,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
{V6@V7,V6@Buf8}
end,
{V6@V3,V6@Buf4}
end,
<<V6@V9:V6@V0/bitstring-unit:1,V6@Buf10/bitstring>> = V6@Buf1,
{V6@V9,V6@Buf10}
end,
Bytes9= skipextensions(Bytes8, 1, Extensions),
Res1 = #{direction=>Term1,circle=>Term4},
Res2 = case Term2 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{extent=>Term2}
end,
Res3 = case Term3 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{laneWidth=>Term3}
end,
Res4 = case Term5 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{regional=>Term5}
end,
{Res4,Bytes9}.


dec_GeometricProjection_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components48(V1@Add2, V1@Buf1, []).


dec_GeometricProjection_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_Header(Val) ->
Input@1 = case Val of
  #{year:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{timeStamp:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{secMark:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{msgIssueRevision:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@3 =:= asn1__MISSING_IN_MAP ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
begin
%% attribute year(1) with type INTEGER
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
Input@1 bsr 12 =:= 0 ->
<<Input@1:12>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute timeStamp(2) with type INTEGER
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@2, Input@2 < 527041 ->
<<Input@2:20>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end,
begin
%% attribute secMark(3) with type INTEGER
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
Input@3 bsr 16 =:= 0 ->
<<Input@3:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end|begin
%% attribute msgIssueRevision(4) with type INTEGER
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
Input@4 bsr 7 =:= 0 ->
<<Input@4:7>>;
true ->
exit({error,{asn1,{illegal_integer,Input@4}}})
end
end].


dec_Header(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:4,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute year(1) with type INTEGER
{Term1,Bytes3} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V3@V0:12,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute timeStamp(2) with type INTEGER
{Term2,Bytes4} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V4@V0:20,V4@Buf1/bitstring>> = Bytes3,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute secMark(3) with type INTEGER
{Term3,Bytes5} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V5@V0:16,V5@Buf1/bitstring>> = Bytes4,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute msgIssueRevision(4) with type INTEGER
{Term4,Bytes6} = case Opt band 1 of
1 ->
begin
<<V6@V0:7,V6@Buf1/bitstring>> = Bytes5,
{V6@V0,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% Extensions
{Extensions,Bytes7} = case Ext of
0 -> {<<>>,Bytes6};
1 ->
{V7@V0,V7@Buf1} = case Bytes6 of
<<0:1,V7@V3:6,V7@Buf4/bitstring>> ->
V7@Add5 = V7@V3 + 1,
{V7@Add5,V7@Buf4};
<<1:1,V7@Buf2/bitstring>> ->
{V7@V3,V7@Buf4} = case V7@Buf2 of
<<0:1,V7@V6:7,V7@Buf7/bitstring>> when V7@V6 =/= 0 ->
{V7@V6,V7@Buf7};
<<1:1,0:1,V7@V7:14,V7@Buf8/bitstring>> when V7@V7 =/= 0 ->
{V7@V7,V7@Buf8}
end,
{V7@V3,V7@Buf4}
end,
<<V7@V9:V7@V0/bitstring-unit:1,V7@Buf10/bitstring>> = V7@Buf1,
{V7@V9,V7@Buf10}
end,
Bytes8= skipextensions(Bytes7, 1, Extensions),
Res1 = #{},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{year=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{timeStamp=>Term2}
end,
Res4 = case Term3 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{secMark=>Term3}
end,
Res5 = case Term4 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{msgIssueRevision=>Term4}
end,
{Res5,Bytes8}.

enc_IntersectionAccessPoint(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= lane ->
if ChoiceVal bsr 8 =:= 0 ->
[<<0:1,0:2,ChoiceVal:8>>];
true ->
exit({error,{asn1,{illegal_integer,ChoiceVal}}})
end;
ChoiceTag =:= approach ->
if ChoiceVal bsr 4 =:= 0 ->
<<0:1,1:2,ChoiceVal:4>>;
true ->
exit({error,{asn1,{illegal_integer,ChoiceVal}}})
end;
ChoiceTag =:= connection ->
if ChoiceVal bsr 8 =:= 0 ->
[<<0:1,2:2,ChoiceVal:8>>];
true ->
exit({error,{asn1,{illegal_integer,ChoiceVal}}})
end
end.


dec_IntersectionAccessPoint(Bytes) ->
case Bytes of
<<0:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes1,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
begin
<<V2@V0:8,V2@Buf1/bitstring>> = Bytes2,
{V2@V0,V2@Buf1}
end
end,
{{lane,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
begin
<<V3@V0:4,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end
end,
{{approach,Val},NewBytes};
2 ->
{Val,NewBytes} = begin
begin
<<V4@V0:8,V4@Buf1/bitstring>> = Bytes2,
{V4@V0,V4@Buf1}
end
end,
{{connection,Val},NewBytes}
end;

<<1:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
{V1@V0,V1@Buf1} = case Bytes1 of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> when V1@V6 =/= 0 ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
{V1@V7,V1@Buf8}
end,
<<V1@V9:V1@V3/unit:8,V1@Buf10/bitstring>> = V1@Buf4,
{V1@V9,V1@Buf10}
end,
{V1@V0,V1@Buf1}
end,
begin
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end
end,
case Choice of
_ ->
{{asn1_ExtAlt,V2@V0},V2@Buf1}
end
end.
enc_IntersectionGeometry(Val) ->
#{id:=Input@2,revision:=Input@3,refPoint:=Input@4,laneSet:=Input@7} = Val,
Input@1 = case Val of
  #{name:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{laneWidth:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@6 = case Val of
  #{speedLimits:=Input@6_0} -> Input@6_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@8 = case Val of
  #{preemptPriorityData:=Input@8_0} -> Input@8_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@9 = case Val of
  #{regional:=Input@9_0} -> Input@9_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@6 =:= asn1__MISSING_IN_MAP ->
if Input@8 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@8 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@9 =:= asn1__MISSING_IN_MAP ->
<<0:1>>;
true ->
<<1:1>>
end,
begin
%% attribute name(1) with type IA5String
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Enc2@len = length(Input@1),
Enc2@bin = encode_chars(Input@1, 7),
Enc2@len@sub = Enc2@len - 1,
if 0 =< Enc2@len@sub, Enc2@len@sub < 63 ->
[<<Enc2@len@sub:6>>|Enc2@bin]
end
end
end
end,
begin
%% attribute id(2) with type IntersectionReferenceID
enc_IntersectionReferenceID(Input@2)
end,
begin
%% attribute revision(3) with type INTEGER
if Input@3 bsr 7 =:= 0 ->
<<Input@3:7>>;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end,
begin
%% attribute refPoint(4) with type Position3D
enc_Position3D(Input@4)
end,
begin
%% attribute laneWidth(5) with type INTEGER
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
Input@5 bsr 15 =:= 0 ->
<<Input@5:15>>;
true ->
exit({error,{asn1,{illegal_integer,Input@5}}})
end
end,
begin
%% attribute speedLimits(6) with type SpeedLimitList
if Input@6 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_SpeedLimitList(Input@6)
end
end,
begin
%% attribute laneSet(7) with type LaneList
enc_LaneList(Input@7)
end,
begin
%% attribute preemptPriorityData(8) with type PreemptPriorityList
if Input@8 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_PreemptPriorityList(Input@8)
end
end|begin
%% attribute regional(9) with type SEQUENCE OF
if Input@9 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_IntersectionGeometry_regional(Input@9)
end
end].
enc_IntersectionGeometry_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_IntersectionGeometry_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_IntersectionGeometry_regional_RegionalExtension(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_IntersectionGeometry(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:5,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute name(1) with type IA5String
{Term1,Bytes3} = case (Opt bsr 4) band 1 of
1 ->
begin
<<V3@V0:6,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + 1,
<<V3@V3:V3@Add2/binary-unit:7,V3@Buf4/bitstring>> = V3@Buf1,
{V3@V5,V3@Buf6}  = {decode_chars(V3@V3, 7),V3@Buf4},
{V3@V5,V3@Buf6}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute id(2) with type IntersectionReferenceID
{Term2,Bytes4} = dec_IntersectionReferenceID(Bytes3),

%% attribute revision(3) with type INTEGER
{Term3,Bytes5} = begin
<<V4@V0:7,V4@Buf1/bitstring>> = Bytes4,
{V4@V0,V4@Buf1}
end,

%% attribute refPoint(4) with type Position3D
{Term4,Bytes6} = dec_Position3D(Bytes5),

%% attribute laneWidth(5) with type INTEGER
{Term5,Bytes7} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V5@V0:15,V5@Buf1/bitstring>> = Bytes6,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute speedLimits(6) with type SpeedLimitList
{Term6,Bytes8} = case (Opt bsr 2) band 1 of
1 ->
dec_SpeedLimitList(Bytes7);
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute laneSet(7) with type LaneList
{Term7,Bytes9} = dec_LaneList(Bytes8),

%% attribute preemptPriorityData(8) with type PreemptPriorityList
{Term8,Bytes10} = case (Opt bsr 1) band 1 of
1 ->
dec_PreemptPriorityList(Bytes9);
0 ->
{asn1_NOVALUE,Bytes9}
end,

%% attribute regional(9) with type SEQUENCE OF
{Term9,Bytes11} = case Opt band 1 of
1 ->
dec_IntersectionGeometry_regional(Bytes10);
0 ->
{asn1_NOVALUE,Bytes10}
end,

%% Extensions
{Extensions,Bytes12} = case Ext of
0 -> {<<>>,Bytes11};
1 ->
{V6@V0,V6@Buf1} = case Bytes11 of
<<0:1,V6@V3:6,V6@Buf4/bitstring>> ->
V6@Add5 = V6@V3 + 1,
{V6@Add5,V6@Buf4};
<<1:1,V6@Buf2/bitstring>> ->
{V6@V3,V6@Buf4} = case V6@Buf2 of
<<0:1,V6@V6:7,V6@Buf7/bitstring>> when V6@V6 =/= 0 ->
{V6@V6,V6@Buf7};
<<1:1,0:1,V6@V7:14,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
{V6@V7,V6@Buf8}
end,
{V6@V3,V6@Buf4}
end,
<<V6@V9:V6@V0/bitstring-unit:1,V6@Buf10/bitstring>> = V6@Buf1,
{V6@V9,V6@Buf10}
end,
Bytes13= skipextensions(Bytes12, 1, Extensions),
Res1 = #{id=>Term2,revision=>Term3,refPoint=>Term4,laneSet=>Term7},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{name=>Term1}
end,
Res3 = case Term5 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{laneWidth=>Term5}
end,
Res4 = case Term6 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{speedLimits=>Term6}
end,
Res5 = case Term8 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{preemptPriorityData=>Term8}
end,
Res6 = case Term9 of
  asn1_NOVALUE -> Res5;
  _ -> Res5#{regional=>Term9}
end,
{Res6,Bytes13}.


dec_IntersectionGeometry_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components49(V1@Add2, V1@Buf1, []).


dec_IntersectionGeometry_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_IntersectionGeometryList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 5 =:= 0 ->
[<<Enc1@len@sub:5>>|[enc_IntersectionGeometry(Comp) || Comp <- Val]]
end.



dec_IntersectionGeometryList(Bytes) ->
%% Length with constraint {1,32}
<<V1@V0:5,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components50(V1@Add2, V1@Buf1, []).

enc_IntersectionReferenceID(Val) ->
#{id:=Input@2} = Val,
Input@1 = case Val of
  #{region:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
<<0:1>>;
true ->
<<1:1>>
end,
begin
%% attribute region(1) with type INTEGER
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
Input@1 bsr 16 =:= 0 ->
<<Input@1:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute id(2) with type INTEGER
if Input@2 bsr 16 =:= 0 ->
<<Input@2:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end].


dec_IntersectionReferenceID(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute region(1) with type INTEGER
{Term1,Bytes2} = case Opt band 1 of
1 ->
begin
<<V2@V0:16,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes1}
end,

%% attribute id(2) with type INTEGER
{Term2,Bytes3} = begin
<<V3@V0:16,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,
Res1 = #{id=>Term2},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{region=>Term1}
end,
{Res2,Bytes3}.

enc_IntersectionState(Val) ->
#{id:=Input@2,revision:=Input@3,status:=Input@4,states:=Input@8} = Val,
Input@1 = case Val of
  #{name:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{moy:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@6 = case Val of
  #{timeStamp:=Input@6_0} -> Input@6_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@7 = case Val of
  #{enabledLanes:=Input@7_0} -> Input@7_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@9 = case Val of
  #{maneuverAssistList:=Input@9_0} -> Input@9_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@10 = case Val of
  #{regional:=Input@10_0} -> Input@10_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@6 =:= asn1__MISSING_IN_MAP ->
if Input@7 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@7 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@9 =:= asn1__MISSING_IN_MAP ->
if Input@10 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@10 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
begin
%% attribute name(1) with type IA5String
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Enc2@len = length(Input@1),
Enc2@bin = encode_chars(Input@1, 7),
Enc2@len@sub = Enc2@len - 1,
if 0 =< Enc2@len@sub, Enc2@len@sub < 63 ->
[<<Enc2@len@sub:6>>|Enc2@bin]
end
end
end
end,
begin
%% attribute id(2) with type IntersectionReferenceID
enc_IntersectionReferenceID(Input@2)
end,
begin
%% attribute revision(3) with type INTEGER
if Input@3 bsr 7 =:= 0 ->
<<Input@3:7>>;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end,
begin
%% attribute status(4) with type BIT STRING
Enc5@bs = try bit_string_name2pos_51(Input@4) of
Enc5@positions ->
bitstring_from_positions(Enc5@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(Input@4, 16)
end,
Enc5@bits = bit_size(Enc5@bs),
if Enc5@bits =:= 16 ->
Enc5@bs
end
end,
begin
%% attribute moy(5) with type INTEGER
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@5, Input@5 < 527041 ->
<<Input@5:20>>;
true ->
exit({error,{asn1,{illegal_integer,Input@5}}})
end
end,
begin
%% attribute timeStamp(6) with type INTEGER
if Input@6 =:= asn1__MISSING_IN_MAP ->
[];
Input@6 bsr 16 =:= 0 ->
<<Input@6:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@6}}})
end
end,
begin
%% attribute enabledLanes(7) with type EnabledLaneList
if Input@7 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_EnabledLaneList(Input@7)
end
end,
begin
%% attribute states(8) with type MovementList
enc_MovementList(Input@8)
end,
begin
%% attribute maneuverAssistList(9) with type ManeuverAssistList
if Input@9 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_ManeuverAssistList(Input@9)
end
end|begin
%% attribute regional(10) with type SEQUENCE OF
if Input@10 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_IntersectionState_regional(Input@10)
end
end].
enc_IntersectionState_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_IntersectionState_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_IntersectionState_regional_RegionalExtension(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type52(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_IntersectionState(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:6,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute name(1) with type IA5String
{Term1,Bytes3} = case (Opt bsr 5) band 1 of
1 ->
begin
<<V3@V0:6,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + 1,
<<V3@V3:V3@Add2/binary-unit:7,V3@Buf4/bitstring>> = V3@Buf1,
{V3@V5,V3@Buf6}  = {decode_chars(V3@V3, 7),V3@Buf4},
{V3@V5,V3@Buf6}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute id(2) with type IntersectionReferenceID
{Term2,Bytes4} = dec_IntersectionReferenceID(Bytes3),

%% attribute revision(3) with type INTEGER
{Term3,Bytes5} = begin
<<V4@V0:7,V4@Buf1/bitstring>> = Bytes4,
{V4@V0,V4@Buf1}
end,

%% attribute status(4) with type BIT STRING
{Term4,Bytes6} = begin
<<V5@V0:16/binary-unit:1,V5@Buf1/bitstring>> = Bytes5,
{V5@V2,V5@Buf3}  = {decode_named_bit_string(V5@V0, [{manualControlIsEnabled,0},{stopTimeIsActivated,1},{failureFlash,2},{preemptIsActive,3},{signalPriorityIsActive,4},{fixedTimeOperation,5},{trafficDependentOperation,6},{standbyOperation,7},{failureMode,8},{off,9},{recentMAPmessageUpdate,10},{recentChangeInMAPassignedLanesIDsUsed,11},{noValidMAPisAvailableAtThisTime,12},{noValidSPATisAvailableAtThisTime,13}]),V5@Buf1},
{V5@V2,V5@Buf3}
end,

%% attribute moy(5) with type INTEGER
{Term5,Bytes7} = case (Opt bsr 4) band 1 of
1 ->
begin
<<V6@V0:20,V6@Buf1/bitstring>> = Bytes6,
{V6@V0,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute timeStamp(6) with type INTEGER
{Term6,Bytes8} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V7@V0:16,V7@Buf1/bitstring>> = Bytes7,
{V7@V0,V7@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute enabledLanes(7) with type EnabledLaneList
{Term7,Bytes9} = case (Opt bsr 2) band 1 of
1 ->
dec_EnabledLaneList(Bytes8);
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% attribute states(8) with type MovementList
{Term8,Bytes10} = dec_MovementList(Bytes9),

%% attribute maneuverAssistList(9) with type ManeuverAssistList
{Term9,Bytes11} = case (Opt bsr 1) band 1 of
1 ->
dec_ManeuverAssistList(Bytes10);
0 ->
{asn1_NOVALUE,Bytes10}
end,

%% attribute regional(10) with type SEQUENCE OF
{Term10,Bytes12} = case Opt band 1 of
1 ->
dec_IntersectionState_regional(Bytes11);
0 ->
{asn1_NOVALUE,Bytes11}
end,

%% Extensions
{Extensions,Bytes13} = case Ext of
0 -> {<<>>,Bytes12};
1 ->
{V8@V0,V8@Buf1} = case Bytes12 of
<<0:1,V8@V3:6,V8@Buf4/bitstring>> ->
V8@Add5 = V8@V3 + 1,
{V8@Add5,V8@Buf4};
<<1:1,V8@Buf2/bitstring>> ->
{V8@V3,V8@Buf4} = case V8@Buf2 of
<<0:1,V8@V6:7,V8@Buf7/bitstring>> when V8@V6 =/= 0 ->
{V8@V6,V8@Buf7};
<<1:1,0:1,V8@V7:14,V8@Buf8/bitstring>> when V8@V7 =/= 0 ->
{V8@V7,V8@Buf8}
end,
{V8@V3,V8@Buf4}
end,
<<V8@V9:V8@V0/bitstring-unit:1,V8@Buf10/bitstring>> = V8@Buf1,
{V8@V9,V8@Buf10}
end,
Bytes14= skipextensions(Bytes13, 1, Extensions),
Res1 = #{id=>Term2,revision=>Term3,status=>Term4,states=>Term8},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{name=>Term1}
end,
Res3 = case Term5 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{moy=>Term5}
end,
Res4 = case Term6 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{timeStamp=>Term6}
end,
Res5 = case Term7 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{enabledLanes=>Term7}
end,
Res6 = case Term9 of
  asn1_NOVALUE -> Res5;
  _ -> Res5#{maneuverAssistList=>Term9}
end,
Res7 = case Term10 of
  asn1_NOVALUE -> Res6;
  _ -> Res6#{regional=>Term10}
end,
{Res7,Bytes14}.


dec_IntersectionState_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components53(V1@Add2, V1@Buf1, []).


dec_IntersectionState_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type54(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_IntersectionStateList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 5 =:= 0 ->
[<<Enc1@len@sub:5>>|[enc_IntersectionState(Comp) || Comp <- Val]]
end.



dec_IntersectionStateList(Bytes) ->
%% Length with constraint {1,32}
<<V1@V0:5,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components55(V1@Add2, V1@Buf1, []).

enc_ExitService(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 4 =:= 0 ->
[<<Enc1@len@sub:4>>|[enc_ExitService_SEQOF(Comp) || Comp <- Val]]
end.

enc_ExitService_SEQOF(Val) ->
#{item:=Input@1} = Val,
%% attribute item(1) with type CHOICE
enc_ExitService_SEQOF_item(Input@1).
enc_ExitService_SEQOF_item(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= itis ->
if ChoiceVal bsr 16 =:= 0 ->
<<0:1,ChoiceVal:16>>;
true ->
exit({error,{asn1,{illegal_integer,ChoiceVal}}})
end;
ChoiceTag =:= text ->
begin
Enc4@len = length(ChoiceVal),
Enc4@bin = encode_chars(ChoiceVal, 7),
Enc4@len@sub = Enc4@len - 1,
if Enc4@len@sub bsr 4 =:= 0 ->
[<<1:1,Enc4@len@sub:4>>|Enc4@bin]
end
end
end.


dec_ExitService(Bytes) ->
%% Length with constraint {1,16}
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components56(V1@Add2, V1@Buf1, []).


dec_ExitService_SEQOF(Bytes) ->

%% attribute item(1) with type CHOICE
{Term1,Bytes1} = dec_ExitService_SEQOF_item(Bytes),
Res1 = #{item=>Term1},
{Res1,Bytes1}.


dec_ExitService_SEQOF_item(Bytes) ->
{Choice,Bytes1} = 
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
begin
<<V2@V0:16,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end
end,
{{itis,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
begin
<<V3@V0:4,V3@Buf1/bitstring>> = Bytes1,
V3@Add2 = V3@V0 + 1,
<<V3@V3:V3@Add2/binary-unit:7,V3@Buf4/bitstring>> = V3@Buf1,
{V3@V5,V3@Buf6}  = {decode_chars(V3@V3, 7),V3@Buf4},
{V3@V5,V3@Buf6}
end
end,
{{text,Val},NewBytes}
end.
enc_GenericSignage(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 4 =:= 0 ->
[<<Enc1@len@sub:4>>|[enc_GenericSignage_SEQOF(Comp) || Comp <- Val]]
end.

enc_GenericSignage_SEQOF(Val) ->
#{item:=Input@1} = Val,
%% attribute item(1) with type CHOICE
enc_GenericSignage_SEQOF_item(Input@1).
enc_GenericSignage_SEQOF_item(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= itis ->
if ChoiceVal bsr 16 =:= 0 ->
<<0:1,ChoiceVal:16>>;
true ->
exit({error,{asn1,{illegal_integer,ChoiceVal}}})
end;
ChoiceTag =:= text ->
begin
Enc4@len = length(ChoiceVal),
Enc4@bin = encode_chars(ChoiceVal, 7),
Enc4@len@sub = Enc4@len - 1,
if Enc4@len@sub bsr 4 =:= 0 ->
[<<1:1,Enc4@len@sub:4>>|Enc4@bin]
end
end
end.


dec_GenericSignage(Bytes) ->
%% Length with constraint {1,16}
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components57(V1@Add2, V1@Buf1, []).


dec_GenericSignage_SEQOF(Bytes) ->

%% attribute item(1) with type CHOICE
{Term1,Bytes1} = dec_GenericSignage_SEQOF_item(Bytes),
Res1 = #{item=>Term1},
{Res1,Bytes1}.


dec_GenericSignage_SEQOF_item(Bytes) ->
{Choice,Bytes1} = 
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
begin
<<V2@V0:16,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end
end,
{{itis,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
begin
<<V3@V0:4,V3@Buf1/bitstring>> = Bytes1,
V3@Add2 = V3@V0 + 1,
<<V3@V3:V3@Add2/binary-unit:7,V3@Buf4/bitstring>> = V3@Buf1,
{V3@V5,V3@Buf6}  = {decode_chars(V3@V3, 7),V3@Buf4},
{V3@V5,V3@Buf6}
end
end,
{{text,Val},NewBytes}
end.
enc_SpeedLimit(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 4 =:= 0 ->
[<<Enc1@len@sub:4>>|[enc_SpeedLimit_SEQOF(Comp) || Comp <- Val]]
end.

enc_SpeedLimit_SEQOF(Val) ->
#{item:=Input@1} = Val,
%% attribute item(1) with type CHOICE
enc_SpeedLimit_SEQOF_item(Input@1).
enc_SpeedLimit_SEQOF_item(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= itis ->
if ChoiceVal bsr 16 =:= 0 ->
<<0:1,ChoiceVal:16>>;
true ->
exit({error,{asn1,{illegal_integer,ChoiceVal}}})
end;
ChoiceTag =:= text ->
begin
Enc4@len = length(ChoiceVal),
Enc4@bin = encode_chars(ChoiceVal, 7),
Enc4@len@sub = Enc4@len - 1,
if Enc4@len@sub bsr 4 =:= 0 ->
[<<1:1,Enc4@len@sub:4>>|Enc4@bin]
end
end
end.


dec_SpeedLimit(Bytes) ->
%% Length with constraint {1,16}
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components58(V1@Add2, V1@Buf1, []).


dec_SpeedLimit_SEQOF(Bytes) ->

%% attribute item(1) with type CHOICE
{Term1,Bytes1} = dec_SpeedLimit_SEQOF_item(Bytes),
Res1 = #{item=>Term1},
{Res1,Bytes1}.


dec_SpeedLimit_SEQOF_item(Bytes) ->
{Choice,Bytes1} = 
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
begin
<<V2@V0:16,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end
end,
{{itis,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
begin
<<V3@V0:4,V3@Buf1/bitstring>> = Bytes1,
V3@Add2 = V3@V0 + 1,
<<V3@V3:V3@Add2/binary-unit:7,V3@Buf4/bitstring>> = V3@Buf1,
{V3@V5,V3@Buf6}  = {decode_chars(V3@V3, 7),V3@Buf4},
{V3@V5,V3@Buf6}
end
end,
{{text,Val},NewBytes}
end.
enc_WorkZone(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 4 =:= 0 ->
[<<Enc1@len@sub:4>>|[enc_WorkZone_SEQOF(Comp) || Comp <- Val]]
end.

enc_WorkZone_SEQOF(Val) ->
#{item:=Input@1} = Val,
%% attribute item(1) with type CHOICE
enc_WorkZone_SEQOF_item(Input@1).
enc_WorkZone_SEQOF_item(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= itis ->
if ChoiceVal bsr 16 =:= 0 ->
<<0:1,ChoiceVal:16>>;
true ->
exit({error,{asn1,{illegal_integer,ChoiceVal}}})
end;
ChoiceTag =:= text ->
begin
Enc4@len = length(ChoiceVal),
Enc4@bin = encode_chars(ChoiceVal, 7),
Enc4@len@sub = Enc4@len - 1,
if Enc4@len@sub bsr 4 =:= 0 ->
[<<1:1,Enc4@len@sub:4>>|Enc4@bin]
end
end
end.


dec_WorkZone(Bytes) ->
%% Length with constraint {1,16}
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components59(V1@Add2, V1@Buf1, []).


dec_WorkZone_SEQOF(Bytes) ->

%% attribute item(1) with type CHOICE
{Term1,Bytes1} = dec_WorkZone_SEQOF_item(Bytes),
Res1 = #{item=>Term1},
{Res1,Bytes1}.


dec_WorkZone_SEQOF_item(Bytes) ->
{Choice,Bytes1} = 
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
begin
<<V2@V0:16,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end
end,
{{itis,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
begin
<<V3@V0:4,V3@Buf1/bitstring>> = Bytes1,
V3@Add2 = V3@V0 + 1,
<<V3@V3:V3@Add2/binary-unit:7,V3@Buf4/bitstring>> = V3@Buf1,
{V3@V5,V3@Buf6}  = {decode_chars(V3@V3, 7),V3@Buf4},
{V3@V5,V3@Buf6}
end
end,
{{text,Val},NewBytes}
end.
enc_J1939data(Val) ->
Input@1 = case Val of
  #{tires:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{axles:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{trailerWeight:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{cargoWeight:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{steeringAxleTemperature:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@6 = case Val of
  #{driveAxleLocation:=Input@6_0} -> Input@6_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@7 = case Val of
  #{driveAxleLiftAirPressure:=Input@7_0} -> Input@7_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@8 = case Val of
  #{driveAxleTemperature:=Input@8_0} -> Input@8_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@9 = case Val of
  #{driveAxleLubePressure:=Input@9_0} -> Input@9_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@10 = case Val of
  #{steeringAxleLubePressure:=Input@10_0} -> Input@10_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@3 =:= asn1__MISSING_IN_MAP ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@5 =:= asn1__MISSING_IN_MAP ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@7 =:= asn1__MISSING_IN_MAP ->
if Input@8 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@8 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@9 =:= asn1__MISSING_IN_MAP ->
if Input@10 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@10 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
begin
%% attribute tires(1) with type TireDataList
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_TireDataList(Input@1)
end
end,
begin
%% attribute axles(2) with type AxleWeightList
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_AxleWeightList(Input@2)
end
end,
begin
%% attribute trailerWeight(3) with type INTEGER
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@3, Input@3 < 64256 ->
<<Input@3:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end,
begin
%% attribute cargoWeight(4) with type INTEGER
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@4, Input@4 < 64256 ->
<<Input@4:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@4}}})
end
end,
begin
%% attribute steeringAxleTemperature(5) with type INTEGER
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Input@5@sub = Input@5 - -40,
if 0 =< Input@5@sub, Input@5@sub < 251 ->
Input@5@sub;
true ->
exit({error,{asn1,{illegal_integer,Input@5}}})
end
end
end
end,
begin
%% attribute driveAxleLocation(6) with type INTEGER
if Input@6 =:= asn1__MISSING_IN_MAP ->
[];
Input@6 bsr 8 =:= 0 ->
Input@6;
true ->
exit({error,{asn1,{illegal_integer,Input@6}}})
end
end,
begin
%% attribute driveAxleLiftAirPressure(7) with type INTEGER
if Input@7 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@7, Input@7 < 1001 ->
<<Input@7:10>>;
true ->
exit({error,{asn1,{illegal_integer,Input@7}}})
end
end,
begin
%% attribute driveAxleTemperature(8) with type INTEGER
if Input@8 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Input@8@sub = Input@8 - -40,
if 0 =< Input@8@sub, Input@8@sub < 251 ->
Input@8@sub;
true ->
exit({error,{asn1,{illegal_integer,Input@8}}})
end
end
end
end,
begin
%% attribute driveAxleLubePressure(9) with type INTEGER
if Input@9 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@9, Input@9 < 251 ->
Input@9;
true ->
exit({error,{asn1,{illegal_integer,Input@9}}})
end
end|begin
%% attribute steeringAxleLubePressure(10) with type INTEGER
if Input@10 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@10, Input@10 < 251 ->
[Input@10];
true ->
exit({error,{asn1,{illegal_integer,Input@10}}})
end
end].


dec_J1939data(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:10,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute tires(1) with type TireDataList
{Term1,Bytes3} = case (Opt bsr 9) band 1 of
1 ->
dec_TireDataList(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute axles(2) with type AxleWeightList
{Term2,Bytes4} = case (Opt bsr 8) band 1 of
1 ->
dec_AxleWeightList(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute trailerWeight(3) with type INTEGER
{Term3,Bytes5} = case (Opt bsr 7) band 1 of
1 ->
begin
<<V3@V0:16,V3@Buf1/bitstring>> = Bytes4,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute cargoWeight(4) with type INTEGER
{Term4,Bytes6} = case (Opt bsr 6) band 1 of
1 ->
begin
<<V4@V0:16,V4@Buf1/bitstring>> = Bytes5,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute steeringAxleTemperature(5) with type INTEGER
{Term5,Bytes7} = case (Opt bsr 5) band 1 of
1 ->
begin
<<V5@V0:8,V5@Buf1/bitstring>> = Bytes6,
V5@Add2 = V5@V0 + -40,
{V5@Add2,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute driveAxleLocation(6) with type INTEGER
{Term6,Bytes8} = case (Opt bsr 4) band 1 of
1 ->
begin
<<V6@V0:8,V6@Buf1/bitstring>> = Bytes7,
{V6@V0,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute driveAxleLiftAirPressure(7) with type INTEGER
{Term7,Bytes9} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V7@V0:10,V7@Buf1/bitstring>> = Bytes8,
{V7@V0,V7@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% attribute driveAxleTemperature(8) with type INTEGER
{Term8,Bytes10} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V8@V0:8,V8@Buf1/bitstring>> = Bytes9,
V8@Add2 = V8@V0 + -40,
{V8@Add2,V8@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes9}
end,

%% attribute driveAxleLubePressure(9) with type INTEGER
{Term9,Bytes11} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V9@V0:8,V9@Buf1/bitstring>> = Bytes10,
{V9@V0,V9@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes10}
end,

%% attribute steeringAxleLubePressure(10) with type INTEGER
{Term10,Bytes12} = case Opt band 1 of
1 ->
begin
<<V10@V0:8,V10@Buf1/bitstring>> = Bytes11,
{V10@V0,V10@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes11}
end,

%% Extensions
{Extensions,Bytes13} = case Ext of
0 -> {<<>>,Bytes12};
1 ->
{V11@V0,V11@Buf1} = case Bytes12 of
<<0:1,V11@V3:6,V11@Buf4/bitstring>> ->
V11@Add5 = V11@V3 + 1,
{V11@Add5,V11@Buf4};
<<1:1,V11@Buf2/bitstring>> ->
{V11@V3,V11@Buf4} = case V11@Buf2 of
<<0:1,V11@V6:7,V11@Buf7/bitstring>> when V11@V6 =/= 0 ->
{V11@V6,V11@Buf7};
<<1:1,0:1,V11@V7:14,V11@Buf8/bitstring>> when V11@V7 =/= 0 ->
{V11@V7,V11@Buf8}
end,
{V11@V3,V11@Buf4}
end,
<<V11@V9:V11@V0/bitstring-unit:1,V11@Buf10/bitstring>> = V11@Buf1,
{V11@V9,V11@Buf10}
end,
Bytes14= skipextensions(Bytes13, 1, Extensions),
Res1 = #{},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{tires=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{axles=>Term2}
end,
Res4 = case Term3 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{trailerWeight=>Term3}
end,
Res5 = case Term4 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{cargoWeight=>Term4}
end,
Res6 = case Term5 of
  asn1_NOVALUE -> Res5;
  _ -> Res5#{steeringAxleTemperature=>Term5}
end,
Res7 = case Term6 of
  asn1_NOVALUE -> Res6;
  _ -> Res6#{driveAxleLocation=>Term6}
end,
Res8 = case Term7 of
  asn1_NOVALUE -> Res7;
  _ -> Res7#{driveAxleLiftAirPressure=>Term7}
end,
Res9 = case Term8 of
  asn1_NOVALUE -> Res8;
  _ -> Res8#{driveAxleTemperature=>Term8}
end,
Res10 = case Term9 of
  asn1_NOVALUE -> Res9;
  _ -> Res9#{driveAxleLubePressure=>Term9}
end,
Res11 = case Term10 of
  asn1_NOVALUE -> Res10;
  _ -> Res10#{steeringAxleLubePressure=>Term10}
end,
{Res11,Bytes14}.

enc_TireDataList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 4 =:= 0 ->
[<<Enc1@len@sub:4>>|[enc_TireData(Comp) || Comp <- Val]]
end.



dec_TireDataList(Bytes) ->
%% Length with constraint {1,16}
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components60(V1@Add2, V1@Buf1, []).

enc_TireData(Val) ->
Input@1 = case Val of
  #{location:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{pressure:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{temp:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{wheelSensorStatus:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{wheelEndElectFault:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@6 = case Val of
  #{leakageRate:=Input@6_0} -> Input@6_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@7 = case Val of
  #{detection:=Input@7_0} -> Input@7_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@3 =:= asn1__MISSING_IN_MAP ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@5 =:= asn1__MISSING_IN_MAP ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@7 =:= asn1__MISSING_IN_MAP ->
<<0:1>>;
true ->
<<1:1>>
end,
begin
%% attribute location(1) with type INTEGER
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute pressure(2) with type INTEGER
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@2, Input@2 < 251 ->
Input@2;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end,
begin
%% attribute temp(3) with type INTEGER
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Input@3@sub = Input@3 - -8736,
if 0 =< Input@3@sub, Input@3@sub < 64256 ->
<<Input@3@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end
end
end,
begin
%% attribute wheelSensorStatus(4) with type ENUMERATED
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
Input@4 =:= off ->
<<0:2>>;
Input@4 =:= on ->
<<1:2>>;
Input@4 =:= notDefined ->
<<2:2>>;
Input@4 =:= notSupported ->
<<3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@4}}})
end
end,
begin
%% attribute wheelEndElectFault(5) with type ENUMERATED
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
Input@5 =:= isOk ->
<<0:2>>;
Input@5 =:= isNotDefined ->
<<1:2>>;
Input@5 =:= isError ->
<<2:2>>;
Input@5 =:= isNotSupported ->
<<3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@5}}})
end
end,
begin
%% attribute leakageRate(6) with type INTEGER
if Input@6 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@6, Input@6 < 64256 ->
<<Input@6:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@6}}})
end
end|begin
%% attribute detection(7) with type ENUMERATED
if Input@7 =:= asn1__MISSING_IN_MAP ->
[];
Input@7 =:= noData ->
<<0:3>>;
Input@7 =:= overPressure ->
<<1:3>>;
Input@7 =:= noWarningPressure ->
<<2:3>>;
Input@7 =:= underPressure ->
<<3:3>>;
Input@7 =:= extremeUnderPressure ->
<<4:3>>;
Input@7 =:= undefined ->
<<5:3>>;
Input@7 =:= errorIndicator ->
<<6:3>>;
Input@7 =:= notAvailable ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@7}}})
end
end].


dec_TireData(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:7,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute location(1) with type INTEGER
{Term1,Bytes3} = case (Opt bsr 6) band 1 of
1 ->
begin
<<V3@V0:8,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute pressure(2) with type INTEGER
{Term2,Bytes4} = case (Opt bsr 5) band 1 of
1 ->
begin
<<V4@V0:8,V4@Buf1/bitstring>> = Bytes3,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute temp(3) with type INTEGER
{Term3,Bytes5} = case (Opt bsr 4) band 1 of
1 ->
begin
<<V5@V0:16,V5@Buf1/bitstring>> = Bytes4,
V5@Add2 = V5@V0 + -8736,
{V5@Add2,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute wheelSensorStatus(4) with type ENUMERATED
{Term4,Bytes6} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V6@V0:2,V6@Buf1/bitstring>> = Bytes5,
V6@Int2 = case V6@V0 of
0 -> off;
1 -> on;
2 -> notDefined;
3 -> notSupported
end,
{V6@Int2,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute wheelEndElectFault(5) with type ENUMERATED
{Term5,Bytes7} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V7@V0:2,V7@Buf1/bitstring>> = Bytes6,
V7@Int2 = case V7@V0 of
0 -> isOk;
1 -> isNotDefined;
2 -> isError;
3 -> isNotSupported
end,
{V7@Int2,V7@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute leakageRate(6) with type INTEGER
{Term6,Bytes8} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V8@V0:16,V8@Buf1/bitstring>> = Bytes7,
{V8@V0,V8@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute detection(7) with type ENUMERATED
{Term7,Bytes9} = case Opt band 1 of
1 ->
begin
<<V9@V0:3,V9@Buf1/bitstring>> = Bytes8,
V9@Int2 = case V9@V0 of
0 -> noData;
1 -> overPressure;
2 -> noWarningPressure;
3 -> underPressure;
4 -> extremeUnderPressure;
5 -> undefined;
6 -> errorIndicator;
7 -> notAvailable
end,
{V9@Int2,V9@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% Extensions
{Extensions,Bytes10} = case Ext of
0 -> {<<>>,Bytes9};
1 ->
{V10@V0,V10@Buf1} = case Bytes9 of
<<0:1,V10@V3:6,V10@Buf4/bitstring>> ->
V10@Add5 = V10@V3 + 1,
{V10@Add5,V10@Buf4};
<<1:1,V10@Buf2/bitstring>> ->
{V10@V3,V10@Buf4} = case V10@Buf2 of
<<0:1,V10@V6:7,V10@Buf7/bitstring>> when V10@V6 =/= 0 ->
{V10@V6,V10@Buf7};
<<1:1,0:1,V10@V7:14,V10@Buf8/bitstring>> when V10@V7 =/= 0 ->
{V10@V7,V10@Buf8}
end,
{V10@V3,V10@Buf4}
end,
<<V10@V9:V10@V0/bitstring-unit:1,V10@Buf10/bitstring>> = V10@Buf1,
{V10@V9,V10@Buf10}
end,
Bytes11= skipextensions(Bytes10, 1, Extensions),
Res1 = #{},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{location=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{pressure=>Term2}
end,
Res4 = case Term3 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{temp=>Term3}
end,
Res5 = case Term4 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{wheelSensorStatus=>Term4}
end,
Res6 = case Term5 of
  asn1_NOVALUE -> Res5;
  _ -> Res5#{wheelEndElectFault=>Term5}
end,
Res7 = case Term6 of
  asn1_NOVALUE -> Res6;
  _ -> Res6#{leakageRate=>Term6}
end,
Res8 = case Term7 of
  asn1_NOVALUE -> Res7;
  _ -> Res7#{detection=>Term7}
end,
{Res8,Bytes11}.

enc_AxleWeightList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 4 =:= 0 ->
[<<Enc1@len@sub:4>>|[enc_AxleWeightSet(Comp) || Comp <- Val]]
end.



dec_AxleWeightList(Bytes) ->
%% Length with constraint {1,16}
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components61(V1@Add2, V1@Buf1, []).

enc_AxleWeightSet(Val) ->
Input@1 = case Val of
  #{location:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{weight:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
begin
%% attribute location(1) with type INTEGER
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute weight(2) with type INTEGER
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@2, Input@2 < 64256 ->
<<Input@2:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end].


dec_AxleWeightSet(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute location(1) with type INTEGER
{Term1,Bytes3} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V3@V0:8,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute weight(2) with type INTEGER
{Term2,Bytes4} = case Opt band 1 of
1 ->
begin
<<V4@V0:16,V4@Buf1/bitstring>> = Bytes3,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V5@V0,V5@Buf1} = case Bytes4 of
<<0:1,V5@V3:6,V5@Buf4/bitstring>> ->
V5@Add5 = V5@V3 + 1,
{V5@Add5,V5@Buf4};
<<1:1,V5@Buf2/bitstring>> ->
{V5@V3,V5@Buf4} = case V5@Buf2 of
<<0:1,V5@V6:7,V5@Buf7/bitstring>> when V5@V6 =/= 0 ->
{V5@V6,V5@Buf7};
<<1:1,0:1,V5@V7:14,V5@Buf8/bitstring>> when V5@V7 =/= 0 ->
{V5@V7,V5@Buf8}
end,
{V5@V3,V5@Buf4}
end,
<<V5@V9:V5@V0/bitstring-unit:1,V5@Buf10/bitstring>> = V5@Buf1,
{V5@V9,V5@Buf10}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = #{},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{location=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{weight=>Term2}
end,
{Res3,Bytes6}.

enc_LaneAttributes(Val) ->
#{directionalUse:=Input@1,sharedWith:=Input@2,laneType:=Input@3} = Val,
Input@4 = case Val of
  #{regional:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@4 =:= asn1__MISSING_IN_MAP ->
<<0:1>>;
true ->
<<1:1>>
end,
begin
%% attribute directionalUse(1) with type BIT STRING
Enc1@bs = try bit_string_name2pos_62(Input@1) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 2)
catch throw:invalid ->
adjust_trailing_zeroes(Input@1, 2)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 2 ->
Enc1@bs
end
end,
begin
%% attribute sharedWith(2) with type BIT STRING
Enc2@bs = try bit_string_name2pos_63(Input@2) of
Enc2@positions ->
bitstring_from_positions(Enc2@positions, 10)
catch throw:invalid ->
adjust_trailing_zeroes(Input@2, 10)
end,
Enc2@bits = bit_size(Enc2@bs),
if Enc2@bits =:= 10 ->
Enc2@bs
end
end,
begin
%% attribute laneType(3) with type LaneTypeAttributes
enc_LaneTypeAttributes(Input@3)
end|begin
%% attribute regional(4) with type SEQUENCE
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_LaneAttributes_regional(Input@4)
end
end].
enc_LaneAttributes_regional(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_LaneAttributes(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute directionalUse(1) with type BIT STRING
{Term1,Bytes2} = begin
<<V2@V0:2/binary-unit:1,V2@Buf1/bitstring>> = Bytes1,
{V2@V2,V2@Buf3}  = {decode_named_bit_string(V2@V0, [{ingressPath,0},{egressPath,1}]),V2@Buf1},
{V2@V2,V2@Buf3}
end,

%% attribute sharedWith(2) with type BIT STRING
{Term2,Bytes3} = begin
<<V3@V0:10/binary-unit:1,V3@Buf1/bitstring>> = Bytes2,
{V3@V2,V3@Buf3}  = {decode_named_bit_string(V3@V0, [{overlappingLaneDescriptionProvided,0},{multipleLanesTreatedAsOneLane,1},{otherNonMotorizedTrafficTypes,2},{individualMotorizedVehicleTraffic,3},{busVehicleTraffic,4},{taxiVehicleTraffic,5},{pedestriansTraffic,6},{cyclistVehicleTraffic,7},{trackedVehicleTraffic,8},{pedestrianTraffic,9}]),V3@Buf1},
{V3@V2,V3@Buf3}
end,

%% attribute laneType(3) with type LaneTypeAttributes
{Term3,Bytes4} = dec_LaneTypeAttributes(Bytes3),

%% attribute regional(4) with type SEQUENCE
{Term4,Bytes5} = case Opt band 1 of
1 ->
dec_LaneAttributes_regional(Bytes4);
0 ->
{asn1_NOVALUE,Bytes4}
end,
Res1 = #{directionalUse=>Term1,sharedWith=>Term2,laneType=>Term3},
Res2 = case Term4 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{regional=>Term4}
end,
{Res2,Bytes5}.


dec_LaneAttributes_regional(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_LaneDataAttribute(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= pathEndPointAngle ->
begin
ChoiceVal@sub = ChoiceVal - -150,
if 0 =< ChoiceVal@sub, ChoiceVal@sub < 301 ->
<<0:1,0:3,ChoiceVal@sub:9>>;
true ->
exit({error,{asn1,{illegal_integer,ChoiceVal}}})
end
end;
ChoiceTag =:= laneCrownPointCenter ->
begin
ChoiceVal@sub = ChoiceVal - -128,
if ChoiceVal@sub bsr 8 =:= 0 ->
[<<0:1,1:3,ChoiceVal@sub:8>>];
true ->
exit({error,{asn1,{illegal_integer,ChoiceVal}}})
end
end;
ChoiceTag =:= laneCrownPointLeft ->
begin
ChoiceVal@sub = ChoiceVal - -128,
if ChoiceVal@sub bsr 8 =:= 0 ->
[<<0:1,2:3,ChoiceVal@sub:8>>];
true ->
exit({error,{asn1,{illegal_integer,ChoiceVal}}})
end
end;
ChoiceTag =:= laneCrownPointRight ->
begin
ChoiceVal@sub = ChoiceVal - -128,
if ChoiceVal@sub bsr 8 =:= 0 ->
[<<0:1,3:3,ChoiceVal@sub:8>>];
true ->
exit({error,{asn1,{illegal_integer,ChoiceVal}}})
end
end;
ChoiceTag =:= laneAngle ->
begin
ChoiceVal@sub = ChoiceVal - -180,
if 0 =< ChoiceVal@sub, ChoiceVal@sub < 361 ->
<<0:1,4:3,ChoiceVal@sub:9>>;
true ->
exit({error,{asn1,{illegal_integer,ChoiceVal}}})
end
end;
ChoiceTag =:= speedLimits ->
[<<0:1,5:3>>|enc_SpeedLimitList(ChoiceVal)];
ChoiceTag =:= regional ->
[<<0:1,6:3>>|enc_LaneDataAttribute_regional(ChoiceVal)]
end.
enc_LaneDataAttribute_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_LaneDataAttribute_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_LaneDataAttribute_regional_RegionalExtension(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type64(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_LaneDataAttribute(Bytes) ->
case Bytes of
<<0:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes1,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
begin
<<V2@V0:9,V2@Buf1/bitstring>> = Bytes2,
V2@Add2 = V2@V0 + -150,
{V2@Add2,V2@Buf1}
end
end,
{{pathEndPointAngle,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
begin
<<V3@V0:8,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + -128,
{V3@Add2,V3@Buf1}
end
end,
{{laneCrownPointCenter,Val},NewBytes};
2 ->
{Val,NewBytes} = begin
begin
<<V4@V0:8,V4@Buf1/bitstring>> = Bytes2,
V4@Add2 = V4@V0 + -128,
{V4@Add2,V4@Buf1}
end
end,
{{laneCrownPointLeft,Val},NewBytes};
3 ->
{Val,NewBytes} = begin
begin
<<V5@V0:8,V5@Buf1/bitstring>> = Bytes2,
V5@Add2 = V5@V0 + -128,
{V5@Add2,V5@Buf1}
end
end,
{{laneCrownPointRight,Val},NewBytes};
4 ->
{Val,NewBytes} = begin
begin
<<V6@V0:9,V6@Buf1/bitstring>> = Bytes2,
V6@Add2 = V6@V0 + -180,
{V6@Add2,V6@Buf1}
end
end,
{{laneAngle,Val},NewBytes};
5 ->
{Val,NewBytes} = begin
dec_SpeedLimitList(Bytes2)
end,
{{speedLimits,Val},NewBytes};
6 ->
{Val,NewBytes} = begin
dec_LaneDataAttribute_regional(Bytes2)
end,
{{regional,Val},NewBytes}
end;

<<1:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
{V1@V0,V1@Buf1} = case Bytes1 of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> when V1@V6 =/= 0 ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
{V1@V7,V1@Buf8}
end,
<<V1@V9:V1@V3/unit:8,V1@Buf10/bitstring>> = V1@Buf4,
{V1@V9,V1@Buf10}
end,
{V1@V0,V1@Buf1}
end,
begin
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end
end,
case Choice of
_ ->
{{asn1_ExtAlt,V2@V0},V2@Buf1}
end
end.

dec_LaneDataAttribute_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components65(V1@Add2, V1@Buf1, []).


dec_LaneDataAttribute_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type66(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_LaneDataAttributeList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 3 =:= 0 ->
[<<Enc1@len@sub:3>>|[enc_LaneDataAttribute(Comp) || Comp <- Val]]
end.



dec_LaneDataAttributeList(Bytes) ->
%% Length with constraint {1,8}
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components67(V1@Add2, V1@Buf1, []).

enc_LaneList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if 0 =< Enc1@len@sub, Enc1@len@sub < 255 ->
[Enc1@len@sub|[enc_GenericLane(Comp) || Comp <- Val]]
end.



dec_LaneList(Bytes) ->
%% Length with constraint {1,255}
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components68(V1@Add2, V1@Buf1, []).

enc_LaneTypeAttributes(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= vehicle ->
begin
Enc2@bs = try bit_string_name2pos_69(ChoiceVal) of
Enc2@positions ->
bitstring_from_positions(Enc2@positions, 8)
catch throw:invalid ->
adjust_trailing_zeroes(ChoiceVal, 8)
end,
Enc2@bits = bit_size(Enc2@bs),
if Enc2@bits =:= 8 ->
[<<0:1,0:3,0:1>>|Enc2@bs];
Enc2@bits < 128 ->
[<<0:1,0:3,1:1,Enc2@bits:8>>|Enc2@bs];
Enc2@bits < 16384 ->
[<<0:1,0:3,1:1,2:2,Enc2@bits:14>>|Enc2@bs];
true ->
[<<0:1,0:3,1:1>>|encode_fragmented(Enc2@bs, 1)]
end
end;
ChoiceTag =:= crosswalk ->
begin
Enc4@bs = try bit_string_name2pos_70(ChoiceVal) of
Enc4@positions ->
bitstring_from_positions(Enc4@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(ChoiceVal, 16)
end,
Enc4@bits = bit_size(Enc4@bs),
if Enc4@bits =:= 16 ->
[<<0:1,1:3>>|Enc4@bs]
end
end;
ChoiceTag =:= bikeLane ->
begin
Enc6@bs = try bit_string_name2pos_71(ChoiceVal) of
Enc6@positions ->
bitstring_from_positions(Enc6@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(ChoiceVal, 16)
end,
Enc6@bits = bit_size(Enc6@bs),
if Enc6@bits =:= 16 ->
[<<0:1,2:3>>|Enc6@bs]
end
end;
ChoiceTag =:= sidewalk ->
begin
Enc8@bs = try bit_string_name2pos_72(ChoiceVal) of
Enc8@positions ->
bitstring_from_positions(Enc8@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(ChoiceVal, 16)
end,
Enc8@bits = bit_size(Enc8@bs),
if Enc8@bits =:= 16 ->
[<<0:1,3:3>>|Enc8@bs]
end
end;
ChoiceTag =:= median ->
begin
Enc10@bs = try bit_string_name2pos_73(ChoiceVal) of
Enc10@positions ->
bitstring_from_positions(Enc10@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(ChoiceVal, 16)
end,
Enc10@bits = bit_size(Enc10@bs),
if Enc10@bits =:= 16 ->
[<<0:1,4:3>>|Enc10@bs]
end
end;
ChoiceTag =:= striping ->
begin
Enc12@bs = try bit_string_name2pos_74(ChoiceVal) of
Enc12@positions ->
bitstring_from_positions(Enc12@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(ChoiceVal, 16)
end,
Enc12@bits = bit_size(Enc12@bs),
if Enc12@bits =:= 16 ->
[<<0:1,5:3>>|Enc12@bs]
end
end;
ChoiceTag =:= trackedVehicle ->
begin
Enc14@bs = try bit_string_name2pos_75(ChoiceVal) of
Enc14@positions ->
bitstring_from_positions(Enc14@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(ChoiceVal, 16)
end,
Enc14@bits = bit_size(Enc14@bs),
if Enc14@bits =:= 16 ->
[<<0:1,6:3>>|Enc14@bs]
end
end;
ChoiceTag =:= parking ->
begin
Enc16@bs = try bit_string_name2pos_76(ChoiceVal) of
Enc16@positions ->
bitstring_from_positions(Enc16@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(ChoiceVal, 16)
end,
Enc16@bits = bit_size(Enc16@bs),
if Enc16@bits =:= 16 ->
[<<0:1,7:3>>|Enc16@bs]
end
end
end.


dec_LaneTypeAttributes(Bytes) ->
case Bytes of
<<0:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes1,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
begin
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:8/binary-unit:1,V2@Buf4/bitstring>> ->
{V2@V3,V2@Buf4};
<<1:1,V2@Buf2/bitstring>> ->
{V2@V3,V2@Buf4} = case V2@Buf2 of
<<0:1,V2@V6:7,V2@V8:V2@V6/binary-unit:1,V2@Buf9/bitstring>> ->
{V2@V8,V2@Buf9};
<<1:1,0:1,V2@V7:14,V2@V9:V2@V7/binary-unit:1,V2@Buf10/bitstring>> ->
{V2@V9,V2@Buf10};
<<1:1,1:1,V2@V7:6,V2@Buf8/bitstring>> ->
{V2@V9,V2@Buf10}  = decode_fragmented(V2@V7, V2@Buf8, 1),
{V2@V9,V2@Buf10}
end,
{V2@V3,V2@Buf4}
end,
{V2@V11,V2@Buf12}  = {decode_named_bit_string(V2@V0, [{isVehicleRevocableLane,0},{isVehicleFlyOverLane,1},{hovLaneUseOnly,2},{restrictedToBusUse,3},{restrictedToTaxiUse,4},{restrictedFromPublicUse,5},{hasIRbeaconCoverage,6},{permissionOnRequest,7}]),V2@Buf1},
{V2@V11,V2@Buf12}
end
end,
{{vehicle,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
begin
<<V3@V0:16/binary-unit:1,V3@Buf1/bitstring>> = Bytes2,
{V3@V2,V3@Buf3}  = {decode_named_bit_string(V3@V0, [{crosswalkRevocableLane,0},{bicyleUseAllowed,1},{isXwalkFlyOverLane,2},{fixedCycleTime,3},{biDirectionalCycleTimes,4},{hasPushToWalkButton,5},{audioSupport,6},{rfSignalRequestPresent,7},{unsignalizedSegmentsPresent,8}]),V3@Buf1},
{V3@V2,V3@Buf3}
end
end,
{{crosswalk,Val},NewBytes};
2 ->
{Val,NewBytes} = begin
begin
<<V4@V0:16/binary-unit:1,V4@Buf1/bitstring>> = Bytes2,
{V4@V2,V4@Buf3}  = {decode_named_bit_string(V4@V0, [{bikeRevocableLane,0},{pedestrianUseAllowed,1},{isBikeFlyOverLane,2},{fixedCycleTime,3},{biDirectionalCycleTimes,4},{isolatedByBarrier,5},{unsignalizedSegmentsPresent,6}]),V4@Buf1},
{V4@V2,V4@Buf3}
end
end,
{{bikeLane,Val},NewBytes};
3 ->
{Val,NewBytes} = begin
begin
<<V5@V0:16/binary-unit:1,V5@Buf1/bitstring>> = Bytes2,
{V5@V2,V5@Buf3}  = {decode_named_bit_string(V5@V0, [{'sidewalk-RevocableLane',0},{bicyleUseAllowed,1},{isSidewalkFlyOverLane,2},{walkBikes,3}]),V5@Buf1},
{V5@V2,V5@Buf3}
end
end,
{{sidewalk,Val},NewBytes};
4 ->
{Val,NewBytes} = begin
begin
<<V6@V0:16/binary-unit:1,V6@Buf1/bitstring>> = Bytes2,
{V6@V2,V6@Buf3}  = {decode_named_bit_string(V6@V0, [{'median-RevocableLane',0},{median,1},{whiteLineHashing,2},{stripedLines,3},{doubleStripedLines,4},{trafficCones,5},{constructionBarrier,6},{trafficChannels,7},{lowCurbs,8},{highCurbs,9}]),V6@Buf1},
{V6@V2,V6@Buf3}
end
end,
{{median,Val},NewBytes};
5 ->
{Val,NewBytes} = begin
begin
<<V7@V0:16/binary-unit:1,V7@Buf1/bitstring>> = Bytes2,
{V7@V2,V7@Buf3}  = {decode_named_bit_string(V7@V0, [{stripeToConnectingLanesRevocableLane,0},{stripeDrawOnLeft,1},{stripeDrawOnRight,2},{stripeToConnectingLanesLeft,3},{stripeToConnectingLanesRight,4},{stripeToConnectingLanesAhead,5}]),V7@Buf1},
{V7@V2,V7@Buf3}
end
end,
{{striping,Val},NewBytes};
6 ->
{Val,NewBytes} = begin
begin
<<V8@V0:16/binary-unit:1,V8@Buf1/bitstring>> = Bytes2,
{V8@V2,V8@Buf3}  = {decode_named_bit_string(V8@V0, [{'spec-RevocableLane',0},{'spec-commuterRailRoadTrack',1},{'spec-lightRailRoadTrack',2},{'spec-heavyRailRoadTrack',3},{'spec-otherRailType',4}]),V8@Buf1},
{V8@V2,V8@Buf3}
end
end,
{{trackedVehicle,Val},NewBytes};
7 ->
{Val,NewBytes} = begin
begin
<<V9@V0:16/binary-unit:1,V9@Buf1/bitstring>> = Bytes2,
{V9@V2,V9@Buf3}  = {decode_named_bit_string(V9@V0, [{parkingRevocableLane,0},{parallelParkingInUse,1},{headInParkingInUse,2},{doNotParkZone,3},{parkingForBusUse,4},{parkingForTaxiUse,5},{noPublicParkingUse,6}]),V9@Buf1},
{V9@V2,V9@Buf3}
end
end,
{{parking,Val},NewBytes}
end;

<<1:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
{V1@V0,V1@Buf1} = case Bytes1 of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> when V1@V6 =/= 0 ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
{V1@V7,V1@Buf8}
end,
<<V1@V9:V1@V3/unit:8,V1@Buf10/bitstring>> = V1@Buf4,
{V1@V9,V1@Buf10}
end,
{V1@V0,V1@Buf1}
end,
begin
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end
end,
case Choice of
_ ->
{{asn1_ExtAlt,V2@V0},V2@Buf1}
end
end.
enc_ManeuverAssistList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 4 =:= 0 ->
[<<Enc1@len@sub:4>>|[enc_ConnectionManeuverAssist(Comp) || Comp <- Val]]
end.



dec_ManeuverAssistList(Bytes) ->
%% Length with constraint {1,16}
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components77(V1@Add2, V1@Buf1, []).

enc_MovementEventList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 4 =:= 0 ->
[<<Enc1@len@sub:4>>|[enc_MovementEvent(Comp) || Comp <- Val]]
end.



dec_MovementEventList(Bytes) ->
%% Length with constraint {1,16}
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components78(V1@Add2, V1@Buf1, []).

enc_MovementEvent(Val) ->
#{eventState:=Input@1} = Val,
Input@2 = case Val of
  #{timing:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{speeds:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{regional:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@2 =:= asn1__MISSING_IN_MAP ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<0:1>>;
true ->
<<1:1>>
end,
begin
%% attribute eventState(1) with type ENUMERATED
if Input@1 =:= unavailable ->
<<0:4>>;
Input@1 =:= dark ->
<<1:4>>;
Input@1 =:= 'stop-Then-Proceed' ->
<<2:4>>;
Input@1 =:= 'stop-And-Remain' ->
<<3:4>>;
Input@1 =:= 'pre-Movement' ->
<<4:4>>;
Input@1 =:= 'permissive-Movement-Allowed' ->
<<5:4>>;
Input@1 =:= 'protected-Movement-Allowed' ->
<<6:4>>;
Input@1 =:= 'permissive-clearance' ->
<<7:4>>;
Input@1 =:= 'protected-clearance' ->
<<8:4>>;
Input@1 =:= 'caution-Conflicting-Traffic' ->
<<9:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@1}}})
end
end,
begin
%% attribute timing(2) with type TimeChangeDetails
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_TimeChangeDetails(Input@2)
end
end,
begin
%% attribute speeds(3) with type AdvisorySpeedList
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_AdvisorySpeedList(Input@3)
end
end|begin
%% attribute regional(4) with type SEQUENCE OF
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_MovementEvent_regional(Input@4)
end
end].
enc_MovementEvent_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_MovementEvent_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_MovementEvent_regional_RegionalExtension(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type79(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_MovementEvent(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:3,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute eventState(1) with type ENUMERATED
{Term1,Bytes3} = begin
<<V3@V0:4,V3@Buf1/bitstring>> = Bytes2,
V3@Int2 = case V3@V0 of
0 -> unavailable;
1 -> dark;
2 -> 'stop-Then-Proceed';
3 -> 'stop-And-Remain';
4 -> 'pre-Movement';
5 -> 'permissive-Movement-Allowed';
6 -> 'protected-Movement-Allowed';
7 -> 'permissive-clearance';
8 -> 'protected-clearance';
9 -> 'caution-Conflicting-Traffic';
_ -> exit({error,{asn1,{decode_enumerated,V3@V0}}})
end,
{V3@Int2,V3@Buf1}
end,

%% attribute timing(2) with type TimeChangeDetails
{Term2,Bytes4} = case (Opt bsr 2) band 1 of
1 ->
dec_TimeChangeDetails(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute speeds(3) with type AdvisorySpeedList
{Term3,Bytes5} = case (Opt bsr 1) band 1 of
1 ->
dec_AdvisorySpeedList(Bytes4);
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute regional(4) with type SEQUENCE OF
{Term4,Bytes6} = case Opt band 1 of
1 ->
dec_MovementEvent_regional(Bytes5);
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% Extensions
{Extensions,Bytes7} = case Ext of
0 -> {<<>>,Bytes6};
1 ->
{V4@V0,V4@Buf1} = case Bytes6 of
<<0:1,V4@V3:6,V4@Buf4/bitstring>> ->
V4@Add5 = V4@V3 + 1,
{V4@Add5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:7,V4@Buf7/bitstring>> when V4@V6 =/= 0 ->
{V4@V6,V4@Buf7};
<<1:1,0:1,V4@V7:14,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
{V4@V7,V4@Buf8}
end,
{V4@V3,V4@Buf4}
end,
<<V4@V9:V4@V0/bitstring-unit:1,V4@Buf10/bitstring>> = V4@Buf1,
{V4@V9,V4@Buf10}
end,
Bytes8= skipextensions(Bytes7, 1, Extensions),
Res1 = #{eventState=>Term1},
Res2 = case Term2 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{timing=>Term2}
end,
Res3 = case Term3 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{speeds=>Term3}
end,
Res4 = case Term4 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{regional=>Term4}
end,
{Res4,Bytes8}.


dec_MovementEvent_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components80(V1@Add2, V1@Buf1, []).


dec_MovementEvent_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type81(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_MovementList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if 0 =< Enc1@len@sub, Enc1@len@sub < 255 ->
[Enc1@len@sub|[enc_MovementState(Comp) || Comp <- Val]]
end.



dec_MovementList(Bytes) ->
%% Length with constraint {1,255}
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components82(V1@Add2, V1@Buf1, []).

enc_MovementState(Val) ->
#{signalGroup:=Input@2,'state-time-speed':=Input@3} = Val,
Input@1 = case Val of
  #{movementName:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{maneuverAssistList:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{regional:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<0:1>>;
true ->
<<1:1>>
end,
begin
%% attribute movementName(1) with type IA5String
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Enc2@len = length(Input@1),
Enc2@bin = encode_chars(Input@1, 7),
Enc2@len@sub = Enc2@len - 1,
if 0 =< Enc2@len@sub, Enc2@len@sub < 63 ->
[<<Enc2@len@sub:6>>|Enc2@bin]
end
end
end
end,
begin
%% attribute signalGroup(2) with type INTEGER
if Input@2 bsr 8 =:= 0 ->
Input@2;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end,
begin
%% attribute state-time-speed(3) with type MovementEventList
enc_MovementEventList(Input@3)
end,
begin
%% attribute maneuverAssistList(4) with type ManeuverAssistList
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_ManeuverAssistList(Input@4)
end
end|begin
%% attribute regional(5) with type SEQUENCE OF
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_MovementState_regional(Input@5)
end
end].
enc_MovementState_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_MovementState_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_MovementState_regional_RegionalExtension(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_MovementState(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:3,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute movementName(1) with type IA5String
{Term1,Bytes3} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V3@V0:6,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + 1,
<<V3@V3:V3@Add2/binary-unit:7,V3@Buf4/bitstring>> = V3@Buf1,
{V3@V5,V3@Buf6}  = {decode_chars(V3@V3, 7),V3@Buf4},
{V3@V5,V3@Buf6}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute signalGroup(2) with type INTEGER
{Term2,Bytes4} = begin
<<V4@V0:8,V4@Buf1/bitstring>> = Bytes3,
{V4@V0,V4@Buf1}
end,

%% attribute state-time-speed(3) with type MovementEventList
{Term3,Bytes5} = dec_MovementEventList(Bytes4),

%% attribute maneuverAssistList(4) with type ManeuverAssistList
{Term4,Bytes6} = case (Opt bsr 1) band 1 of
1 ->
dec_ManeuverAssistList(Bytes5);
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute regional(5) with type SEQUENCE OF
{Term5,Bytes7} = case Opt band 1 of
1 ->
dec_MovementState_regional(Bytes6);
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% Extensions
{Extensions,Bytes8} = case Ext of
0 -> {<<>>,Bytes7};
1 ->
{V5@V0,V5@Buf1} = case Bytes7 of
<<0:1,V5@V3:6,V5@Buf4/bitstring>> ->
V5@Add5 = V5@V3 + 1,
{V5@Add5,V5@Buf4};
<<1:1,V5@Buf2/bitstring>> ->
{V5@V3,V5@Buf4} = case V5@Buf2 of
<<0:1,V5@V6:7,V5@Buf7/bitstring>> when V5@V6 =/= 0 ->
{V5@V6,V5@Buf7};
<<1:1,0:1,V5@V7:14,V5@Buf8/bitstring>> when V5@V7 =/= 0 ->
{V5@V7,V5@Buf8}
end,
{V5@V3,V5@Buf4}
end,
<<V5@V9:V5@V0/bitstring-unit:1,V5@Buf10/bitstring>> = V5@Buf1,
{V5@V9,V5@Buf10}
end,
Bytes9= skipextensions(Bytes8, 1, Extensions),
Res1 = #{signalGroup=>Term2,'state-time-speed'=>Term3},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{movementName=>Term1}
end,
Res3 = case Term4 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{maneuverAssistList=>Term4}
end,
Res4 = case Term5 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{regional=>Term5}
end,
{Res4,Bytes9}.


dec_MovementState_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components83(V1@Add2, V1@Buf1, []).


dec_MovementState_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

'enc_Node-LL-24B'(Val) ->
#{lon:=Input@1,lat:=Input@2} = Val,
[begin
%% attribute lon(1) with type INTEGER
Input@1@sub = Input@1 - -2048,
if Input@1@sub bsr 12 =:= 0 ->
<<Input@1@sub:12>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute lat(2) with type INTEGER
Input@2@sub = Input@2 - -2048,
if Input@2@sub bsr 12 =:= 0 ->
<<Input@2@sub:12>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end].


'dec_Node-LL-24B'(Bytes) ->

%% attribute lon(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:12,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -2048,
{V1@Add2,V1@Buf1}
end,

%% attribute lat(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:12,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + -2048,
{V2@Add2,V2@Buf1}
end,
Res1 = #{lon=>Term1,lat=>Term2},
{Res1,Bytes2}.

'enc_Node-LL-28B'(Val) ->
#{lon:=Input@1,lat:=Input@2} = Val,
[begin
%% attribute lon(1) with type INTEGER
Input@1@sub = Input@1 - -8192,
if Input@1@sub bsr 14 =:= 0 ->
<<Input@1@sub:14>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute lat(2) with type INTEGER
Input@2@sub = Input@2 - -8192,
if Input@2@sub bsr 14 =:= 0 ->
<<Input@2@sub:14>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end].


'dec_Node-LL-28B'(Bytes) ->

%% attribute lon(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:14,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -8192,
{V1@Add2,V1@Buf1}
end,

%% attribute lat(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:14,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + -8192,
{V2@Add2,V2@Buf1}
end,
Res1 = #{lon=>Term1,lat=>Term2},
{Res1,Bytes2}.

'enc_Node-LL-32B'(Val) ->
#{lon:=Input@1,lat:=Input@2} = Val,
[begin
%% attribute lon(1) with type INTEGER
Input@1@sub = Input@1 - -32768,
if Input@1@sub bsr 16 =:= 0 ->
<<Input@1@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute lat(2) with type INTEGER
Input@2@sub = Input@2 - -32768,
if Input@2@sub bsr 16 =:= 0 ->
<<Input@2@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end].


'dec_Node-LL-32B'(Bytes) ->

%% attribute lon(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -32768,
{V1@Add2,V1@Buf1}
end,

%% attribute lat(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:16,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + -32768,
{V2@Add2,V2@Buf1}
end,
Res1 = #{lon=>Term1,lat=>Term2},
{Res1,Bytes2}.

'enc_Node-LL-36B'(Val) ->
#{lon:=Input@1,lat:=Input@2} = Val,
[begin
%% attribute lon(1) with type INTEGER
Input@1@sub = Input@1 - -131072,
if Input@1@sub bsr 18 =:= 0 ->
<<Input@1@sub:18>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute lat(2) with type INTEGER
Input@2@sub = Input@2 - -131072,
if Input@2@sub bsr 18 =:= 0 ->
<<Input@2@sub:18>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end].


'dec_Node-LL-36B'(Bytes) ->

%% attribute lon(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:18,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -131072,
{V1@Add2,V1@Buf1}
end,

%% attribute lat(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:18,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + -131072,
{V2@Add2,V2@Buf1}
end,
Res1 = #{lon=>Term1,lat=>Term2},
{Res1,Bytes2}.

'enc_Node-LL-44B'(Val) ->
#{lon:=Input@1,lat:=Input@2} = Val,
[begin
%% attribute lon(1) with type INTEGER
Input@1@sub = Input@1 - -2097152,
if Input@1@sub bsr 22 =:= 0 ->
<<Input@1@sub:22>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute lat(2) with type INTEGER
Input@2@sub = Input@2 - -2097152,
if Input@2@sub bsr 22 =:= 0 ->
<<Input@2@sub:22>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end].


'dec_Node-LL-44B'(Bytes) ->

%% attribute lon(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:22,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -2097152,
{V1@Add2,V1@Buf1}
end,

%% attribute lat(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:22,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + -2097152,
{V2@Add2,V2@Buf1}
end,
Res1 = #{lon=>Term1,lat=>Term2},
{Res1,Bytes2}.

'enc_Node-LL-48B'(Val) ->
#{lon:=Input@1,lat:=Input@2} = Val,
[begin
%% attribute lon(1) with type INTEGER
Input@1@sub = Input@1 - -8388608,
if Input@1@sub bsr 24 =:= 0 ->
<<Input@1@sub:24>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute lat(2) with type INTEGER
Input@2@sub = Input@2 - -8388608,
if Input@2@sub bsr 24 =:= 0 ->
<<Input@2@sub:24>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end].


'dec_Node-LL-48B'(Bytes) ->

%% attribute lon(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:24,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -8388608,
{V1@Add2,V1@Buf1}
end,

%% attribute lat(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:24,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + -8388608,
{V2@Add2,V2@Buf1}
end,
Res1 = #{lon=>Term1,lat=>Term2},
{Res1,Bytes2}.

'enc_Node-LLmD-64b'(Val) ->
#{lon:=Input@1,lat:=Input@2} = Val,
[begin
%% attribute lon(1) with type INTEGER
Input@1@sub = Input@1 - -1799999999,
if 0 =< Input@1@sub, Input@1@sub < 3600000001 ->
<<Input@1@sub:32>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute lat(2) with type INTEGER
Input@2@sub = Input@2 - -900000000,
if 0 =< Input@2@sub, Input@2@sub < 1800000002 ->
<<Input@2@sub:31>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end].


'dec_Node-LLmD-64b'(Bytes) ->

%% attribute lon(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:32,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -1799999999,
{V1@Add2,V1@Buf1}
end,

%% attribute lat(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:31,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + -900000000,
{V2@Add2,V2@Buf1}
end,
Res1 = #{lon=>Term1,lat=>Term2},
{Res1,Bytes2}.

'enc_Node-XY-20b'(Val) ->
#{x:=Input@1,y:=Input@2} = Val,
[begin
%% attribute x(1) with type INTEGER
Input@1@sub = Input@1 - -512,
if Input@1@sub bsr 10 =:= 0 ->
<<Input@1@sub:10>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute y(2) with type INTEGER
Input@2@sub = Input@2 - -512,
if Input@2@sub bsr 10 =:= 0 ->
<<Input@2@sub:10>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end].


'dec_Node-XY-20b'(Bytes) ->

%% attribute x(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:10,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -512,
{V1@Add2,V1@Buf1}
end,

%% attribute y(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:10,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + -512,
{V2@Add2,V2@Buf1}
end,
Res1 = #{x=>Term1,y=>Term2},
{Res1,Bytes2}.

'enc_Node-XY-22b'(Val) ->
#{x:=Input@1,y:=Input@2} = Val,
[begin
%% attribute x(1) with type INTEGER
Input@1@sub = Input@1 - -1024,
if Input@1@sub bsr 11 =:= 0 ->
<<Input@1@sub:11>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute y(2) with type INTEGER
Input@2@sub = Input@2 - -1024,
if Input@2@sub bsr 11 =:= 0 ->
<<Input@2@sub:11>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end].


'dec_Node-XY-22b'(Bytes) ->

%% attribute x(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:11,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -1024,
{V1@Add2,V1@Buf1}
end,

%% attribute y(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:11,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + -1024,
{V2@Add2,V2@Buf1}
end,
Res1 = #{x=>Term1,y=>Term2},
{Res1,Bytes2}.

'enc_Node-XY-24b'(Val) ->
#{x:=Input@1,y:=Input@2} = Val,
[begin
%% attribute x(1) with type INTEGER
Input@1@sub = Input@1 - -2048,
if Input@1@sub bsr 12 =:= 0 ->
<<Input@1@sub:12>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute y(2) with type INTEGER
Input@2@sub = Input@2 - -2048,
if Input@2@sub bsr 12 =:= 0 ->
<<Input@2@sub:12>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end].


'dec_Node-XY-24b'(Bytes) ->

%% attribute x(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:12,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -2048,
{V1@Add2,V1@Buf1}
end,

%% attribute y(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:12,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + -2048,
{V2@Add2,V2@Buf1}
end,
Res1 = #{x=>Term1,y=>Term2},
{Res1,Bytes2}.

'enc_Node-XY-26b'(Val) ->
#{x:=Input@1,y:=Input@2} = Val,
[begin
%% attribute x(1) with type INTEGER
Input@1@sub = Input@1 - -4096,
if Input@1@sub bsr 13 =:= 0 ->
<<Input@1@sub:13>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute y(2) with type INTEGER
Input@2@sub = Input@2 - -4096,
if Input@2@sub bsr 13 =:= 0 ->
<<Input@2@sub:13>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end].


'dec_Node-XY-26b'(Bytes) ->

%% attribute x(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:13,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -4096,
{V1@Add2,V1@Buf1}
end,

%% attribute y(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:13,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + -4096,
{V2@Add2,V2@Buf1}
end,
Res1 = #{x=>Term1,y=>Term2},
{Res1,Bytes2}.

'enc_Node-XY-28b'(Val) ->
#{x:=Input@1,y:=Input@2} = Val,
[begin
%% attribute x(1) with type INTEGER
Input@1@sub = Input@1 - -8192,
if Input@1@sub bsr 14 =:= 0 ->
<<Input@1@sub:14>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute y(2) with type INTEGER
Input@2@sub = Input@2 - -8192,
if Input@2@sub bsr 14 =:= 0 ->
<<Input@2@sub:14>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end].


'dec_Node-XY-28b'(Bytes) ->

%% attribute x(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:14,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -8192,
{V1@Add2,V1@Buf1}
end,

%% attribute y(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:14,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + -8192,
{V2@Add2,V2@Buf1}
end,
Res1 = #{x=>Term1,y=>Term2},
{Res1,Bytes2}.

'enc_Node-XY-32b'(Val) ->
#{x:=Input@1,y:=Input@2} = Val,
[begin
%% attribute x(1) with type INTEGER
Input@1@sub = Input@1 - -32768,
if Input@1@sub bsr 16 =:= 0 ->
<<Input@1@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute y(2) with type INTEGER
Input@2@sub = Input@2 - -32768,
if Input@2@sub bsr 16 =:= 0 ->
<<Input@2@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end].


'dec_Node-XY-32b'(Bytes) ->

%% attribute x(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -32768,
{V1@Add2,V1@Buf1}
end,

%% attribute y(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:16,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + -32768,
{V2@Add2,V2@Buf1}
end,
Res1 = #{x=>Term1,y=>Term2},
{Res1,Bytes2}.

enc_NodeAttributeLLList(Val) ->
Enc2@len = length(Val),
Enc2@len@sub = Enc2@len - 1,
if Enc2@len@sub bsr 3 =:= 0 ->
[<<Enc2@len@sub:3>>|[if Comp =:= reserved ->
<<0:1,0:4>>;
Comp =:= stopLine ->
<<0:1,1:4>>;
Comp =:= roundedCapStyleA ->
<<0:1,2:4>>;
Comp =:= roundedCapStyleB ->
<<0:1,3:4>>;
Comp =:= mergePoint ->
<<0:1,4:4>>;
Comp =:= divergePoint ->
<<0:1,5:4>>;
Comp =:= downstreamStopLine ->
<<0:1,6:4>>;
Comp =:= downstreamStartNode ->
<<0:1,7:4>>;
Comp =:= closedToTraffic ->
<<0:1,8:4>>;
Comp =:= safeIsland ->
<<0:1,9:4>>;
Comp =:= curbPresentAtStepOff ->
<<0:1,10:4>>;
Comp =:= hydrantPresent ->
<<0:1,11:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Comp}}})
end || Comp <- Val]]
end.



dec_NodeAttributeLLList(Bytes) ->
%% Length with constraint {1,8}
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components84(V1@Add2, V1@Buf1, []).

enc_NodeAttributeSetLL(Val) ->
Input@1 = case Val of
  #{localNode:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{disabled:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{enabled:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{data:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{dWidth:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@6 = case Val of
  #{dElevation:=Input@6_0} -> Input@6_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@7 = case Val of
  #{regional:=Input@7_0} -> Input@7_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@3 =:= asn1__MISSING_IN_MAP ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@5 =:= asn1__MISSING_IN_MAP ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@7 =:= asn1__MISSING_IN_MAP ->
<<0:1>>;
true ->
<<1:1>>
end,
begin
%% attribute localNode(1) with type NodeAttributeLLList
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_NodeAttributeLLList(Input@1)
end
end,
begin
%% attribute disabled(2) with type SegmentAttributeLLList
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_SegmentAttributeLLList(Input@2)
end
end,
begin
%% attribute enabled(3) with type SegmentAttributeLLList
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_SegmentAttributeLLList(Input@3)
end
end,
begin
%% attribute data(4) with type LaneDataAttributeList
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_LaneDataAttributeList(Input@4)
end
end,
begin
%% attribute dWidth(5) with type INTEGER
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Input@5@sub = Input@5 - -512,
if Input@5@sub bsr 10 =:= 0 ->
<<Input@5@sub:10>>;
true ->
exit({error,{asn1,{illegal_integer,Input@5}}})
end
end
end
end,
begin
%% attribute dElevation(6) with type INTEGER
if Input@6 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Input@6@sub = Input@6 - -512,
if Input@6@sub bsr 10 =:= 0 ->
<<Input@6@sub:10>>;
true ->
exit({error,{asn1,{illegal_integer,Input@6}}})
end
end
end
end|begin
%% attribute regional(7) with type SEQUENCE OF
if Input@7 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_NodeAttributeSetLL_regional(Input@7)
end
end].
enc_NodeAttributeSetLL_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_NodeAttributeSetLL_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_NodeAttributeSetLL_regional_RegionalExtension(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_NodeAttributeSetLL(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:7,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute localNode(1) with type NodeAttributeLLList
{Term1,Bytes3} = case (Opt bsr 6) band 1 of
1 ->
dec_NodeAttributeLLList(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute disabled(2) with type SegmentAttributeLLList
{Term2,Bytes4} = case (Opt bsr 5) band 1 of
1 ->
dec_SegmentAttributeLLList(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute enabled(3) with type SegmentAttributeLLList
{Term3,Bytes5} = case (Opt bsr 4) band 1 of
1 ->
dec_SegmentAttributeLLList(Bytes4);
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute data(4) with type LaneDataAttributeList
{Term4,Bytes6} = case (Opt bsr 3) band 1 of
1 ->
dec_LaneDataAttributeList(Bytes5);
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute dWidth(5) with type INTEGER
{Term5,Bytes7} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V3@V0:10,V3@Buf1/bitstring>> = Bytes6,
V3@Add2 = V3@V0 + -512,
{V3@Add2,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute dElevation(6) with type INTEGER
{Term6,Bytes8} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V4@V0:10,V4@Buf1/bitstring>> = Bytes7,
V4@Add2 = V4@V0 + -512,
{V4@Add2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute regional(7) with type SEQUENCE OF
{Term7,Bytes9} = case Opt band 1 of
1 ->
dec_NodeAttributeSetLL_regional(Bytes8);
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% Extensions
{Extensions,Bytes10} = case Ext of
0 -> {<<>>,Bytes9};
1 ->
{V5@V0,V5@Buf1} = case Bytes9 of
<<0:1,V5@V3:6,V5@Buf4/bitstring>> ->
V5@Add5 = V5@V3 + 1,
{V5@Add5,V5@Buf4};
<<1:1,V5@Buf2/bitstring>> ->
{V5@V3,V5@Buf4} = case V5@Buf2 of
<<0:1,V5@V6:7,V5@Buf7/bitstring>> when V5@V6 =/= 0 ->
{V5@V6,V5@Buf7};
<<1:1,0:1,V5@V7:14,V5@Buf8/bitstring>> when V5@V7 =/= 0 ->
{V5@V7,V5@Buf8}
end,
{V5@V3,V5@Buf4}
end,
<<V5@V9:V5@V0/bitstring-unit:1,V5@Buf10/bitstring>> = V5@Buf1,
{V5@V9,V5@Buf10}
end,
Bytes11= skipextensions(Bytes10, 1, Extensions),
Res1 = #{},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{localNode=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{disabled=>Term2}
end,
Res4 = case Term3 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{enabled=>Term3}
end,
Res5 = case Term4 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{data=>Term4}
end,
Res6 = case Term5 of
  asn1_NOVALUE -> Res5;
  _ -> Res5#{dWidth=>Term5}
end,
Res7 = case Term6 of
  asn1_NOVALUE -> Res6;
  _ -> Res6#{dElevation=>Term6}
end,
Res8 = case Term7 of
  asn1_NOVALUE -> Res7;
  _ -> Res7#{regional=>Term7}
end,
{Res8,Bytes11}.


dec_NodeAttributeSetLL_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components85(V1@Add2, V1@Buf1, []).


dec_NodeAttributeSetLL_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_NodeAttributeSetXY(Val) ->
Input@1 = case Val of
  #{localNode:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{disabled:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{enabled:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{data:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{dWidth:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@6 = case Val of
  #{dElevation:=Input@6_0} -> Input@6_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@7 = case Val of
  #{regional:=Input@7_0} -> Input@7_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@3 =:= asn1__MISSING_IN_MAP ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@5 =:= asn1__MISSING_IN_MAP ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@7 =:= asn1__MISSING_IN_MAP ->
<<0:1>>;
true ->
<<1:1>>
end,
begin
%% attribute localNode(1) with type NodeAttributeXYList
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_NodeAttributeXYList(Input@1)
end
end,
begin
%% attribute disabled(2) with type SegmentAttributeXYList
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_SegmentAttributeXYList(Input@2)
end
end,
begin
%% attribute enabled(3) with type SegmentAttributeXYList
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_SegmentAttributeXYList(Input@3)
end
end,
begin
%% attribute data(4) with type LaneDataAttributeList
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_LaneDataAttributeList(Input@4)
end
end,
begin
%% attribute dWidth(5) with type INTEGER
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Input@5@sub = Input@5 - -512,
if Input@5@sub bsr 10 =:= 0 ->
<<Input@5@sub:10>>;
true ->
exit({error,{asn1,{illegal_integer,Input@5}}})
end
end
end
end,
begin
%% attribute dElevation(6) with type INTEGER
if Input@6 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Input@6@sub = Input@6 - -512,
if Input@6@sub bsr 10 =:= 0 ->
<<Input@6@sub:10>>;
true ->
exit({error,{asn1,{illegal_integer,Input@6}}})
end
end
end
end|begin
%% attribute regional(7) with type SEQUENCE OF
if Input@7 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_NodeAttributeSetXY_regional(Input@7)
end
end].
enc_NodeAttributeSetXY_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_NodeAttributeSetXY_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_NodeAttributeSetXY_regional_RegionalExtension(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_NodeAttributeSetXY(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:7,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute localNode(1) with type NodeAttributeXYList
{Term1,Bytes3} = case (Opt bsr 6) band 1 of
1 ->
dec_NodeAttributeXYList(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute disabled(2) with type SegmentAttributeXYList
{Term2,Bytes4} = case (Opt bsr 5) band 1 of
1 ->
dec_SegmentAttributeXYList(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute enabled(3) with type SegmentAttributeXYList
{Term3,Bytes5} = case (Opt bsr 4) band 1 of
1 ->
dec_SegmentAttributeXYList(Bytes4);
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute data(4) with type LaneDataAttributeList
{Term4,Bytes6} = case (Opt bsr 3) band 1 of
1 ->
dec_LaneDataAttributeList(Bytes5);
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute dWidth(5) with type INTEGER
{Term5,Bytes7} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V3@V0:10,V3@Buf1/bitstring>> = Bytes6,
V3@Add2 = V3@V0 + -512,
{V3@Add2,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute dElevation(6) with type INTEGER
{Term6,Bytes8} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V4@V0:10,V4@Buf1/bitstring>> = Bytes7,
V4@Add2 = V4@V0 + -512,
{V4@Add2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute regional(7) with type SEQUENCE OF
{Term7,Bytes9} = case Opt band 1 of
1 ->
dec_NodeAttributeSetXY_regional(Bytes8);
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% Extensions
{Extensions,Bytes10} = case Ext of
0 -> {<<>>,Bytes9};
1 ->
{V5@V0,V5@Buf1} = case Bytes9 of
<<0:1,V5@V3:6,V5@Buf4/bitstring>> ->
V5@Add5 = V5@V3 + 1,
{V5@Add5,V5@Buf4};
<<1:1,V5@Buf2/bitstring>> ->
{V5@V3,V5@Buf4} = case V5@Buf2 of
<<0:1,V5@V6:7,V5@Buf7/bitstring>> when V5@V6 =/= 0 ->
{V5@V6,V5@Buf7};
<<1:1,0:1,V5@V7:14,V5@Buf8/bitstring>> when V5@V7 =/= 0 ->
{V5@V7,V5@Buf8}
end,
{V5@V3,V5@Buf4}
end,
<<V5@V9:V5@V0/bitstring-unit:1,V5@Buf10/bitstring>> = V5@Buf1,
{V5@V9,V5@Buf10}
end,
Bytes11= skipextensions(Bytes10, 1, Extensions),
Res1 = #{},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{localNode=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{disabled=>Term2}
end,
Res4 = case Term3 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{enabled=>Term3}
end,
Res5 = case Term4 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{data=>Term4}
end,
Res6 = case Term5 of
  asn1_NOVALUE -> Res5;
  _ -> Res5#{dWidth=>Term5}
end,
Res7 = case Term6 of
  asn1_NOVALUE -> Res6;
  _ -> Res6#{dElevation=>Term6}
end,
Res8 = case Term7 of
  asn1_NOVALUE -> Res7;
  _ -> Res7#{regional=>Term7}
end,
{Res8,Bytes11}.


dec_NodeAttributeSetXY_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components86(V1@Add2, V1@Buf1, []).


dec_NodeAttributeSetXY_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_NodeAttributeXYList(Val) ->
Enc2@len = length(Val),
Enc2@len@sub = Enc2@len - 1,
if Enc2@len@sub bsr 3 =:= 0 ->
[<<Enc2@len@sub:3>>|[if Comp =:= reserved ->
<<0:1,0:4>>;
Comp =:= stopLine ->
<<0:1,1:4>>;
Comp =:= roundedCapStyleA ->
<<0:1,2:4>>;
Comp =:= roundedCapStyleB ->
<<0:1,3:4>>;
Comp =:= mergePoint ->
<<0:1,4:4>>;
Comp =:= divergePoint ->
<<0:1,5:4>>;
Comp =:= downstreamStopLine ->
<<0:1,6:4>>;
Comp =:= downstreamStartNode ->
<<0:1,7:4>>;
Comp =:= closedToTraffic ->
<<0:1,8:4>>;
Comp =:= safeIsland ->
<<0:1,9:4>>;
Comp =:= curbPresentAtStepOff ->
<<0:1,10:4>>;
Comp =:= hydrantPresent ->
<<0:1,11:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Comp}}})
end || Comp <- Val]]
end.



dec_NodeAttributeXYList(Bytes) ->
%% Length with constraint {1,8}
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components87(V1@Add2, V1@Buf1, []).

enc_NodeListLL(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= nodes ->
[<<0:1>>|enc_NodeSetLL(ChoiceVal)]
end.


dec_NodeListLL(Bytes) ->
case Bytes of
<<0:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
ignore,
{0,Bytes1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
dec_NodeSetLL(Bytes2)
end,
{{nodes,Val},NewBytes}
end;

<<1:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
{V1@V0,V1@Buf1} = case Bytes1 of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> when V1@V6 =/= 0 ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
{V1@V7,V1@Buf8}
end,
<<V1@V9:V1@V3/unit:8,V1@Buf10/bitstring>> = V1@Buf4,
{V1@V9,V1@Buf10}
end,
{V1@V0,V1@Buf1}
end,
begin
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end
end,
case Choice of
_ ->
{{asn1_ExtAlt,V2@V0},V2@Buf1}
end
end.
enc_NodeListXY(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= nodes ->
[<<0:1,0:1>>|enc_NodeSetXY(ChoiceVal)];
ChoiceTag =:= computed ->
[<<0:1,1:1>>|enc_ComputedLane(ChoiceVal)]
end.


dec_NodeListXY(Bytes) ->
case Bytes of
<<0:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes1,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
dec_NodeSetXY(Bytes2)
end,
{{nodes,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
dec_ComputedLane(Bytes2)
end,
{{computed,Val},NewBytes}
end;

<<1:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
{V1@V0,V1@Buf1} = case Bytes1 of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> when V1@V6 =/= 0 ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
{V1@V7,V1@Buf8}
end,
<<V1@V9:V1@V3/unit:8,V1@Buf10/bitstring>> = V1@Buf4,
{V1@V9,V1@Buf10}
end,
{V1@V0,V1@Buf1}
end,
begin
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end
end,
case Choice of
_ ->
{{asn1_ExtAlt,V2@V0},V2@Buf1}
end
end.
enc_NodeLL(Val) ->
#{delta:=Input@1} = Val,
Input@2 = case Val of
  #{attributes:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end,
begin
%% attribute delta(1) with type NodeOffsetPointLL
enc_NodeOffsetPointLL(Input@1)
end|begin
%% attribute attributes(2) with type NodeAttributeSetLL
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_NodeAttributeSetLL(Input@2)
end
end].


dec_NodeLL(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:1,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute delta(1) with type NodeOffsetPointLL
{Term1,Bytes3} = dec_NodeOffsetPointLL(Bytes2),

%% attribute attributes(2) with type NodeAttributeSetLL
{Term2,Bytes4} = case Opt band 1 of
1 ->
dec_NodeAttributeSetLL(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V3@V0,V3@Buf1} = case Bytes4 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V9:V3@V0/bitstring-unit:1,V3@Buf10/bitstring>> = V3@Buf1,
{V3@V9,V3@Buf10}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = #{delta=>Term1},
Res2 = case Term2 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{attributes=>Term2}
end,
{Res2,Bytes6}.

enc_NodeOffsetPointLL(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= 'node-LL1' ->
[<<0:3>>|'enc_Node-LL-24B'(ChoiceVal)];
ChoiceTag =:= 'node-LL2' ->
[<<1:3>>|'enc_Node-LL-28B'(ChoiceVal)];
ChoiceTag =:= 'node-LL3' ->
[<<2:3>>|'enc_Node-LL-32B'(ChoiceVal)];
ChoiceTag =:= 'node-LL4' ->
[<<3:3>>|'enc_Node-LL-36B'(ChoiceVal)];
ChoiceTag =:= 'node-LL5' ->
[<<4:3>>|'enc_Node-LL-44B'(ChoiceVal)];
ChoiceTag =:= 'node-LL6' ->
[<<5:3>>|'enc_Node-LL-48B'(ChoiceVal)];
ChoiceTag =:= 'node-LatLon' ->
[<<6:3>>|'enc_Node-LLmD-64b'(ChoiceVal)];
ChoiceTag =:= regional ->
[<<7:3>>|enc_NodeOffsetPointLL_regional(ChoiceVal)]
end.
enc_NodeOffsetPointLL_regional(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_NodeOffsetPointLL(Bytes) ->
{Choice,Bytes1} = 
begin
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
'dec_Node-LL-24B'(Bytes1)
end,
{{'node-LL1',Val},NewBytes};
1 ->
{Val,NewBytes} = begin
'dec_Node-LL-28B'(Bytes1)
end,
{{'node-LL2',Val},NewBytes};
2 ->
{Val,NewBytes} = begin
'dec_Node-LL-32B'(Bytes1)
end,
{{'node-LL3',Val},NewBytes};
3 ->
{Val,NewBytes} = begin
'dec_Node-LL-36B'(Bytes1)
end,
{{'node-LL4',Val},NewBytes};
4 ->
{Val,NewBytes} = begin
'dec_Node-LL-44B'(Bytes1)
end,
{{'node-LL5',Val},NewBytes};
5 ->
{Val,NewBytes} = begin
'dec_Node-LL-48B'(Bytes1)
end,
{{'node-LL6',Val},NewBytes};
6 ->
{Val,NewBytes} = begin
'dec_Node-LLmD-64b'(Bytes1)
end,
{{'node-LatLon',Val},NewBytes};
7 ->
{Val,NewBytes} = begin
dec_NodeOffsetPointLL_regional(Bytes1)
end,
{{regional,Val},NewBytes}
end.

dec_NodeOffsetPointLL_regional(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_NodeOffsetPointXY(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= 'node-XY1' ->
[<<0:3>>|'enc_Node-XY-20b'(ChoiceVal)];
ChoiceTag =:= 'node-XY2' ->
[<<1:3>>|'enc_Node-XY-22b'(ChoiceVal)];
ChoiceTag =:= 'node-XY3' ->
[<<2:3>>|'enc_Node-XY-24b'(ChoiceVal)];
ChoiceTag =:= 'node-XY4' ->
[<<3:3>>|'enc_Node-XY-26b'(ChoiceVal)];
ChoiceTag =:= 'node-XY5' ->
[<<4:3>>|'enc_Node-XY-28b'(ChoiceVal)];
ChoiceTag =:= 'node-XY6' ->
[<<5:3>>|'enc_Node-XY-32b'(ChoiceVal)];
ChoiceTag =:= 'node-LatLon' ->
[<<6:3>>|'enc_Node-LLmD-64b'(ChoiceVal)];
ChoiceTag =:= regional ->
[<<7:3>>|enc_NodeOffsetPointXY_regional(ChoiceVal)]
end.
enc_NodeOffsetPointXY_regional(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type88(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_NodeOffsetPointXY(Bytes) ->
{Choice,Bytes1} = 
begin
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
'dec_Node-XY-20b'(Bytes1)
end,
{{'node-XY1',Val},NewBytes};
1 ->
{Val,NewBytes} = begin
'dec_Node-XY-22b'(Bytes1)
end,
{{'node-XY2',Val},NewBytes};
2 ->
{Val,NewBytes} = begin
'dec_Node-XY-24b'(Bytes1)
end,
{{'node-XY3',Val},NewBytes};
3 ->
{Val,NewBytes} = begin
'dec_Node-XY-26b'(Bytes1)
end,
{{'node-XY4',Val},NewBytes};
4 ->
{Val,NewBytes} = begin
'dec_Node-XY-28b'(Bytes1)
end,
{{'node-XY5',Val},NewBytes};
5 ->
{Val,NewBytes} = begin
'dec_Node-XY-32b'(Bytes1)
end,
{{'node-XY6',Val},NewBytes};
6 ->
{Val,NewBytes} = begin
'dec_Node-LLmD-64b'(Bytes1)
end,
{{'node-LatLon',Val},NewBytes};
7 ->
{Val,NewBytes} = begin
dec_NodeOffsetPointXY_regional(Bytes1)
end,
{{regional,Val},NewBytes}
end.

dec_NodeOffsetPointXY_regional(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type89(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_NodeSetLL(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 2,
if 0 =< Enc1@len@sub, Enc1@len@sub < 62 ->
[<<Enc1@len@sub:6>>|[enc_NodeLL(Comp) || Comp <- Val]]
end.



dec_NodeSetLL(Bytes) ->
%% Length with constraint {2,63}
<<V1@V0:6,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 2,
dec_components90(V1@Add2, V1@Buf1, []).

enc_NodeSetXY(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 2,
if 0 =< Enc1@len@sub, Enc1@len@sub < 62 ->
[<<Enc1@len@sub:6>>|[enc_NodeXY(Comp) || Comp <- Val]]
end.



dec_NodeSetXY(Bytes) ->
%% Length with constraint {2,63}
<<V1@V0:6,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 2,
dec_components91(V1@Add2, V1@Buf1, []).

enc_NodeXY(Val) ->
#{delta:=Input@1} = Val,
Input@2 = case Val of
  #{attributes:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end,
begin
%% attribute delta(1) with type NodeOffsetPointXY
enc_NodeOffsetPointXY(Input@1)
end|begin
%% attribute attributes(2) with type NodeAttributeSetXY
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_NodeAttributeSetXY(Input@2)
end
end].


dec_NodeXY(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:1,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute delta(1) with type NodeOffsetPointXY
{Term1,Bytes3} = dec_NodeOffsetPointXY(Bytes2),

%% attribute attributes(2) with type NodeAttributeSetXY
{Term2,Bytes4} = case Opt band 1 of
1 ->
dec_NodeAttributeSetXY(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V3@V0,V3@Buf1} = case Bytes4 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V9:V3@V0/bitstring-unit:1,V3@Buf10/bitstring>> = V3@Buf1,
{V3@V9,V3@Buf10}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = #{delta=>Term1},
Res2 = case Term2 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{attributes=>Term2}
end,
{Res2,Bytes6}.

enc_ObstacleDetection(Val) ->
#{obDist:=Input@1,obDirect:=Input@2,dateTime:=Input@5} = Val,
Input@3 = case Val of
  #{description:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{locationDetails:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@6 = case Val of
  #{vertEvent:=Input@6_0} -> Input@6_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@3 =:= asn1__MISSING_IN_MAP ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<0:1>>;
true ->
<<1:1>>
end,
begin
%% attribute obDist(1) with type INTEGER
if Input@1 bsr 15 =:= 0 ->
<<Input@1:15>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute obDirect(2) with type INTEGER
if 0 =< Input@2, Input@2 < 28801 ->
<<Input@2:15>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end,
begin
%% attribute description(3) with type INTEGER
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
Input@3 bsr 16 =:= 0 ->
<<Input@3:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end,
begin
%% attribute locationDetails(4) with type ENUMERATED
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
Input@4 =:= 'on-bridges' ->
<<0:1,0:7>>;
Input@4 =:= 'in-tunnels' ->
<<0:1,1:7>>;
Input@4 =:= 'entering-or-leaving-tunnels' ->
<<0:1,2:7>>;
Input@4 =:= 'on-ramps' ->
<<0:1,3:7>>;
Input@4 =:= 'in-road-construction-area' ->
<<0:1,4:7>>;
Input@4 =:= 'around-a-curve' ->
<<0:1,5:7>>;
Input@4 =:= 'on-minor-roads' ->
<<0:1,6:7>>;
Input@4 =:= 'in-the-opposing-lanes' ->
<<0:1,7:7>>;
Input@4 =:= 'adjacent-to-roadway' ->
<<0:1,8:7>>;
Input@4 =:= 'on-bend' ->
<<0:1,9:7>>;
Input@4 =:= 'entire-intersection' ->
<<0:1,10:7>>;
Input@4 =:= 'in-the-median' ->
<<0:1,11:7>>;
Input@4 =:= 'moved-to-side-of-road' ->
<<0:1,12:7>>;
Input@4 =:= 'moved-to-shoulder' ->
<<0:1,13:7>>;
Input@4 =:= 'on-the-roadway' ->
<<0:1,14:7>>;
Input@4 =:= 'in-shaded-areas' ->
<<0:1,15:7>>;
Input@4 =:= 'in-low-lying-areas' ->
<<0:1,16:7>>;
Input@4 =:= 'in-the-downtown-area' ->
<<0:1,17:7>>;
Input@4 =:= 'in-the-inner-city-area' ->
<<0:1,18:7>>;
Input@4 =:= 'in-parts' ->
<<0:1,19:7>>;
Input@4 =:= 'in-some-places' ->
<<0:1,20:7>>;
Input@4 =:= 'in-the-ditch' ->
<<0:1,21:7>>;
Input@4 =:= 'in-the-valley' ->
<<0:1,22:7>>;
Input@4 =:= 'on-hill-top' ->
<<0:1,23:7>>;
Input@4 =:= 'near-the-foothills' ->
<<0:1,24:7>>;
Input@4 =:= 'at-high-altitudes' ->
<<0:1,25:7>>;
Input@4 =:= 'near-the-lake' ->
<<0:1,26:7>>;
Input@4 =:= 'near-the-shore' ->
<<0:1,27:7>>;
Input@4 =:= 'over-the-crest-of-a-hill' ->
<<0:1,28:7>>;
Input@4 =:= 'other-than-on-the-roadway' ->
<<0:1,29:7>>;
Input@4 =:= 'near-the-beach' ->
<<0:1,30:7>>;
Input@4 =:= 'near-beach-access-point' ->
<<0:1,31:7>>;
Input@4 =:= 'lower-level' ->
<<0:1,32:7>>;
Input@4 =:= 'upper-level' ->
<<0:1,33:7>>;
Input@4 =:= airport ->
<<0:1,34:7>>;
Input@4 =:= concourse ->
<<0:1,35:7>>;
Input@4 =:= gate ->
<<0:1,36:7>>;
Input@4 =:= 'baggage-claim' ->
<<0:1,37:7>>;
Input@4 =:= 'customs-point' ->
<<0:1,38:7>>;
Input@4 =:= station ->
<<0:1,39:7>>;
Input@4 =:= platform ->
<<0:1,40:7>>;
Input@4 =:= dock ->
<<0:1,41:7>>;
Input@4 =:= depot ->
<<0:1,42:7>>;
Input@4 =:= 'ev-charging-point' ->
<<0:1,43:7>>;
Input@4 =:= 'information-welcome-point' ->
<<0:1,44:7>>;
Input@4 =:= 'at-rest-area' ->
<<0:1,45:7>>;
Input@4 =:= 'at-service-area' ->
<<0:1,46:7>>;
Input@4 =:= 'at-weigh-station' ->
<<0:1,47:7>>;
Input@4 =:= 'picnic-areas' ->
<<0:1,48:7>>;
Input@4 =:= 'rest-area' ->
<<0:1,49:7>>;
Input@4 =:= 'service-stations' ->
<<0:1,50:7>>;
Input@4 =:= toilets ->
<<0:1,51:7>>;
Input@4 =:= 'on-the-right' ->
<<0:1,52:7>>;
Input@4 =:= 'on-the-left' ->
<<0:1,53:7>>;
Input@4 =:= 'in-the-center' ->
<<0:1,54:7>>;
Input@4 =:= 'in-the-opposite-direction' ->
<<0:1,55:7>>;
Input@4 =:= 'cross-traffic' ->
<<0:1,56:7>>;
Input@4 =:= 'northbound-traffic' ->
<<0:1,57:7>>;
Input@4 =:= 'eastbound-traffic' ->
<<0:1,58:7>>;
Input@4 =:= 'southbound-traffic' ->
<<0:1,59:7>>;
Input@4 =:= 'westbound-traffic' ->
<<0:1,60:7>>;
Input@4 =:= north ->
<<0:1,61:7>>;
Input@4 =:= south ->
<<0:1,62:7>>;
Input@4 =:= east ->
<<0:1,63:7>>;
Input@4 =:= west ->
<<0:1,64:7>>;
Input@4 =:= northeast ->
<<0:1,65:7>>;
Input@4 =:= northwest ->
<<0:1,66:7>>;
Input@4 =:= southeast ->
<<0:1,67:7>>;
Input@4 =:= southwest ->
<<0:1,68:7>>;
Input@4 =:= 'mountain-pass' ->
<<0:1,69:7>>;
Input@4 =:= 'reservation-center' ->
<<0:1,70:7>>;
Input@4 =:= 'nearby-basin' ->
<<0:1,71:7>>;
Input@4 =:= 'on-tracks' ->
<<0:1,72:7>>;
Input@4 =:= dip ->
<<0:1,73:7>>;
Input@4 =:= 'traffic-circle' ->
<<0:1,74:7>>;
Input@4 =:= 'park-and-ride-lot' ->
<<0:1,75:7>>;
Input@4 =:= to ->
<<0:1,76:7>>;
Input@4 =:= by ->
<<0:1,77:7>>;
Input@4 =:= through ->
<<0:1,78:7>>;
Input@4 =:= 'area-of' ->
<<0:1,79:7>>;
Input@4 =:= under ->
<<0:1,80:7>>;
Input@4 =:= over ->
<<0:1,81:7>>;
Input@4 =:= from ->
<<0:1,82:7>>;
Input@4 =:= approaching ->
<<0:1,83:7>>;
Input@4 =:= 'entering-at' ->
<<0:1,84:7>>;
Input@4 =:= 'exiting-at' ->
<<0:1,85:7>>;
Input@4 =:= 'across-tracks' ->
<<0:1,86:7>>;
Input@4 =:= 'in-street' ->
<<0:1,87:7>>;
Input@4 =:= 'on-curve' ->
<<0:1,88:7>>;
Input@4 =:= shoulder ->
<<0:1,89:7>>;
Input@4 =:= crossover ->
<<0:1,90:7>>;
Input@4 =:= 'cross-road' ->
<<0:1,91:7>>;
Input@4 =:= 'side-road' ->
<<0:1,92:7>>;
Input@4 =:= 'bus-stop' ->
<<0:1,93:7>>;
Input@4 =:= intersection ->
<<0:1,94:7>>;
Input@4 =:= 'roadside-park' ->
<<0:1,95:7>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@4}}})
end
end,
begin
%% attribute dateTime(5) with type DDateTime
enc_DDateTime(Input@5)
end|begin
%% attribute vertEvent(6) with type BIT STRING
if Input@6 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Enc8@bs = try bit_string_name2pos_92(Input@6) of
Enc8@positions ->
bitstring_from_positions(Enc8@positions, 5)
catch throw:invalid ->
adjust_trailing_zeroes(Input@6, 5)
end,
Enc8@bits = bit_size(Enc8@bs),
if Enc8@bits =:= 5 ->
Enc8@bs
end
end
end
end].


dec_ObstacleDetection(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:3,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute obDist(1) with type INTEGER
{Term1,Bytes3} = begin
<<V3@V0:15,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute obDirect(2) with type INTEGER
{Term2,Bytes4} = begin
<<V4@V0:15,V4@Buf1/bitstring>> = Bytes3,
{V4@V0,V4@Buf1}
end,

%% attribute description(3) with type INTEGER
{Term3,Bytes5} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V5@V0:16,V5@Buf1/bitstring>> = Bytes4,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute locationDetails(4) with type ENUMERATED
{Term4,Bytes6} = case (Opt bsr 1) band 1 of
1 ->
begin
{V6@V0,V6@Buf1} = case Bytes5 of
<<0:1,V6@V3:7,V6@Buf4/bitstring>> ->
V6@Int5 = case V6@V3 of
0 -> 'on-bridges';
1 -> 'in-tunnels';
2 -> 'entering-or-leaving-tunnels';
3 -> 'on-ramps';
4 -> 'in-road-construction-area';
5 -> 'around-a-curve';
6 -> 'on-minor-roads';
7 -> 'in-the-opposing-lanes';
8 -> 'adjacent-to-roadway';
9 -> 'on-bend';
10 -> 'entire-intersection';
11 -> 'in-the-median';
12 -> 'moved-to-side-of-road';
13 -> 'moved-to-shoulder';
14 -> 'on-the-roadway';
15 -> 'in-shaded-areas';
16 -> 'in-low-lying-areas';
17 -> 'in-the-downtown-area';
18 -> 'in-the-inner-city-area';
19 -> 'in-parts';
20 -> 'in-some-places';
21 -> 'in-the-ditch';
22 -> 'in-the-valley';
23 -> 'on-hill-top';
24 -> 'near-the-foothills';
25 -> 'at-high-altitudes';
26 -> 'near-the-lake';
27 -> 'near-the-shore';
28 -> 'over-the-crest-of-a-hill';
29 -> 'other-than-on-the-roadway';
30 -> 'near-the-beach';
31 -> 'near-beach-access-point';
32 -> 'lower-level';
33 -> 'upper-level';
34 -> airport;
35 -> concourse;
36 -> gate;
37 -> 'baggage-claim';
38 -> 'customs-point';
39 -> station;
40 -> platform;
41 -> dock;
42 -> depot;
43 -> 'ev-charging-point';
44 -> 'information-welcome-point';
45 -> 'at-rest-area';
46 -> 'at-service-area';
47 -> 'at-weigh-station';
48 -> 'picnic-areas';
49 -> 'rest-area';
50 -> 'service-stations';
51 -> toilets;
52 -> 'on-the-right';
53 -> 'on-the-left';
54 -> 'in-the-center';
55 -> 'in-the-opposite-direction';
56 -> 'cross-traffic';
57 -> 'northbound-traffic';
58 -> 'eastbound-traffic';
59 -> 'southbound-traffic';
60 -> 'westbound-traffic';
61 -> north;
62 -> south;
63 -> east;
64 -> west;
65 -> northeast;
66 -> northwest;
67 -> southeast;
68 -> southwest;
69 -> 'mountain-pass';
70 -> 'reservation-center';
71 -> 'nearby-basin';
72 -> 'on-tracks';
73 -> dip;
74 -> 'traffic-circle';
75 -> 'park-and-ride-lot';
76 -> to;
77 -> by;
78 -> through;
79 -> 'area-of';
80 -> under;
81 -> over;
82 -> from;
83 -> approaching;
84 -> 'entering-at';
85 -> 'exiting-at';
86 -> 'across-tracks';
87 -> 'in-street';
88 -> 'on-curve';
89 -> shoulder;
90 -> crossover;
91 -> 'cross-road';
92 -> 'side-road';
93 -> 'bus-stop';
94 -> intersection;
95 -> 'roadside-park';
_ -> exit({error,{asn1,{decode_enumerated,V6@V3}}})
end,
{V6@Int5,V6@Buf4};
<<1:1,V6@Buf2/bitstring>> ->
{V6@V3,V6@Buf4} = case V6@Buf2 of
<<0:1,V6@V6:6,V6@Buf7/bitstring>> ->
{V6@V6,V6@Buf7};
<<1:1,V6@Buf5/bitstring>> ->
{V6@V6,V6@Buf7} = case V6@Buf5 of
<<0:1,V6@V9:7,V6@Buf10/bitstring>> when V6@V9 =/= 0 ->
{V6@V9,V6@Buf10};
<<1:1,0:1,V6@V10:14,V6@Buf11/bitstring>> when V6@V10 =/= 0 ->
{V6@V10,V6@Buf11}
end,
<<V6@V12:V6@V6/unit:8,V6@Buf13/bitstring>> = V6@Buf7,
{V6@V12,V6@Buf13}
end,
V6@Int14 = case V6@V3 of
_ -> {asn1_enum,V6@V3}
end,
{V6@Int14,V6@Buf4}
end,
{V6@V0,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute dateTime(5) with type DDateTime
{Term5,Bytes7} = dec_DDateTime(Bytes6),

%% attribute vertEvent(6) with type BIT STRING
{Term6,Bytes8} = case Opt band 1 of
1 ->
begin
<<V7@V0:5/binary-unit:1,V7@Buf1/bitstring>> = Bytes7,
{V7@V2,V7@Buf3}  = {decode_named_bit_string(V7@V0, [{notEquipped,0},{leftFront,1},{leftRear,2},{rightFront,3},{rightRear,4}]),V7@Buf1},
{V7@V2,V7@Buf3}
end;
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% Extensions
{Extensions,Bytes9} = case Ext of
0 -> {<<>>,Bytes8};
1 ->
{V8@V0,V8@Buf1} = case Bytes8 of
<<0:1,V8@V3:6,V8@Buf4/bitstring>> ->
V8@Add5 = V8@V3 + 1,
{V8@Add5,V8@Buf4};
<<1:1,V8@Buf2/bitstring>> ->
{V8@V3,V8@Buf4} = case V8@Buf2 of
<<0:1,V8@V6:7,V8@Buf7/bitstring>> when V8@V6 =/= 0 ->
{V8@V6,V8@Buf7};
<<1:1,0:1,V8@V7:14,V8@Buf8/bitstring>> when V8@V7 =/= 0 ->
{V8@V7,V8@Buf8}
end,
{V8@V3,V8@Buf4}
end,
<<V8@V9:V8@V0/bitstring-unit:1,V8@Buf10/bitstring>> = V8@Buf1,
{V8@V9,V8@Buf10}
end,
Bytes10= skipextensions(Bytes9, 1, Extensions),
Res1 = #{obDist=>Term1,obDirect=>Term2,dateTime=>Term5},
Res2 = case Term3 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{description=>Term3}
end,
Res3 = case Term4 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{locationDetails=>Term4}
end,
Res4 = case Term6 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{vertEvent=>Term6}
end,
{Res4,Bytes10}.

enc_OffsetSystem(Val) ->
#{offset:=Input@2} = Val,
Input@1 = case Val of
  #{scale:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
<<0:1>>;
true ->
<<1:1>>
end,
begin
%% attribute scale(1) with type INTEGER
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
Input@1 bsr 4 =:= 0 ->
<<Input@1:4>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute offset(2) with type CHOICE
enc_OffsetSystem_offset(Input@2)
end].
enc_OffsetSystem_offset(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= xy ->
[<<0:1>>|enc_NodeListXY(ChoiceVal)];
ChoiceTag =:= ll ->
[<<1:1>>|enc_NodeListLL(ChoiceVal)]
end.


dec_OffsetSystem(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute scale(1) with type INTEGER
{Term1,Bytes2} = case Opt band 1 of
1 ->
begin
<<V2@V0:4,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes1}
end,

%% attribute offset(2) with type CHOICE
{Term2,Bytes3} = dec_OffsetSystem_offset(Bytes2),
Res1 = #{offset=>Term2},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{scale=>Term1}
end,
{Res2,Bytes3}.


dec_OffsetSystem_offset(Bytes) ->
{Choice,Bytes1} = 
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
dec_NodeListXY(Bytes1)
end,
{{xy,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
dec_NodeListLL(Bytes1)
end,
{{ll,Val},NewBytes}
end.
enc_OverlayLaneList(Val) ->
Enc2@len = length(Val),
Enc2@len@sub = Enc2@len - 1,
if 0 =< Enc2@len@sub, Enc2@len@sub < 5 ->
[<<Enc2@len@sub:3>>|[if Comp bsr 8 =:= 0 ->
[Comp];
true ->
exit({error,{asn1,{illegal_integer,Comp}}})
end || Comp <- Val]]
end.



dec_OverlayLaneList(Bytes) ->
%% Length with constraint {1,5}
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components93(V1@Add2, V1@Buf1, []).

enc_PathHistory(Val) ->
#{crumbData:=Input@3} = Val,
Input@1 = case Val of
  #{initialPosition:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{currGNSSstatus:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
begin
%% attribute initialPosition(1) with type FullPositionVector
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_FullPositionVector(Input@1)
end
end,
begin
%% attribute currGNSSstatus(2) with type BIT STRING
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Enc3@bs = try bit_string_name2pos_94(Input@2) of
Enc3@positions ->
bitstring_from_positions(Enc3@positions, 8)
catch throw:invalid ->
adjust_trailing_zeroes(Input@2, 8)
end,
Enc3@bits = bit_size(Enc3@bs),
if Enc3@bits =:= 8 ->
Enc3@bs
end
end
end
end|begin
%% attribute crumbData(3) with type PathHistoryPointList
enc_PathHistoryPointList(Input@3)
end].


dec_PathHistory(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute initialPosition(1) with type FullPositionVector
{Term1,Bytes3} = case (Opt bsr 1) band 1 of
1 ->
dec_FullPositionVector(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute currGNSSstatus(2) with type BIT STRING
{Term2,Bytes4} = case Opt band 1 of
1 ->
begin
<<V3@V0:8/binary-unit:1,V3@Buf1/bitstring>> = Bytes3,
{V3@V2,V3@Buf3}  = {decode_named_bit_string(V3@V0, [{unavailable,0},{isHealthy,1},{isMonitored,2},{baseStationType,3},{aPDOPofUnder5,4},{inViewOfUnder5,5},{localCorrectionsPresent,6},{networkCorrectionsPresent,7}]),V3@Buf1},
{V3@V2,V3@Buf3}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute crumbData(3) with type PathHistoryPointList
{Term3,Bytes5} = dec_PathHistoryPointList(Bytes4),

%% Extensions
{Extensions,Bytes6} = case Ext of
0 -> {<<>>,Bytes5};
1 ->
{V4@V0,V4@Buf1} = case Bytes5 of
<<0:1,V4@V3:6,V4@Buf4/bitstring>> ->
V4@Add5 = V4@V3 + 1,
{V4@Add5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:7,V4@Buf7/bitstring>> when V4@V6 =/= 0 ->
{V4@V6,V4@Buf7};
<<1:1,0:1,V4@V7:14,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
{V4@V7,V4@Buf8}
end,
{V4@V3,V4@Buf4}
end,
<<V4@V9:V4@V0/bitstring-unit:1,V4@Buf10/bitstring>> = V4@Buf1,
{V4@V9,V4@Buf10}
end,
Bytes7= skipextensions(Bytes6, 1, Extensions),
Res1 = #{crumbData=>Term3},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{initialPosition=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{currGNSSstatus=>Term2}
end,
{Res3,Bytes7}.

enc_PathHistoryPointList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if 0 =< Enc1@len@sub, Enc1@len@sub < 23 ->
[<<Enc1@len@sub:5>>|[enc_PathHistoryPoint(Comp) || Comp <- Val]]
end.



dec_PathHistoryPointList(Bytes) ->
%% Length with constraint {1,23}
<<V1@V0:5,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components95(V1@Add2, V1@Buf1, []).

enc_PathHistoryPoint(Val) ->
#{latOffset:=Input@1,lonOffset:=Input@2,elevationOffset:=Input@3,timeOffset:=Input@4} = Val,
Input@5 = case Val of
  #{speed:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@6 = case Val of
  #{posAccuracy:=Input@6_0} -> Input@6_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@7 = case Val of
  #{heading:=Input@7_0} -> Input@7_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@5 =:= asn1__MISSING_IN_MAP ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@7 =:= asn1__MISSING_IN_MAP ->
<<0:1>>;
true ->
<<1:1>>
end,
begin
%% attribute latOffset(1) with type INTEGER
Input@1@sub = Input@1 - -131072,
if Input@1@sub bsr 18 =:= 0 ->
<<Input@1@sub:18>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute lonOffset(2) with type INTEGER
Input@2@sub = Input@2 - -131072,
if Input@2@sub bsr 18 =:= 0 ->
<<Input@2@sub:18>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end,
begin
%% attribute elevationOffset(3) with type INTEGER
Input@3@sub = Input@3 - -2048,
if Input@3@sub bsr 12 =:= 0 ->
<<Input@3@sub:12>>;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end,
begin
%% attribute timeOffset(4) with type INTEGER
Input@4@sub = Input@4 - 1,
if 0 =< Input@4@sub, Input@4@sub < 65535 ->
<<Input@4@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@4}}})
end
end,
begin
%% attribute speed(5) with type INTEGER
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
Input@5 bsr 13 =:= 0 ->
<<Input@5:13>>;
true ->
exit({error,{asn1,{illegal_integer,Input@5}}})
end
end,
begin
%% attribute posAccuracy(6) with type PositionalAccuracy
if Input@6 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_PositionalAccuracy(Input@6)
end
end|begin
%% attribute heading(7) with type INTEGER
if Input@7 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@7, Input@7 < 241 ->
[Input@7];
true ->
exit({error,{asn1,{illegal_integer,Input@7}}})
end
end].


dec_PathHistoryPoint(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:3,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute latOffset(1) with type INTEGER
{Term1,Bytes3} = begin
<<V3@V0:18,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + -131072,
{V3@Add2,V3@Buf1}
end,

%% attribute lonOffset(2) with type INTEGER
{Term2,Bytes4} = begin
<<V4@V0:18,V4@Buf1/bitstring>> = Bytes3,
V4@Add2 = V4@V0 + -131072,
{V4@Add2,V4@Buf1}
end,

%% attribute elevationOffset(3) with type INTEGER
{Term3,Bytes5} = begin
<<V5@V0:12,V5@Buf1/bitstring>> = Bytes4,
V5@Add2 = V5@V0 + -2048,
{V5@Add2,V5@Buf1}
end,

%% attribute timeOffset(4) with type INTEGER
{Term4,Bytes6} = begin
<<V6@V0:16,V6@Buf1/bitstring>> = Bytes5,
V6@Add2 = V6@V0 + 1,
{V6@Add2,V6@Buf1}
end,

%% attribute speed(5) with type INTEGER
{Term5,Bytes7} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V7@V0:13,V7@Buf1/bitstring>> = Bytes6,
{V7@V0,V7@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute posAccuracy(6) with type PositionalAccuracy
{Term6,Bytes8} = case (Opt bsr 1) band 1 of
1 ->
dec_PositionalAccuracy(Bytes7);
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute heading(7) with type INTEGER
{Term7,Bytes9} = case Opt band 1 of
1 ->
begin
<<V8@V0:8,V8@Buf1/bitstring>> = Bytes8,
{V8@V0,V8@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% Extensions
{Extensions,Bytes10} = case Ext of
0 -> {<<>>,Bytes9};
1 ->
{V9@V0,V9@Buf1} = case Bytes9 of
<<0:1,V9@V3:6,V9@Buf4/bitstring>> ->
V9@Add5 = V9@V3 + 1,
{V9@Add5,V9@Buf4};
<<1:1,V9@Buf2/bitstring>> ->
{V9@V3,V9@Buf4} = case V9@Buf2 of
<<0:1,V9@V6:7,V9@Buf7/bitstring>> when V9@V6 =/= 0 ->
{V9@V6,V9@Buf7};
<<1:1,0:1,V9@V7:14,V9@Buf8/bitstring>> when V9@V7 =/= 0 ->
{V9@V7,V9@Buf8}
end,
{V9@V3,V9@Buf4}
end,
<<V9@V9:V9@V0/bitstring-unit:1,V9@Buf10/bitstring>> = V9@Buf1,
{V9@V9,V9@Buf10}
end,
Bytes11= skipextensions(Bytes10, 1, Extensions),
Res1 = #{latOffset=>Term1,lonOffset=>Term2,elevationOffset=>Term3,timeOffset=>Term4},
Res2 = case Term5 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{speed=>Term5}
end,
Res3 = case Term6 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{posAccuracy=>Term6}
end,
Res4 = case Term7 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{heading=>Term7}
end,
{Res4,Bytes11}.

enc_PathPrediction(Val) ->
#{radiusOfCurve:=Input@1,confidence:=Input@2} = Val,
[begin
%% attribute radiusOfCurve(1) with type INTEGER
Input@1@sub = Input@1 - -32767,
if 0 =< Input@1@sub, Input@1@sub < 65535 ->
<<0:1,Input@1@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute confidence(2) with type INTEGER
if 0 =< Input@2, Input@2 < 201 ->
[Input@2];
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end].


dec_PathPrediction(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute radiusOfCurve(1) with type INTEGER
{Term1,Bytes2} = begin
<<V2@V0:16,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + -32767,
{V2@Add2,V2@Buf1}
end,

%% attribute confidence(2) with type INTEGER
{Term2,Bytes3} = begin
<<V3@V0:8,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% Extensions
{Extensions,Bytes4} = case Ext of
0 -> {<<>>,Bytes3};
1 ->
{V4@V0,V4@Buf1} = case Bytes3 of
<<0:1,V4@V3:6,V4@Buf4/bitstring>> ->
V4@Add5 = V4@V3 + 1,
{V4@Add5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:7,V4@Buf7/bitstring>> when V4@V6 =/= 0 ->
{V4@V6,V4@Buf7};
<<1:1,0:1,V4@V7:14,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
{V4@V7,V4@Buf8}
end,
{V4@V3,V4@Buf4}
end,
<<V4@V9:V4@V0/bitstring-unit:1,V4@Buf10/bitstring>> = V4@Buf1,
{V4@V9,V4@Buf10}
end,
Bytes5= skipextensions(Bytes4, 1, Extensions),
Res1 = #{radiusOfCurve=>Term1,confidence=>Term2},
{Res1,Bytes5}.

enc_PivotPointDescription(Val) ->
#{pivotOffset:=Input@1,pivotAngle:=Input@2,pivots:=Input@3} = Val,
[begin
%% attribute pivotOffset(1) with type INTEGER
Input@1@sub = Input@1 - -1024,
if Input@1@sub bsr 11 =:= 0 ->
<<0:1,Input@1@sub:11>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute pivotAngle(2) with type INTEGER
if 0 =< Input@2, Input@2 < 28801 ->
<<Input@2:15>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end|begin
%% attribute pivots(3) with type BOOLEAN
if Input@3 =:= false ->
<<0:1>>;
Input@3 =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Input@3}}})
end
end].


dec_PivotPointDescription(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute pivotOffset(1) with type INTEGER
{Term1,Bytes2} = begin
<<V2@V0:11,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + -1024,
{V2@Add2,V2@Buf1}
end,

%% attribute pivotAngle(2) with type INTEGER
{Term2,Bytes3} = begin
<<V3@V0:15,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute pivots(3) with type BOOLEAN
{Term3,Bytes4} = begin
<<V4@V0:1,V4@Buf1/bitstring>> = Bytes3,
V4@Int2 = case V4@V0 of
0 -> false;
1 -> true
end,
{V4@Int2,V4@Buf1}
end,

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V5@V0,V5@Buf1} = case Bytes4 of
<<0:1,V5@V3:6,V5@Buf4/bitstring>> ->
V5@Add5 = V5@V3 + 1,
{V5@Add5,V5@Buf4};
<<1:1,V5@Buf2/bitstring>> ->
{V5@V3,V5@Buf4} = case V5@Buf2 of
<<0:1,V5@V6:7,V5@Buf7/bitstring>> when V5@V6 =/= 0 ->
{V5@V6,V5@Buf7};
<<1:1,0:1,V5@V7:14,V5@Buf8/bitstring>> when V5@V7 =/= 0 ->
{V5@V7,V5@Buf8}
end,
{V5@V3,V5@Buf4}
end,
<<V5@V9:V5@V0/bitstring-unit:1,V5@Buf10/bitstring>> = V5@Buf1,
{V5@V9,V5@Buf10}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = #{pivotOffset=>Term1,pivotAngle=>Term2,pivots=>Term3},
{Res1,Bytes6}.

enc_Position3D(Val) ->
#{lat:=Input@1,long:=Input@2} = Val,
Input@3 = case Val of
  #{elevation:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{regional:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@3 =:= asn1__MISSING_IN_MAP ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
begin
%% attribute lat(1) with type INTEGER
Input@1@sub = Input@1 - -900000000,
if 0 =< Input@1@sub, Input@1@sub < 1800000002 ->
<<Input@1@sub:31>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute long(2) with type INTEGER
Input@2@sub = Input@2 - -1799999999,
if 0 =< Input@2@sub, Input@2@sub < 3600000001 ->
<<Input@2@sub:32>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end,
begin
%% attribute elevation(3) with type INTEGER
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Input@3@sub = Input@3 - -4096,
if Input@3@sub bsr 16 =:= 0 ->
<<Input@3@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end
end
end|begin
%% attribute regional(4) with type SEQUENCE OF
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_Position3D_regional(Input@4)
end
end].
enc_Position3D_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_Position3D_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_Position3D_regional_RegionalExtension(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type96(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_Position3D(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute lat(1) with type INTEGER
{Term1,Bytes3} = begin
<<V3@V0:31,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + -900000000,
{V3@Add2,V3@Buf1}
end,

%% attribute long(2) with type INTEGER
{Term2,Bytes4} = begin
<<V4@V0:32,V4@Buf1/bitstring>> = Bytes3,
V4@Add2 = V4@V0 + -1799999999,
{V4@Add2,V4@Buf1}
end,

%% attribute elevation(3) with type INTEGER
{Term3,Bytes5} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V5@V0:16,V5@Buf1/bitstring>> = Bytes4,
V5@Add2 = V5@V0 + -4096,
{V5@Add2,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute regional(4) with type SEQUENCE OF
{Term4,Bytes6} = case Opt band 1 of
1 ->
dec_Position3D_regional(Bytes5);
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% Extensions
{Extensions,Bytes7} = case Ext of
0 -> {<<>>,Bytes6};
1 ->
{V6@V0,V6@Buf1} = case Bytes6 of
<<0:1,V6@V3:6,V6@Buf4/bitstring>> ->
V6@Add5 = V6@V3 + 1,
{V6@Add5,V6@Buf4};
<<1:1,V6@Buf2/bitstring>> ->
{V6@V3,V6@Buf4} = case V6@Buf2 of
<<0:1,V6@V6:7,V6@Buf7/bitstring>> when V6@V6 =/= 0 ->
{V6@V6,V6@Buf7};
<<1:1,0:1,V6@V7:14,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
{V6@V7,V6@Buf8}
end,
{V6@V3,V6@Buf4}
end,
<<V6@V9:V6@V0/bitstring-unit:1,V6@Buf10/bitstring>> = V6@Buf1,
{V6@V9,V6@Buf10}
end,
Bytes8= skipextensions(Bytes7, 1, Extensions),
Res1 = #{lat=>Term1,long=>Term2},
Res2 = case Term3 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{elevation=>Term3}
end,
Res3 = case Term4 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{regional=>Term4}
end,
{Res3,Bytes8}.


dec_Position3D_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components97(V1@Add2, V1@Buf1, []).


dec_Position3D_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type98(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_PositionalAccuracy(Val) ->
#{semiMajor:=Input@1,semiMinor:=Input@2,orientation:=Input@3} = Val,
[begin
%% attribute semiMajor(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute semiMinor(2) with type INTEGER
if Input@2 bsr 8 =:= 0 ->
Input@2;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end|begin
%% attribute orientation(3) with type INTEGER
if Input@3 bsr 16 =:= 0 ->
<<Input@3:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end].


dec_PositionalAccuracy(Bytes) ->

%% attribute semiMajor(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute semiMinor(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute orientation(3) with type INTEGER
{Term3,Bytes3} = begin
<<V3@V0:16,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,
Res1 = #{semiMajor=>Term1,semiMinor=>Term2,orientation=>Term3},
{Res1,Bytes3}.

enc_PositionConfidenceSet(Val) ->
#{pos:=Input@1,elevation:=Input@2} = Val,
[begin
%% attribute pos(1) with type ENUMERATED
if Input@1 =:= unavailable ->
<<0:4>>;
Input@1 =:= a500m ->
<<1:4>>;
Input@1 =:= a200m ->
<<2:4>>;
Input@1 =:= a100m ->
<<3:4>>;
Input@1 =:= a50m ->
<<4:4>>;
Input@1 =:= a20m ->
<<5:4>>;
Input@1 =:= a10m ->
<<6:4>>;
Input@1 =:= a5m ->
<<7:4>>;
Input@1 =:= a2m ->
<<8:4>>;
Input@1 =:= a1m ->
<<9:4>>;
Input@1 =:= a50cm ->
<<10:4>>;
Input@1 =:= a20cm ->
<<11:4>>;
Input@1 =:= a10cm ->
<<12:4>>;
Input@1 =:= a5cm ->
<<13:4>>;
Input@1 =:= a2cm ->
<<14:4>>;
Input@1 =:= a1cm ->
<<15:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@1}}})
end
end|begin
%% attribute elevation(2) with type ENUMERATED
if Input@2 =:= unavailable ->
<<0:4>>;
Input@2 =:= 'elev-500-00' ->
<<1:4>>;
Input@2 =:= 'elev-200-00' ->
<<2:4>>;
Input@2 =:= 'elev-100-00' ->
<<3:4>>;
Input@2 =:= 'elev-050-00' ->
<<4:4>>;
Input@2 =:= 'elev-020-00' ->
<<5:4>>;
Input@2 =:= 'elev-010-00' ->
<<6:4>>;
Input@2 =:= 'elev-005-00' ->
<<7:4>>;
Input@2 =:= 'elev-002-00' ->
<<8:4>>;
Input@2 =:= 'elev-001-00' ->
<<9:4>>;
Input@2 =:= 'elev-000-50' ->
<<10:4>>;
Input@2 =:= 'elev-000-20' ->
<<11:4>>;
Input@2 =:= 'elev-000-10' ->
<<12:4>>;
Input@2 =:= 'elev-000-05' ->
<<13:4>>;
Input@2 =:= 'elev-000-02' ->
<<14:4>>;
Input@2 =:= 'elev-000-01' ->
<<15:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@2}}})
end
end].


dec_PositionConfidenceSet(Bytes) ->

%% attribute pos(1) with type ENUMERATED
{Term1,Bytes1} = begin
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> unavailable;
1 -> a500m;
2 -> a200m;
3 -> a100m;
4 -> a50m;
5 -> a20m;
6 -> a10m;
7 -> a5m;
8 -> a2m;
9 -> a1m;
10 -> a50cm;
11 -> a20cm;
12 -> a10cm;
13 -> a5cm;
14 -> a2cm;
15 -> a1cm
end,
{V1@Int2,V1@Buf1}
end,

%% attribute elevation(2) with type ENUMERATED
{Term2,Bytes2} = begin
<<V2@V0:4,V2@Buf1/bitstring>> = Bytes1,
V2@Int2 = case V2@V0 of
0 -> unavailable;
1 -> 'elev-500-00';
2 -> 'elev-200-00';
3 -> 'elev-100-00';
4 -> 'elev-050-00';
5 -> 'elev-020-00';
6 -> 'elev-010-00';
7 -> 'elev-005-00';
8 -> 'elev-002-00';
9 -> 'elev-001-00';
10 -> 'elev-000-50';
11 -> 'elev-000-20';
12 -> 'elev-000-10';
13 -> 'elev-000-05';
14 -> 'elev-000-02';
15 -> 'elev-000-01'
end,
{V2@Int2,V2@Buf1}
end,
Res1 = #{pos=>Term1,elevation=>Term2},
{Res1,Bytes2}.

enc_PreemptPriorityList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 5 =:= 0 ->
[<<Enc1@len@sub:5>>|[enc_SignalControlZone(Comp) || Comp <- Val]]
end.



dec_PreemptPriorityList(Bytes) ->
%% Length with constraint {1,32}
<<V1@V0:5,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components99(V1@Add2, V1@Buf1, []).

enc_SignalControlZone(Val) ->
#{zone:=Input@1} = Val,
[<<0:1>>|begin
%% attribute zone(1) with type SEQUENCE
enc_SignalControlZone_zone(Input@1)
end].
enc_SignalControlZone_zone(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_SignalControlZone(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute zone(1) with type SEQUENCE
{Term1,Bytes2} = dec_SignalControlZone_zone(Bytes1),

%% Extensions
{Extensions,Bytes3} = case Ext of
0 -> {<<>>,Bytes2};
1 ->
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:6,V2@Buf4/bitstring>> ->
V2@Add5 = V2@V3 + 1,
{V2@Add5,V2@Buf4};
<<1:1,V2@Buf2/bitstring>> ->
{V2@V3,V2@Buf4} = case V2@Buf2 of
<<0:1,V2@V6:7,V2@Buf7/bitstring>> when V2@V6 =/= 0 ->
{V2@V6,V2@Buf7};
<<1:1,0:1,V2@V7:14,V2@Buf8/bitstring>> when V2@V7 =/= 0 ->
{V2@V7,V2@Buf8}
end,
{V2@V3,V2@Buf4}
end,
<<V2@V9:V2@V0/bitstring-unit:1,V2@Buf10/bitstring>> = V2@Buf1,
{V2@V9,V2@Buf10}
end,
Bytes4= skipextensions(Bytes3, 1, Extensions),
Res1 = #{zone=>Term1},
{Res1,Bytes4}.


dec_SignalControlZone_zone(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_PrivilegedEvents(Val) ->
#{sspRights:=Input@1,event:=Input@2} = Val,
[begin
%% attribute sspRights(1) with type INTEGER
if Input@1 bsr 5 =:= 0 ->
<<0:1,Input@1:5>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute event(2) with type BIT STRING
Enc3@bs = try bit_string_name2pos_100(Input@2) of
Enc3@positions ->
bitstring_from_positions(Enc3@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(Input@2, 16)
end,
Enc3@bits = bit_size(Enc3@bs),
if Enc3@bits =:= 16 ->
Enc3@bs
end
end].


dec_PrivilegedEvents(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute sspRights(1) with type INTEGER
{Term1,Bytes2} = begin
<<V2@V0:5,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute event(2) with type BIT STRING
{Term2,Bytes3} = begin
<<V3@V0:16/binary-unit:1,V3@Buf1/bitstring>> = Bytes2,
{V3@V2,V3@Buf3}  = {decode_named_bit_string(V3@V0, [{peUnavailable,0},{peEmergencyResponse,1},{peEmergencyLightsActive,2},{peEmergencySoundActive,3},{peNonEmergencyLightsActive,4},{peNonEmergencySoundActive,5}]),V3@Buf1},
{V3@V2,V3@Buf3}
end,

%% Extensions
{Extensions,Bytes4} = case Ext of
0 -> {<<>>,Bytes3};
1 ->
{V4@V0,V4@Buf1} = case Bytes3 of
<<0:1,V4@V3:6,V4@Buf4/bitstring>> ->
V4@Add5 = V4@V3 + 1,
{V4@Add5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:7,V4@Buf7/bitstring>> when V4@V6 =/= 0 ->
{V4@V6,V4@Buf7};
<<1:1,0:1,V4@V7:14,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
{V4@V7,V4@Buf8}
end,
{V4@V3,V4@Buf4}
end,
<<V4@V9:V4@V0/bitstring-unit:1,V4@Buf10/bitstring>> = V4@Buf1,
{V4@V9,V4@Buf10}
end,
Bytes5= skipextensions(Bytes4, 1, Extensions),
Res1 = #{sspRights=>Term1,event=>Term2},
{Res1,Bytes5}.

enc_PropelledInformation(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= human ->
if ChoiceVal =:= unavailable ->
<<0:1,0:2,0:1,0:3>>;
ChoiceVal =:= otherTypes ->
<<0:1,0:2,0:1,1:3>>;
ChoiceVal =:= onFoot ->
<<0:1,0:2,0:1,2:3>>;
ChoiceVal =:= skateboard ->
<<0:1,0:2,0:1,3:3>>;
ChoiceVal =:= pushOrKickScooter ->
<<0:1,0:2,0:1,4:3>>;
ChoiceVal =:= wheelchair ->
<<0:1,0:2,0:1,5:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,ChoiceVal}}})
end;
ChoiceTag =:= animal ->
if ChoiceVal =:= unavailable ->
<<0:1,1:2,0:1,0:2>>;
ChoiceVal =:= otherTypes ->
<<0:1,1:2,0:1,1:2>>;
ChoiceVal =:= animalMounted ->
<<0:1,1:2,0:1,2:2>>;
ChoiceVal =:= animalDrawnCarriage ->
<<0:1,1:2,0:1,3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,ChoiceVal}}})
end;
ChoiceTag =:= motor ->
if ChoiceVal =:= unavailable ->
<<0:1,2:2,0:1,0:3>>;
ChoiceVal =:= otherTypes ->
<<0:1,2:2,0:1,1:3>>;
ChoiceVal =:= wheelChair ->
<<0:1,2:2,0:1,2:3>>;
ChoiceVal =:= bicycle ->
<<0:1,2:2,0:1,3:3>>;
ChoiceVal =:= scooter ->
<<0:1,2:2,0:1,4:3>>;
ChoiceVal =:= selfBalancingDevice ->
<<0:1,2:2,0:1,5:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,ChoiceVal}}})
end
end.


dec_PropelledInformation(Bytes) ->
case Bytes of
<<0:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes1,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
begin
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:3,V2@Buf4/bitstring>> ->
V2@Int5 = case V2@V3 of
0 -> unavailable;
1 -> otherTypes;
2 -> onFoot;
3 -> skateboard;
4 -> pushOrKickScooter;
5 -> wheelchair;
_ -> exit({error,{asn1,{decode_enumerated,V2@V3}}})
end,
{V2@Int5,V2@Buf4};
<<1:1,V2@Buf2/bitstring>> ->
{V2@V3,V2@Buf4} = case V2@Buf2 of
<<0:1,V2@V6:6,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7} = case V2@Buf5 of
<<0:1,V2@V9:7,V2@Buf10/bitstring>> when V2@V9 =/= 0 ->
{V2@V9,V2@Buf10};
<<1:1,0:1,V2@V10:14,V2@Buf11/bitstring>> when V2@V10 =/= 0 ->
{V2@V10,V2@Buf11}
end,
<<V2@V12:V2@V6/unit:8,V2@Buf13/bitstring>> = V2@Buf7,
{V2@V12,V2@Buf13}
end,
V2@Int14 = case V2@V3 of
_ -> {asn1_enum,V2@V3}
end,
{V2@Int14,V2@Buf4}
end,
{V2@V0,V2@Buf1}
end
end,
{{human,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
begin
{V3@V0,V3@Buf1} = case Bytes2 of
<<0:1,V3@V3:2,V3@Buf4/bitstring>> ->
V3@Int5 = case V3@V3 of
0 -> unavailable;
1 -> otherTypes;
2 -> animalMounted;
3 -> animalDrawnCarriage
end,
{V3@Int5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:6,V3@Buf7/bitstring>> ->
{V3@V6,V3@Buf7};
<<1:1,V3@Buf5/bitstring>> ->
{V3@V6,V3@Buf7} = case V3@Buf5 of
<<0:1,V3@V9:7,V3@Buf10/bitstring>> when V3@V9 =/= 0 ->
{V3@V9,V3@Buf10};
<<1:1,0:1,V3@V10:14,V3@Buf11/bitstring>> when V3@V10 =/= 0 ->
{V3@V10,V3@Buf11}
end,
<<V3@V12:V3@V6/unit:8,V3@Buf13/bitstring>> = V3@Buf7,
{V3@V12,V3@Buf13}
end,
V3@Int14 = case V3@V3 of
_ -> {asn1_enum,V3@V3}
end,
{V3@Int14,V3@Buf4}
end,
{V3@V0,V3@Buf1}
end
end,
{{animal,Val},NewBytes};
2 ->
{Val,NewBytes} = begin
begin
{V4@V0,V4@Buf1} = case Bytes2 of
<<0:1,V4@V3:3,V4@Buf4/bitstring>> ->
V4@Int5 = case V4@V3 of
0 -> unavailable;
1 -> otherTypes;
2 -> wheelChair;
3 -> bicycle;
4 -> scooter;
5 -> selfBalancingDevice;
_ -> exit({error,{asn1,{decode_enumerated,V4@V3}}})
end,
{V4@Int5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:6,V4@Buf7/bitstring>> ->
{V4@V6,V4@Buf7};
<<1:1,V4@Buf5/bitstring>> ->
{V4@V6,V4@Buf7} = case V4@Buf5 of
<<0:1,V4@V9:7,V4@Buf10/bitstring>> when V4@V9 =/= 0 ->
{V4@V9,V4@Buf10};
<<1:1,0:1,V4@V10:14,V4@Buf11/bitstring>> when V4@V10 =/= 0 ->
{V4@V10,V4@Buf11}
end,
<<V4@V12:V4@V6/unit:8,V4@Buf13/bitstring>> = V4@Buf7,
{V4@V12,V4@Buf13}
end,
V4@Int14 = case V4@V3 of
_ -> {asn1_enum,V4@V3}
end,
{V4@Int14,V4@Buf4}
end,
{V4@V0,V4@Buf1}
end
end,
{{motor,Val},NewBytes}
end;

<<1:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
{V1@V0,V1@Buf1} = case Bytes1 of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> when V1@V6 =/= 0 ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
{V1@V7,V1@Buf8}
end,
<<V1@V9:V1@V3/unit:8,V1@Buf10/bitstring>> = V1@Buf4,
{V1@V9,V1@Buf10}
end,
{V1@V0,V1@Buf1}
end,
begin
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end
end,
case Choice of
_ ->
{{asn1_ExtAlt,V2@V0},V2@Buf1}
end
end.
enc_RegionList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 6 =:= 0 ->
[<<Enc1@len@sub:6>>|[enc_RegionOffsets(Comp) || Comp <- Val]]
end.



dec_RegionList(Bytes) ->
%% Length with constraint {1,64}
<<V1@V0:6,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components101(V1@Add2, V1@Buf1, []).

enc_RegionOffsets(Val) ->
#{xOffset:=Input@1,yOffset:=Input@2} = Val,
Input@3 = case Val of
  #{zOffset:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1>>;
true ->
<<1:1>>
end,
begin
%% attribute xOffset(1) with type INTEGER
Input@1@sub = Input@1 - -32768,
if Input@1@sub bsr 16 =:= 0 ->
<<Input@1@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute yOffset(2) with type INTEGER
Input@2@sub = Input@2 - -32768,
if Input@2@sub bsr 16 =:= 0 ->
<<Input@2@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end|begin
%% attribute zOffset(3) with type INTEGER
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Input@3@sub = Input@3 - -32768,
if Input@3@sub bsr 16 =:= 0 ->
<<Input@3@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end
end
end].


dec_RegionOffsets(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute xOffset(1) with type INTEGER
{Term1,Bytes2} = begin
<<V2@V0:16,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + -32768,
{V2@Add2,V2@Buf1}
end,

%% attribute yOffset(2) with type INTEGER
{Term2,Bytes3} = begin
<<V3@V0:16,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + -32768,
{V3@Add2,V3@Buf1}
end,

%% attribute zOffset(3) with type INTEGER
{Term3,Bytes4} = case Opt band 1 of
1 ->
begin
<<V4@V0:16,V4@Buf1/bitstring>> = Bytes3,
V4@Add2 = V4@V0 + -32768,
{V4@Add2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,
Res1 = #{xOffset=>Term1,yOffset=>Term2},
Res2 = case Term3 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{zOffset=>Term3}
end,
{Res2,Bytes4}.

enc_RegionPointSet(Val) ->
#{nodeList:=Input@3} = Val,
Input@1 = case Val of
  #{anchor:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{scale:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
begin
%% attribute anchor(1) with type Position3D
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_Position3D(Input@1)
end
end,
begin
%% attribute scale(2) with type INTEGER
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
Input@2 bsr 4 =:= 0 ->
<<Input@2:4>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end|begin
%% attribute nodeList(3) with type RegionList
enc_RegionList(Input@3)
end].


dec_RegionPointSet(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute anchor(1) with type Position3D
{Term1,Bytes3} = case (Opt bsr 1) band 1 of
1 ->
dec_Position3D(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute scale(2) with type INTEGER
{Term2,Bytes4} = case Opt band 1 of
1 ->
begin
<<V3@V0:4,V3@Buf1/bitstring>> = Bytes3,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute nodeList(3) with type RegionList
{Term3,Bytes5} = dec_RegionList(Bytes4),

%% Extensions
{Extensions,Bytes6} = case Ext of
0 -> {<<>>,Bytes5};
1 ->
{V4@V0,V4@Buf1} = case Bytes5 of
<<0:1,V4@V3:6,V4@Buf4/bitstring>> ->
V4@Add5 = V4@V3 + 1,
{V4@Add5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:7,V4@Buf7/bitstring>> when V4@V6 =/= 0 ->
{V4@V6,V4@Buf7};
<<1:1,0:1,V4@V7:14,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
{V4@V7,V4@Buf8}
end,
{V4@V3,V4@Buf4}
end,
<<V4@V9:V4@V0/bitstring-unit:1,V4@Buf10/bitstring>> = V4@Buf1,
{V4@V9,V4@Buf10}
end,
Bytes7= skipextensions(Bytes6, 1, Extensions),
Res1 = #{nodeList=>Term3},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{anchor=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{scale=>Term2}
end,
{Res3,Bytes7}.

enc_RegulatorySpeedLimit(Val) ->
#{type:=Input@1,speed:=Input@2} = Val,
[begin
%% attribute type(1) with type ENUMERATED
if Input@1 =:= unknown ->
<<0:1,0:4>>;
Input@1 =:= maxSpeedInSchoolZone ->
<<0:1,1:4>>;
Input@1 =:= maxSpeedInSchoolZoneWhenChildrenArePresent ->
<<0:1,2:4>>;
Input@1 =:= maxSpeedInConstructionZone ->
<<0:1,3:4>>;
Input@1 =:= vehicleMinSpeed ->
<<0:1,4:4>>;
Input@1 =:= vehicleMaxSpeed ->
<<0:1,5:4>>;
Input@1 =:= vehicleNightMaxSpeed ->
<<0:1,6:4>>;
Input@1 =:= truckMinSpeed ->
<<0:1,7:4>>;
Input@1 =:= truckMaxSpeed ->
<<0:1,8:4>>;
Input@1 =:= truckNightMaxSpeed ->
<<0:1,9:4>>;
Input@1 =:= vehiclesWithTrailersMinSpeed ->
<<0:1,10:4>>;
Input@1 =:= vehiclesWithTrailersMaxSpeed ->
<<0:1,11:4>>;
Input@1 =:= vehiclesWithTrailersNightMaxSpeed ->
<<0:1,12:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@1}}})
end
end|begin
%% attribute speed(2) with type INTEGER
if Input@2 bsr 13 =:= 0 ->
<<Input@2:13>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end].


dec_RegulatorySpeedLimit(Bytes) ->

%% attribute type(1) with type ENUMERATED
{Term1,Bytes1} = begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:4,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> unknown;
1 -> maxSpeedInSchoolZone;
2 -> maxSpeedInSchoolZoneWhenChildrenArePresent;
3 -> maxSpeedInConstructionZone;
4 -> vehicleMinSpeed;
5 -> vehicleMaxSpeed;
6 -> vehicleNightMaxSpeed;
7 -> truckMinSpeed;
8 -> truckMaxSpeed;
9 -> truckNightMaxSpeed;
10 -> vehiclesWithTrailersMinSpeed;
11 -> vehiclesWithTrailersMaxSpeed;
12 -> vehiclesWithTrailersNightMaxSpeed;
_ -> exit({error,{asn1,{decode_enumerated,V1@V3}}})
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11}
end,
<<V1@V12:V1@V6/unit:8,V1@Buf13/bitstring>> = V1@Buf7,
{V1@V12,V1@Buf13}
end,
V1@Int14 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int14,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end,

%% attribute speed(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:13,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,
Res1 = #{type=>Term1,speed=>Term2},
{Res1,Bytes2}.

enc_RequestedItemList(Val) ->
Enc2@len = length(Val),
Enc2@len@sub = Enc2@len - 1,
if Enc2@len@sub bsr 5 =:= 0 ->
[<<Enc2@len@sub:5>>|[if Comp =:= reserved ->
<<0:1,0:5>>;
Comp =:= itemA ->
<<0:1,1:5>>;
Comp =:= itemB ->
<<0:1,2:5>>;
Comp =:= itemC ->
<<0:1,3:5>>;
Comp =:= itemD ->
<<0:1,4:5>>;
Comp =:= itemE ->
<<0:1,5:5>>;
Comp =:= itemF ->
<<0:1,6:5>>;
Comp =:= itemG ->
<<0:1,7:5>>;
Comp =:= itemI ->
<<0:1,8:5>>;
Comp =:= itemJ ->
<<0:1,9:5>>;
Comp =:= itemK ->
<<0:1,10:5>>;
Comp =:= itemL ->
<<0:1,11:5>>;
Comp =:= itemM ->
<<0:1,12:5>>;
Comp =:= itemN ->
<<0:1,13:5>>;
Comp =:= itemO ->
<<0:1,14:5>>;
Comp =:= itemP ->
<<0:1,15:5>>;
Comp =:= itemQ ->
<<0:1,16:5>>;
true ->
exit({error,{asn1,{illegal_enumerated,Comp}}})
end || Comp <- Val]]
end.



dec_RequestedItemList(Bytes) ->
%% Length with constraint {1,32}
<<V1@V0:5,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components102(V1@Add2, V1@Buf1, []).

enc_RequestorDescription(Val) ->
#{id:=Input@1} = Val,
Input@2 = case Val of
  #{type:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{position:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{name:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{routeName:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@6 = case Val of
  #{transitStatus:=Input@6_0} -> Input@6_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@7 = case Val of
  #{transitOccupancy:=Input@7_0} -> Input@7_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@8 = case Val of
  #{transitSchedule:=Input@8_0} -> Input@8_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@9 = case Val of
  #{regional:=Input@9_0} -> Input@9_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@2 =:= asn1__MISSING_IN_MAP ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@4 =:= asn1__MISSING_IN_MAP ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@6 =:= asn1__MISSING_IN_MAP ->
if Input@7 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@7 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@8 =:= asn1__MISSING_IN_MAP ->
if Input@9 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@9 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
begin
%% attribute id(1) with type VehicleID
enc_VehicleID(Input@1)
end,
begin
%% attribute type(2) with type RequestorType
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_RequestorType(Input@2)
end
end,
begin
%% attribute position(3) with type RequestorPositionVector
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_RequestorPositionVector(Input@3)
end
end,
begin
%% attribute name(4) with type IA5String
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Enc4@len = length(Input@4),
Enc4@bin = encode_chars(Input@4, 7),
Enc4@len@sub = Enc4@len - 1,
if 0 =< Enc4@len@sub, Enc4@len@sub < 63 ->
[<<Enc4@len@sub:6>>|Enc4@bin]
end
end
end
end,
begin
%% attribute routeName(5) with type IA5String
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Enc6@len = length(Input@5),
Enc6@bin = encode_chars(Input@5, 7),
Enc6@len@sub = Enc6@len - 1,
if 0 =< Enc6@len@sub, Enc6@len@sub < 63 ->
[<<Enc6@len@sub:6>>|Enc6@bin]
end
end
end
end,
begin
%% attribute transitStatus(6) with type BIT STRING
if Input@6 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Enc8@bs = try bit_string_name2pos_103(Input@6) of
Enc8@positions ->
bitstring_from_positions(Enc8@positions, 8)
catch throw:invalid ->
adjust_trailing_zeroes(Input@6, 8)
end,
Enc8@bits = bit_size(Enc8@bs),
if Enc8@bits =:= 8 ->
Enc8@bs
end
end
end
end,
begin
%% attribute transitOccupancy(7) with type ENUMERATED
if Input@7 =:= asn1__MISSING_IN_MAP ->
[];
Input@7 =:= occupancyUnknown ->
<<0:3>>;
Input@7 =:= occupancyEmpty ->
<<1:3>>;
Input@7 =:= occupancyVeryLow ->
<<2:3>>;
Input@7 =:= occupancyLow ->
<<3:3>>;
Input@7 =:= occupancyMed ->
<<4:3>>;
Input@7 =:= occupancyHigh ->
<<5:3>>;
Input@7 =:= occupancyNearlyFull ->
<<6:3>>;
Input@7 =:= occupancyFull ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@7}}})
end
end,
begin
%% attribute transitSchedule(8) with type INTEGER
if Input@8 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Input@8@sub = Input@8 - -122,
if 0 =< Input@8@sub, Input@8@sub < 244 ->
Input@8@sub;
true ->
exit({error,{asn1,{illegal_integer,Input@8}}})
end
end
end
end|begin
%% attribute regional(9) with type SEQUENCE OF
if Input@9 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_RequestorDescription_regional(Input@9)
end
end].
enc_RequestorDescription_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_RequestorDescription_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_RequestorDescription_regional_RegionalExtension(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_RequestorDescription(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute id(1) with type VehicleID
{Term1,Bytes3} = dec_VehicleID(Bytes2),

%% attribute type(2) with type RequestorType
{Term2,Bytes4} = case (Opt bsr 7) band 1 of
1 ->
dec_RequestorType(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute position(3) with type RequestorPositionVector
{Term3,Bytes5} = case (Opt bsr 6) band 1 of
1 ->
dec_RequestorPositionVector(Bytes4);
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute name(4) with type IA5String
{Term4,Bytes6} = case (Opt bsr 5) band 1 of
1 ->
begin
<<V3@V0:6,V3@Buf1/bitstring>> = Bytes5,
V3@Add2 = V3@V0 + 1,
<<V3@V3:V3@Add2/binary-unit:7,V3@Buf4/bitstring>> = V3@Buf1,
{V3@V5,V3@Buf6}  = {decode_chars(V3@V3, 7),V3@Buf4},
{V3@V5,V3@Buf6}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute routeName(5) with type IA5String
{Term5,Bytes7} = case (Opt bsr 4) band 1 of
1 ->
begin
<<V4@V0:6,V4@Buf1/bitstring>> = Bytes6,
V4@Add2 = V4@V0 + 1,
<<V4@V3:V4@Add2/binary-unit:7,V4@Buf4/bitstring>> = V4@Buf1,
{V4@V5,V4@Buf6}  = {decode_chars(V4@V3, 7),V4@Buf4},
{V4@V5,V4@Buf6}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute transitStatus(6) with type BIT STRING
{Term6,Bytes8} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V5@V0:8/binary-unit:1,V5@Buf1/bitstring>> = Bytes7,
{V5@V2,V5@Buf3}  = {decode_named_bit_string(V5@V0, [{loading,0},{anADAuse,1},{aBikeLoad,2},{doorOpen,3},{charging,4},{atStopLine,5}]),V5@Buf1},
{V5@V2,V5@Buf3}
end;
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute transitOccupancy(7) with type ENUMERATED
{Term7,Bytes9} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V6@V0:3,V6@Buf1/bitstring>> = Bytes8,
V6@Int2 = case V6@V0 of
0 -> occupancyUnknown;
1 -> occupancyEmpty;
2 -> occupancyVeryLow;
3 -> occupancyLow;
4 -> occupancyMed;
5 -> occupancyHigh;
6 -> occupancyNearlyFull;
7 -> occupancyFull
end,
{V6@Int2,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% attribute transitSchedule(8) with type INTEGER
{Term8,Bytes10} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V7@V0:8,V7@Buf1/bitstring>> = Bytes9,
V7@Add2 = V7@V0 + -122,
{V7@Add2,V7@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes9}
end,

%% attribute regional(9) with type SEQUENCE OF
{Term9,Bytes11} = case Opt band 1 of
1 ->
dec_RequestorDescription_regional(Bytes10);
0 ->
{asn1_NOVALUE,Bytes10}
end,

%% Extensions
{Extensions,Bytes12} = case Ext of
0 -> {<<>>,Bytes11};
1 ->
{V8@V0,V8@Buf1} = case Bytes11 of
<<0:1,V8@V3:6,V8@Buf4/bitstring>> ->
V8@Add5 = V8@V3 + 1,
{V8@Add5,V8@Buf4};
<<1:1,V8@Buf2/bitstring>> ->
{V8@V3,V8@Buf4} = case V8@Buf2 of
<<0:1,V8@V6:7,V8@Buf7/bitstring>> when V8@V6 =/= 0 ->
{V8@V6,V8@Buf7};
<<1:1,0:1,V8@V7:14,V8@Buf8/bitstring>> when V8@V7 =/= 0 ->
{V8@V7,V8@Buf8}
end,
{V8@V3,V8@Buf4}
end,
<<V8@V9:V8@V0/bitstring-unit:1,V8@Buf10/bitstring>> = V8@Buf1,
{V8@V9,V8@Buf10}
end,
Bytes13= skipextensions(Bytes12, 1, Extensions),
Res1 = #{id=>Term1},
Res2 = case Term2 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{type=>Term2}
end,
Res3 = case Term3 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{position=>Term3}
end,
Res4 = case Term4 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{name=>Term4}
end,
Res5 = case Term5 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{routeName=>Term5}
end,
Res6 = case Term6 of
  asn1_NOVALUE -> Res5;
  _ -> Res5#{transitStatus=>Term6}
end,
Res7 = case Term7 of
  asn1_NOVALUE -> Res6;
  _ -> Res6#{transitOccupancy=>Term7}
end,
Res8 = case Term8 of
  asn1_NOVALUE -> Res7;
  _ -> Res7#{transitSchedule=>Term8}
end,
Res9 = case Term9 of
  asn1_NOVALUE -> Res8;
  _ -> Res8#{regional=>Term9}
end,
{Res9,Bytes13}.


dec_RequestorDescription_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components104(V1@Add2, V1@Buf1, []).


dec_RequestorDescription_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_RequestorPositionVector(Val) ->
#{position:=Input@1} = Val,
Input@2 = case Val of
  #{heading:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{speed:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@2 =:= asn1__MISSING_IN_MAP ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
begin
%% attribute position(1) with type Position3D
enc_Position3D(Input@1)
end,
begin
%% attribute heading(2) with type INTEGER
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@2, Input@2 < 28801 ->
<<Input@2:15>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end|begin
%% attribute speed(3) with type TransmissionAndSpeed
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_TransmissionAndSpeed(Input@3)
end
end].


dec_RequestorPositionVector(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute position(1) with type Position3D
{Term1,Bytes3} = dec_Position3D(Bytes2),

%% attribute heading(2) with type INTEGER
{Term2,Bytes4} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V3@V0:15,V3@Buf1/bitstring>> = Bytes3,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute speed(3) with type TransmissionAndSpeed
{Term3,Bytes5} = case Opt band 1 of
1 ->
dec_TransmissionAndSpeed(Bytes4);
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% Extensions
{Extensions,Bytes6} = case Ext of
0 -> {<<>>,Bytes5};
1 ->
{V4@V0,V4@Buf1} = case Bytes5 of
<<0:1,V4@V3:6,V4@Buf4/bitstring>> ->
V4@Add5 = V4@V3 + 1,
{V4@Add5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:7,V4@Buf7/bitstring>> when V4@V6 =/= 0 ->
{V4@V6,V4@Buf7};
<<1:1,0:1,V4@V7:14,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
{V4@V7,V4@Buf8}
end,
{V4@V3,V4@Buf4}
end,
<<V4@V9:V4@V0/bitstring-unit:1,V4@Buf10/bitstring>> = V4@Buf1,
{V4@V9,V4@Buf10}
end,
Bytes7= skipextensions(Bytes6, 1, Extensions),
Res1 = #{position=>Term1},
Res2 = case Term2 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{heading=>Term2}
end,
Res3 = case Term3 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{speed=>Term3}
end,
{Res3,Bytes7}.

enc_RequestorType(Val) ->
#{role:=Input@1} = Val,
Input@2 = case Val of
  #{subrole:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{request:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{iso3883:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{hpmsType:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@6 = case Val of
  #{regional:=Input@6_0} -> Input@6_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@2 =:= asn1__MISSING_IN_MAP ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@4 =:= asn1__MISSING_IN_MAP ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<0:1>>;
true ->
<<1:1>>
end,
begin
%% attribute role(1) with type ENUMERATED
if Input@1 =:= basicVehicle ->
<<0:1,0:5>>;
Input@1 =:= publicTransport ->
<<0:1,1:5>>;
Input@1 =:= specialTransport ->
<<0:1,2:5>>;
Input@1 =:= dangerousGoods ->
<<0:1,3:5>>;
Input@1 =:= roadWork ->
<<0:1,4:5>>;
Input@1 =:= roadRescue ->
<<0:1,5:5>>;
Input@1 =:= emergency ->
<<0:1,6:5>>;
Input@1 =:= safetyCar ->
<<0:1,7:5>>;
Input@1 =:= 'none-unknown' ->
<<0:1,8:5>>;
Input@1 =:= truck ->
<<0:1,9:5>>;
Input@1 =:= motorcycle ->
<<0:1,10:5>>;
Input@1 =:= roadSideSource ->
<<0:1,11:5>>;
Input@1 =:= police ->
<<0:1,12:5>>;
Input@1 =:= fire ->
<<0:1,13:5>>;
Input@1 =:= ambulance ->
<<0:1,14:5>>;
Input@1 =:= dot ->
<<0:1,15:5>>;
Input@1 =:= transit ->
<<0:1,16:5>>;
Input@1 =:= slowMoving ->
<<0:1,17:5>>;
Input@1 =:= stopNgo ->
<<0:1,18:5>>;
Input@1 =:= cyclist ->
<<0:1,19:5>>;
Input@1 =:= pedestrian ->
<<0:1,20:5>>;
Input@1 =:= nonMotorized ->
<<0:1,21:5>>;
Input@1 =:= military ->
<<0:1,22:5>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@1}}})
end
end,
begin
%% attribute subrole(2) with type ENUMERATED
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
Input@2 =:= requestSubRoleUnKnown ->
<<0:4>>;
Input@2 =:= requestSubRole1 ->
<<1:4>>;
Input@2 =:= requestSubRole2 ->
<<2:4>>;
Input@2 =:= requestSubRole3 ->
<<3:4>>;
Input@2 =:= requestSubRole4 ->
<<4:4>>;
Input@2 =:= requestSubRole5 ->
<<5:4>>;
Input@2 =:= requestSubRole6 ->
<<6:4>>;
Input@2 =:= requestSubRole7 ->
<<7:4>>;
Input@2 =:= requestSubRole8 ->
<<8:4>>;
Input@2 =:= requestSubRole9 ->
<<9:4>>;
Input@2 =:= requestSubRole10 ->
<<10:4>>;
Input@2 =:= requestSubRole11 ->
<<11:4>>;
Input@2 =:= requestSubRole12 ->
<<12:4>>;
Input@2 =:= requestSubRole13 ->
<<13:4>>;
Input@2 =:= requestSubRole14 ->
<<14:4>>;
Input@2 =:= requestSubRoleReserved ->
<<15:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@2}}})
end
end,
begin
%% attribute request(3) with type ENUMERATED
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
Input@3 =:= requestImportanceLevelUnKnown ->
<<0:4>>;
Input@3 =:= requestImportanceLevel1 ->
<<1:4>>;
Input@3 =:= requestImportanceLevel2 ->
<<2:4>>;
Input@3 =:= requestImportanceLevel3 ->
<<3:4>>;
Input@3 =:= requestImportanceLevel4 ->
<<4:4>>;
Input@3 =:= requestImportanceLevel5 ->
<<5:4>>;
Input@3 =:= requestImportanceLevel6 ->
<<6:4>>;
Input@3 =:= requestImportanceLevel7 ->
<<7:4>>;
Input@3 =:= requestImportanceLevel8 ->
<<8:4>>;
Input@3 =:= requestImportanceLevel9 ->
<<9:4>>;
Input@3 =:= requestImportanceLevel10 ->
<<10:4>>;
Input@3 =:= requestImportanceLevel11 ->
<<11:4>>;
Input@3 =:= requestImportanceLevel12 ->
<<12:4>>;
Input@3 =:= requestImportanceLevel13 ->
<<13:4>>;
Input@3 =:= requestImportanceLevel14 ->
<<14:4>>;
Input@3 =:= requestImportanceReserved ->
<<15:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@3}}})
end
end,
begin
%% attribute iso3883(4) with type INTEGER
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@4, Input@4 < 101 ->
<<Input@4:7>>;
true ->
exit({error,{asn1,{illegal_integer,Input@4}}})
end
end,
begin
%% attribute hpmsType(5) with type ENUMERATED
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
Input@5 =:= none ->
<<0:1,0:4>>;
Input@5 =:= unknown ->
<<0:1,1:4>>;
Input@5 =:= special ->
<<0:1,2:4>>;
Input@5 =:= moto ->
<<0:1,3:4>>;
Input@5 =:= car ->
<<0:1,4:4>>;
Input@5 =:= carOther ->
<<0:1,5:4>>;
Input@5 =:= bus ->
<<0:1,6:4>>;
Input@5 =:= axleCnt2 ->
<<0:1,7:4>>;
Input@5 =:= axleCnt3 ->
<<0:1,8:4>>;
Input@5 =:= axleCnt4 ->
<<0:1,9:4>>;
Input@5 =:= axleCnt4Trailer ->
<<0:1,10:4>>;
Input@5 =:= axleCnt5Trailer ->
<<0:1,11:4>>;
Input@5 =:= axleCnt6Trailer ->
<<0:1,12:4>>;
Input@5 =:= axleCnt5MultiTrailer ->
<<0:1,13:4>>;
Input@5 =:= axleCnt6MultiTrailer ->
<<0:1,14:4>>;
Input@5 =:= axleCnt7MultiTrailer ->
<<0:1,15:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@5}}})
end
end|begin
%% attribute regional(6) with type SEQUENCE
if Input@6 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_RequestorType_regional(Input@6)
end
end].
enc_RequestorType_regional(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_RequestorType(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:5,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute role(1) with type ENUMERATED
{Term1,Bytes3} = begin
{V3@V0,V3@Buf1} = case Bytes2 of
<<0:1,V3@V3:5,V3@Buf4/bitstring>> ->
V3@Int5 = case V3@V3 of
0 -> basicVehicle;
1 -> publicTransport;
2 -> specialTransport;
3 -> dangerousGoods;
4 -> roadWork;
5 -> roadRescue;
6 -> emergency;
7 -> safetyCar;
8 -> 'none-unknown';
9 -> truck;
10 -> motorcycle;
11 -> roadSideSource;
12 -> police;
13 -> fire;
14 -> ambulance;
15 -> dot;
16 -> transit;
17 -> slowMoving;
18 -> stopNgo;
19 -> cyclist;
20 -> pedestrian;
21 -> nonMotorized;
22 -> military;
_ -> exit({error,{asn1,{decode_enumerated,V3@V3}}})
end,
{V3@Int5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:6,V3@Buf7/bitstring>> ->
{V3@V6,V3@Buf7};
<<1:1,V3@Buf5/bitstring>> ->
{V3@V6,V3@Buf7} = case V3@Buf5 of
<<0:1,V3@V9:7,V3@Buf10/bitstring>> when V3@V9 =/= 0 ->
{V3@V9,V3@Buf10};
<<1:1,0:1,V3@V10:14,V3@Buf11/bitstring>> when V3@V10 =/= 0 ->
{V3@V10,V3@Buf11}
end,
<<V3@V12:V3@V6/unit:8,V3@Buf13/bitstring>> = V3@Buf7,
{V3@V12,V3@Buf13}
end,
V3@Int14 = case V3@V3 of
_ -> {asn1_enum,V3@V3}
end,
{V3@Int14,V3@Buf4}
end,
{V3@V0,V3@Buf1}
end,

%% attribute subrole(2) with type ENUMERATED
{Term2,Bytes4} = case (Opt bsr 4) band 1 of
1 ->
begin
<<V4@V0:4,V4@Buf1/bitstring>> = Bytes3,
V4@Int2 = case V4@V0 of
0 -> requestSubRoleUnKnown;
1 -> requestSubRole1;
2 -> requestSubRole2;
3 -> requestSubRole3;
4 -> requestSubRole4;
5 -> requestSubRole5;
6 -> requestSubRole6;
7 -> requestSubRole7;
8 -> requestSubRole8;
9 -> requestSubRole9;
10 -> requestSubRole10;
11 -> requestSubRole11;
12 -> requestSubRole12;
13 -> requestSubRole13;
14 -> requestSubRole14;
15 -> requestSubRoleReserved
end,
{V4@Int2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute request(3) with type ENUMERATED
{Term3,Bytes5} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V5@V0:4,V5@Buf1/bitstring>> = Bytes4,
V5@Int2 = case V5@V0 of
0 -> requestImportanceLevelUnKnown;
1 -> requestImportanceLevel1;
2 -> requestImportanceLevel2;
3 -> requestImportanceLevel3;
4 -> requestImportanceLevel4;
5 -> requestImportanceLevel5;
6 -> requestImportanceLevel6;
7 -> requestImportanceLevel7;
8 -> requestImportanceLevel8;
9 -> requestImportanceLevel9;
10 -> requestImportanceLevel10;
11 -> requestImportanceLevel11;
12 -> requestImportanceLevel12;
13 -> requestImportanceLevel13;
14 -> requestImportanceLevel14;
15 -> requestImportanceReserved
end,
{V5@Int2,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute iso3883(4) with type INTEGER
{Term4,Bytes6} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V6@V0:7,V6@Buf1/bitstring>> = Bytes5,
{V6@V0,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute hpmsType(5) with type ENUMERATED
{Term5,Bytes7} = case (Opt bsr 1) band 1 of
1 ->
begin
{V7@V0,V7@Buf1} = case Bytes6 of
<<0:1,V7@V3:4,V7@Buf4/bitstring>> ->
V7@Int5 = case V7@V3 of
0 -> none;
1 -> unknown;
2 -> special;
3 -> moto;
4 -> car;
5 -> carOther;
6 -> bus;
7 -> axleCnt2;
8 -> axleCnt3;
9 -> axleCnt4;
10 -> axleCnt4Trailer;
11 -> axleCnt5Trailer;
12 -> axleCnt6Trailer;
13 -> axleCnt5MultiTrailer;
14 -> axleCnt6MultiTrailer;
15 -> axleCnt7MultiTrailer
end,
{V7@Int5,V7@Buf4};
<<1:1,V7@Buf2/bitstring>> ->
{V7@V3,V7@Buf4} = case V7@Buf2 of
<<0:1,V7@V6:6,V7@Buf7/bitstring>> ->
{V7@V6,V7@Buf7};
<<1:1,V7@Buf5/bitstring>> ->
{V7@V6,V7@Buf7} = case V7@Buf5 of
<<0:1,V7@V9:7,V7@Buf10/bitstring>> when V7@V9 =/= 0 ->
{V7@V9,V7@Buf10};
<<1:1,0:1,V7@V10:14,V7@Buf11/bitstring>> when V7@V10 =/= 0 ->
{V7@V10,V7@Buf11}
end,
<<V7@V12:V7@V6/unit:8,V7@Buf13/bitstring>> = V7@Buf7,
{V7@V12,V7@Buf13}
end,
V7@Int14 = case V7@V3 of
_ -> {asn1_enum,V7@V3}
end,
{V7@Int14,V7@Buf4}
end,
{V7@V0,V7@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute regional(6) with type SEQUENCE
{Term6,Bytes8} = case Opt band 1 of
1 ->
dec_RequestorType_regional(Bytes7);
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% Extensions
{Extensions,Bytes9} = case Ext of
0 -> {<<>>,Bytes8};
1 ->
{V8@V0,V8@Buf1} = case Bytes8 of
<<0:1,V8@V3:6,V8@Buf4/bitstring>> ->
V8@Add5 = V8@V3 + 1,
{V8@Add5,V8@Buf4};
<<1:1,V8@Buf2/bitstring>> ->
{V8@V3,V8@Buf4} = case V8@Buf2 of
<<0:1,V8@V6:7,V8@Buf7/bitstring>> when V8@V6 =/= 0 ->
{V8@V6,V8@Buf7};
<<1:1,0:1,V8@V7:14,V8@Buf8/bitstring>> when V8@V7 =/= 0 ->
{V8@V7,V8@Buf8}
end,
{V8@V3,V8@Buf4}
end,
<<V8@V9:V8@V0/bitstring-unit:1,V8@Buf10/bitstring>> = V8@Buf1,
{V8@V9,V8@Buf10}
end,
Bytes10= skipextensions(Bytes9, 1, Extensions),
Res1 = #{role=>Term1},
Res2 = case Term2 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{subrole=>Term2}
end,
Res3 = case Term3 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{request=>Term3}
end,
Res4 = case Term4 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{iso3883=>Term4}
end,
Res5 = case Term5 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{hpmsType=>Term5}
end,
Res6 = case Term6 of
  asn1_NOVALUE -> Res5;
  _ -> Res5#{regional=>Term6}
end,
{Res6,Bytes10}.


dec_RequestorType_regional(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_RestrictionClassAssignment(Val) ->
#{id:=Input@1,users:=Input@2} = Val,
[begin
%% attribute id(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute users(2) with type RestrictionUserTypeList
enc_RestrictionUserTypeList(Input@2)
end].


dec_RestrictionClassAssignment(Bytes) ->

%% attribute id(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute users(2) with type RestrictionUserTypeList
{Term2,Bytes2} = dec_RestrictionUserTypeList(Bytes1),
Res1 = #{id=>Term1,users=>Term2},
{Res1,Bytes2}.

enc_RestrictionClassList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if 0 =< Enc1@len@sub, Enc1@len@sub < 254 ->
[Enc1@len@sub|[enc_RestrictionClassAssignment(Comp) || Comp <- Val]]
end.



dec_RestrictionClassList(Bytes) ->
%% Length with constraint {1,254}
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components105(V1@Add2, V1@Buf1, []).

enc_RestrictionUserTypeList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 4 =:= 0 ->
[<<Enc1@len@sub:4>>|[enc_RestrictionUserType(Comp) || Comp <- Val]]
end.



dec_RestrictionUserTypeList(Bytes) ->
%% Length with constraint {1,16}
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components106(V1@Add2, V1@Buf1, []).

enc_RestrictionUserType(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= basicType ->
if ChoiceVal =:= none ->
<<0:1,0:1,0:1,0:4>>;
ChoiceVal =:= equippedTransit ->
<<0:1,0:1,0:1,1:4>>;
ChoiceVal =:= equippedTaxis ->
<<0:1,0:1,0:1,2:4>>;
ChoiceVal =:= equippedOther ->
<<0:1,0:1,0:1,3:4>>;
ChoiceVal =:= emissionCompliant ->
<<0:1,0:1,0:1,4:4>>;
ChoiceVal =:= equippedBicycle ->
<<0:1,0:1,0:1,5:4>>;
ChoiceVal =:= weightCompliant ->
<<0:1,0:1,0:1,6:4>>;
ChoiceVal =:= heightCompliant ->
<<0:1,0:1,0:1,7:4>>;
ChoiceVal =:= pedestrians ->
<<0:1,0:1,0:1,8:4>>;
ChoiceVal =:= slowMovingPersons ->
<<0:1,0:1,0:1,9:4>>;
ChoiceVal =:= wheelchairUsers ->
<<0:1,0:1,0:1,10:4>>;
ChoiceVal =:= visualDisabilities ->
<<0:1,0:1,0:1,11:4>>;
ChoiceVal =:= audioDisabilities ->
<<0:1,0:1,0:1,12:4>>;
ChoiceVal =:= otherUnknownDisabilities ->
<<0:1,0:1,0:1,13:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,ChoiceVal}}})
end;
ChoiceTag =:= regional ->
[<<0:1,1:1>>|enc_RestrictionUserType_regional(ChoiceVal)]
end.
enc_RestrictionUserType_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_RestrictionUserType_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_RestrictionUserType_regional_RegionalExtension(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type107(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_RestrictionUserType(Bytes) ->
case Bytes of
<<0:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes1,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
begin
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:4,V2@Buf4/bitstring>> ->
V2@Int5 = case V2@V3 of
0 -> none;
1 -> equippedTransit;
2 -> equippedTaxis;
3 -> equippedOther;
4 -> emissionCompliant;
5 -> equippedBicycle;
6 -> weightCompliant;
7 -> heightCompliant;
8 -> pedestrians;
9 -> slowMovingPersons;
10 -> wheelchairUsers;
11 -> visualDisabilities;
12 -> audioDisabilities;
13 -> otherUnknownDisabilities;
_ -> exit({error,{asn1,{decode_enumerated,V2@V3}}})
end,
{V2@Int5,V2@Buf4};
<<1:1,V2@Buf2/bitstring>> ->
{V2@V3,V2@Buf4} = case V2@Buf2 of
<<0:1,V2@V6:6,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7} = case V2@Buf5 of
<<0:1,V2@V9:7,V2@Buf10/bitstring>> when V2@V9 =/= 0 ->
{V2@V9,V2@Buf10};
<<1:1,0:1,V2@V10:14,V2@Buf11/bitstring>> when V2@V10 =/= 0 ->
{V2@V10,V2@Buf11}
end,
<<V2@V12:V2@V6/unit:8,V2@Buf13/bitstring>> = V2@Buf7,
{V2@V12,V2@Buf13}
end,
V2@Int14 = case V2@V3 of
_ -> {asn1_enum,V2@V3}
end,
{V2@Int14,V2@Buf4}
end,
{V2@V0,V2@Buf1}
end
end,
{{basicType,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
dec_RestrictionUserType_regional(Bytes2)
end,
{{regional,Val},NewBytes}
end;

<<1:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
{V1@V0,V1@Buf1} = case Bytes1 of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> when V1@V6 =/= 0 ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
{V1@V7,V1@Buf8}
end,
<<V1@V9:V1@V3/unit:8,V1@Buf10/bitstring>> = V1@Buf4,
{V1@V9,V1@Buf10}
end,
{V1@V0,V1@Buf1}
end,
begin
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end
end,
case Choice of
_ ->
{{asn1_ExtAlt,V2@V0},V2@Buf1}
end
end.

dec_RestrictionUserType_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components108(V1@Add2, V1@Buf1, []).


dec_RestrictionUserType_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type109(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_RoadLaneSetList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if 0 =< Enc1@len@sub, Enc1@len@sub < 255 ->
[Enc1@len@sub|[enc_GenericLane(Comp) || Comp <- Val]]
end.



dec_RoadLaneSetList(Bytes) ->
%% Length with constraint {1,255}
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components110(V1@Add2, V1@Buf1, []).

enc_RoadSegmentList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 5 =:= 0 ->
[<<Enc1@len@sub:5>>|[enc_RoadSegment(Comp) || Comp <- Val]]
end.



dec_RoadSegmentList(Bytes) ->
%% Length with constraint {1,32}
<<V1@V0:5,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components111(V1@Add2, V1@Buf1, []).

enc_RoadSegmentReferenceID(Val) ->
#{id:=Input@2} = Val,
Input@1 = case Val of
  #{region:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
<<0:1>>;
true ->
<<1:1>>
end,
begin
%% attribute region(1) with type INTEGER
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
Input@1 bsr 16 =:= 0 ->
<<Input@1:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute id(2) with type INTEGER
if Input@2 bsr 16 =:= 0 ->
<<Input@2:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end].


dec_RoadSegmentReferenceID(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute region(1) with type INTEGER
{Term1,Bytes2} = case Opt band 1 of
1 ->
begin
<<V2@V0:16,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes1}
end,

%% attribute id(2) with type INTEGER
{Term2,Bytes3} = begin
<<V3@V0:16,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,
Res1 = #{id=>Term2},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{region=>Term1}
end,
{Res2,Bytes3}.

enc_RoadSegment(Val) ->
#{id:=Input@2,revision:=Input@3,refPoint:=Input@4,roadLaneSet:=Input@7} = Val,
Input@1 = case Val of
  #{name:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{laneWidth:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@6 = case Val of
  #{speedLimits:=Input@6_0} -> Input@6_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@8 = case Val of
  #{regional:=Input@8_0} -> Input@8_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@6 =:= asn1__MISSING_IN_MAP ->
if Input@8 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@8 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
begin
%% attribute name(1) with type IA5String
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Enc2@len = length(Input@1),
Enc2@bin = encode_chars(Input@1, 7),
Enc2@len@sub = Enc2@len - 1,
if 0 =< Enc2@len@sub, Enc2@len@sub < 63 ->
[<<Enc2@len@sub:6>>|Enc2@bin]
end
end
end
end,
begin
%% attribute id(2) with type RoadSegmentReferenceID
enc_RoadSegmentReferenceID(Input@2)
end,
begin
%% attribute revision(3) with type INTEGER
if Input@3 bsr 7 =:= 0 ->
<<Input@3:7>>;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end,
begin
%% attribute refPoint(4) with type Position3D
enc_Position3D(Input@4)
end,
begin
%% attribute laneWidth(5) with type INTEGER
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
Input@5 bsr 15 =:= 0 ->
<<Input@5:15>>;
true ->
exit({error,{asn1,{illegal_integer,Input@5}}})
end
end,
begin
%% attribute speedLimits(6) with type SpeedLimitList
if Input@6 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_SpeedLimitList(Input@6)
end
end,
begin
%% attribute roadLaneSet(7) with type RoadLaneSetList
enc_RoadLaneSetList(Input@7)
end|begin
%% attribute regional(8) with type SEQUENCE OF
if Input@8 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_RoadSegment_regional(Input@8)
end
end].
enc_RoadSegment_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_RoadSegment_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_RoadSegment_regional_RegionalExtension(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_RoadSegment(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:4,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute name(1) with type IA5String
{Term1,Bytes3} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V3@V0:6,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + 1,
<<V3@V3:V3@Add2/binary-unit:7,V3@Buf4/bitstring>> = V3@Buf1,
{V3@V5,V3@Buf6}  = {decode_chars(V3@V3, 7),V3@Buf4},
{V3@V5,V3@Buf6}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute id(2) with type RoadSegmentReferenceID
{Term2,Bytes4} = dec_RoadSegmentReferenceID(Bytes3),

%% attribute revision(3) with type INTEGER
{Term3,Bytes5} = begin
<<V4@V0:7,V4@Buf1/bitstring>> = Bytes4,
{V4@V0,V4@Buf1}
end,

%% attribute refPoint(4) with type Position3D
{Term4,Bytes6} = dec_Position3D(Bytes5),

%% attribute laneWidth(5) with type INTEGER
{Term5,Bytes7} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V5@V0:15,V5@Buf1/bitstring>> = Bytes6,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute speedLimits(6) with type SpeedLimitList
{Term6,Bytes8} = case (Opt bsr 1) band 1 of
1 ->
dec_SpeedLimitList(Bytes7);
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute roadLaneSet(7) with type RoadLaneSetList
{Term7,Bytes9} = dec_RoadLaneSetList(Bytes8),

%% attribute regional(8) with type SEQUENCE OF
{Term8,Bytes10} = case Opt band 1 of
1 ->
dec_RoadSegment_regional(Bytes9);
0 ->
{asn1_NOVALUE,Bytes9}
end,

%% Extensions
{Extensions,Bytes11} = case Ext of
0 -> {<<>>,Bytes10};
1 ->
{V6@V0,V6@Buf1} = case Bytes10 of
<<0:1,V6@V3:6,V6@Buf4/bitstring>> ->
V6@Add5 = V6@V3 + 1,
{V6@Add5,V6@Buf4};
<<1:1,V6@Buf2/bitstring>> ->
{V6@V3,V6@Buf4} = case V6@Buf2 of
<<0:1,V6@V6:7,V6@Buf7/bitstring>> when V6@V6 =/= 0 ->
{V6@V6,V6@Buf7};
<<1:1,0:1,V6@V7:14,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
{V6@V7,V6@Buf8}
end,
{V6@V3,V6@Buf4}
end,
<<V6@V9:V6@V0/bitstring-unit:1,V6@Buf10/bitstring>> = V6@Buf1,
{V6@V9,V6@Buf10}
end,
Bytes12= skipextensions(Bytes11, 1, Extensions),
Res1 = #{id=>Term2,revision=>Term3,refPoint=>Term4,roadLaneSet=>Term7},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{name=>Term1}
end,
Res3 = case Term5 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{laneWidth=>Term5}
end,
Res4 = case Term6 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{speedLimits=>Term6}
end,
Res5 = case Term8 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{regional=>Term8}
end,
{Res5,Bytes12}.


dec_RoadSegment_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components112(V1@Add2, V1@Buf1, []).


dec_RoadSegment_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_RoadSignID(Val) ->
#{position:=Input@1,viewAngle:=Input@2} = Val,
Input@3 = case Val of
  #{mutcdCode:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{crc:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@3 =:= asn1__MISSING_IN_MAP ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
begin
%% attribute position(1) with type Position3D
enc_Position3D(Input@1)
end,
begin
%% attribute viewAngle(2) with type BIT STRING
Enc1@bs = try bit_string_name2pos_23(Input@2) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(Input@2, 16)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 16 ->
Enc1@bs
end
end,
begin
%% attribute mutcdCode(3) with type ENUMERATED
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
Input@3 =:= none ->
<<0:1,0:3>>;
Input@3 =:= regulatory ->
<<0:1,1:3>>;
Input@3 =:= warning ->
<<0:1,2:3>>;
Input@3 =:= maintenance ->
<<0:1,3:3>>;
Input@3 =:= motoristService ->
<<0:1,4:3>>;
Input@3 =:= guide ->
<<0:1,5:3>>;
Input@3 =:= rec ->
<<0:1,6:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@3}}})
end
end|begin
%% attribute crc(4) with type OCTET STRING
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
enc_Binary_Id(Input@4, 2)
end
end
end].


dec_RoadSignID(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute position(1) with type Position3D
{Term1,Bytes2} = dec_Position3D(Bytes1),

%% attribute viewAngle(2) with type BIT STRING
{Term2,Bytes3} = begin
<<V2@V0:16/binary-unit:1,V2@Buf1/bitstring>> = Bytes2,
{V2@V2,V2@Buf3}  = {decode_named_bit_string(V2@V0, [{'from000-0to022-5degrees',0},{'from022-5to045-0degrees',1},{'from045-0to067-5degrees',2},{'from067-5to090-0degrees',3},{'from090-0to112-5degrees',4},{'from112-5to135-0degrees',5},{'from135-0to157-5degrees',6},{'from157-5to180-0degrees',7},{'from180-0to202-5degrees',8},{'from202-5to225-0degrees',9},{'from225-0to247-5degrees',10},{'from247-5to270-0degrees',11},{'from270-0to292-5degrees',12},{'from292-5to315-0degrees',13},{'from315-0to337-5degrees',14},{'from337-5to360-0degrees',15}]),V2@Buf1},
{V2@V2,V2@Buf3}
end,

%% attribute mutcdCode(3) with type ENUMERATED
{Term3,Bytes4} = case (Opt bsr 1) band 1 of
1 ->
begin
{V3@V0,V3@Buf1} = case Bytes3 of
<<0:1,V3@V3:3,V3@Buf4/bitstring>> ->
V3@Int5 = case V3@V3 of
0 -> none;
1 -> regulatory;
2 -> warning;
3 -> maintenance;
4 -> motoristService;
5 -> guide;
6 -> rec;
_ -> exit({error,{asn1,{decode_enumerated,V3@V3}}})
end,
{V3@Int5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:6,V3@Buf7/bitstring>> ->
{V3@V6,V3@Buf7};
<<1:1,V3@Buf5/bitstring>> ->
{V3@V6,V3@Buf7} = case V3@Buf5 of
<<0:1,V3@V9:7,V3@Buf10/bitstring>> when V3@V9 =/= 0 ->
{V3@V9,V3@Buf10};
<<1:1,0:1,V3@V10:14,V3@Buf11/bitstring>> when V3@V10 =/= 0 ->
{V3@V10,V3@Buf11}
end,
<<V3@V12:V3@V6/unit:8,V3@Buf13/bitstring>> = V3@Buf7,
{V3@V12,V3@Buf13}
end,
V3@Int14 = case V3@V3 of
_ -> {asn1_enum,V3@V3}
end,
{V3@Int14,V3@Buf4}
end,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute crc(4) with type OCTET STRING
{Term4,Bytes5} = case Opt band 1 of
1 ->
begin
<<V4@V0:2/binary-unit:8,V4@Buf1/bitstring>> = Bytes4,
V4@Conv2 = binary:copy(V4@V0),
{dec_Binary_Id(V4@Conv2),V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,
Res1 = #{position=>Term1,viewAngle=>Term2},
Res2 = case Term3 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{mutcdCode=>Term3}
end,
Res3 = case Term4 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{crc=>Term4}
end,
{Res3,Bytes5}.

enc_RTCMheader(Val) ->
#{status:=Input@1,offsetSet:=Input@2} = Val,
[begin
%% attribute status(1) with type BIT STRING
Enc1@bs = try bit_string_name2pos_94(Input@1) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 8)
catch throw:invalid ->
adjust_trailing_zeroes(Input@1, 8)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 8 ->
Enc1@bs
end
end|begin
%% attribute offsetSet(2) with type AntennaOffsetSet
enc_AntennaOffsetSet(Input@2)
end].


dec_RTCMheader(Bytes) ->

%% attribute status(1) with type BIT STRING
{Term1,Bytes1} = begin
<<V1@V0:8/binary-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V2,V1@Buf3}  = {decode_named_bit_string(V1@V0, [{unavailable,0},{isHealthy,1},{isMonitored,2},{baseStationType,3},{aPDOPofUnder5,4},{inViewOfUnder5,5},{localCorrectionsPresent,6},{networkCorrectionsPresent,7}]),V1@Buf1},
{V1@V2,V1@Buf3}
end,

%% attribute offsetSet(2) with type AntennaOffsetSet
{Term2,Bytes2} = dec_AntennaOffsetSet(Bytes1),
Res1 = #{status=>Term1,offsetSet=>Term2},
{Res1,Bytes2}.

enc_RTCMmessageList(Val) ->
Enc2@len = length(Val),
Enc2@len@sub = Enc2@len - 1,
if 0 =< Enc2@len@sub, Enc2@len@sub < 5 ->
[<<Enc2@len@sub:3>>|[begin
Enc1@len = byte_size(Comp),
Enc1@len@sub = Enc1@len - 1,
if 0 =< Enc1@len@sub, Enc1@len@sub < 1023 ->
[<<Enc1@len@sub:10>>|Comp]
end
end || Comp <- Val]]
end.



dec_RTCMmessageList(Bytes) ->
%% Length with constraint {1,5}
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components113(V1@Add2, V1@Buf1, []).

enc_RTCMPackage(Val) ->
#{msgs:=Input@2} = Val,
Input@1 = case Val of
  #{rtcmHeader:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end,
begin
%% attribute rtcmHeader(1) with type RTCMheader
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_RTCMheader(Input@1)
end
end|begin
%% attribute msgs(2) with type RTCMmessageList
enc_RTCMmessageList(Input@2)
end].


dec_RTCMPackage(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:1,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute rtcmHeader(1) with type RTCMheader
{Term1,Bytes3} = case Opt band 1 of
1 ->
dec_RTCMheader(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute msgs(2) with type RTCMmessageList
{Term2,Bytes4} = dec_RTCMmessageList(Bytes3),

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V3@V0,V3@Buf1} = case Bytes4 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V9:V3@V0/bitstring-unit:1,V3@Buf10/bitstring>> = V3@Buf1,
{V3@V9,V3@Buf10}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = #{msgs=>Term2},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{rtcmHeader=>Term1}
end,
{Res2,Bytes6}.

enc_Sample(Val) ->
#{sampleStart:=Input@1,sampleEnd:=Input@2} = Val,
[begin
%% attribute sampleStart(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute sampleEnd(2) with type INTEGER
if Input@2 bsr 8 =:= 0 ->
[Input@2];
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end].


dec_Sample(Bytes) ->

%% attribute sampleStart(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute sampleEnd(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,
Res1 = #{sampleStart=>Term1,sampleEnd=>Term2},
{Res1,Bytes2}.

enc_SegmentAttributeLLList(Val) ->
Enc2@len = length(Val),
Enc2@len@sub = Enc2@len - 1,
if Enc2@len@sub bsr 3 =:= 0 ->
[<<Enc2@len@sub:3>>|[if Comp =:= reserved ->
<<0:1,0:6>>;
Comp =:= doNotBlock ->
<<0:1,1:6>>;
Comp =:= whiteLine ->
<<0:1,2:6>>;
Comp =:= mergingLaneLeft ->
<<0:1,3:6>>;
Comp =:= mergingLaneRight ->
<<0:1,4:6>>;
Comp =:= curbOnLeft ->
<<0:1,5:6>>;
Comp =:= curbOnRight ->
<<0:1,6:6>>;
Comp =:= loadingzoneOnLeft ->
<<0:1,7:6>>;
Comp =:= loadingzoneOnRight ->
<<0:1,8:6>>;
Comp =:= turnOutPointOnLeft ->
<<0:1,9:6>>;
Comp =:= turnOutPointOnRight ->
<<0:1,10:6>>;
Comp =:= adjacentParkingOnLeft ->
<<0:1,11:6>>;
Comp =:= adjacentParkingOnRight ->
<<0:1,12:6>>;
Comp =:= adjacentBikeLaneOnLeft ->
<<0:1,13:6>>;
Comp =:= adjacentBikeLaneOnRight ->
<<0:1,14:6>>;
Comp =:= sharedBikeLane ->
<<0:1,15:6>>;
Comp =:= bikeBoxInFront ->
<<0:1,16:6>>;
Comp =:= transitStopOnLeft ->
<<0:1,17:6>>;
Comp =:= transitStopOnRight ->
<<0:1,18:6>>;
Comp =:= transitStopInLane ->
<<0:1,19:6>>;
Comp =:= sharedWithTrackedVehicle ->
<<0:1,20:6>>;
Comp =:= safeIsland ->
<<0:1,21:6>>;
Comp =:= lowCurbsPresent ->
<<0:1,22:6>>;
Comp =:= rumbleStripPresent ->
<<0:1,23:6>>;
Comp =:= audibleSignalingPresent ->
<<0:1,24:6>>;
Comp =:= adaptiveTimingPresent ->
<<0:1,25:6>>;
Comp =:= rfSignalRequestPresent ->
<<0:1,26:6>>;
Comp =:= partialCurbIntrusion ->
<<0:1,27:6>>;
Comp =:= taperToLeft ->
<<0:1,28:6>>;
Comp =:= taperToRight ->
<<0:1,29:6>>;
Comp =:= taperToCenterLine ->
<<0:1,30:6>>;
Comp =:= parallelParking ->
<<0:1,31:6>>;
Comp =:= headInParking ->
<<0:1,32:6>>;
Comp =:= freeParking ->
<<0:1,33:6>>;
Comp =:= timeRestrictionsOnParking ->
<<0:1,34:6>>;
Comp =:= costToPark ->
<<0:1,35:6>>;
Comp =:= midBlockCurbPresent ->
<<0:1,36:6>>;
Comp =:= unEvenPavementPresent ->
<<0:1,37:6>>;
true ->
exit({error,{asn1,{illegal_enumerated,Comp}}})
end || Comp <- Val]]
end.



dec_SegmentAttributeLLList(Bytes) ->
%% Length with constraint {1,8}
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components114(V1@Add2, V1@Buf1, []).

enc_SegmentAttributeXYList(Val) ->
Enc2@len = length(Val),
Enc2@len@sub = Enc2@len - 1,
if Enc2@len@sub bsr 3 =:= 0 ->
[<<Enc2@len@sub:3>>|[if Comp =:= reserved ->
<<0:1,0:6>>;
Comp =:= doNotBlock ->
<<0:1,1:6>>;
Comp =:= whiteLine ->
<<0:1,2:6>>;
Comp =:= mergingLaneLeft ->
<<0:1,3:6>>;
Comp =:= mergingLaneRight ->
<<0:1,4:6>>;
Comp =:= curbOnLeft ->
<<0:1,5:6>>;
Comp =:= curbOnRight ->
<<0:1,6:6>>;
Comp =:= loadingzoneOnLeft ->
<<0:1,7:6>>;
Comp =:= loadingzoneOnRight ->
<<0:1,8:6>>;
Comp =:= turnOutPointOnLeft ->
<<0:1,9:6>>;
Comp =:= turnOutPointOnRight ->
<<0:1,10:6>>;
Comp =:= adjacentParkingOnLeft ->
<<0:1,11:6>>;
Comp =:= adjacentParkingOnRight ->
<<0:1,12:6>>;
Comp =:= adjacentBikeLaneOnLeft ->
<<0:1,13:6>>;
Comp =:= adjacentBikeLaneOnRight ->
<<0:1,14:6>>;
Comp =:= sharedBikeLane ->
<<0:1,15:6>>;
Comp =:= bikeBoxInFront ->
<<0:1,16:6>>;
Comp =:= transitStopOnLeft ->
<<0:1,17:6>>;
Comp =:= transitStopOnRight ->
<<0:1,18:6>>;
Comp =:= transitStopInLane ->
<<0:1,19:6>>;
Comp =:= sharedWithTrackedVehicle ->
<<0:1,20:6>>;
Comp =:= safeIsland ->
<<0:1,21:6>>;
Comp =:= lowCurbsPresent ->
<<0:1,22:6>>;
Comp =:= rumbleStripPresent ->
<<0:1,23:6>>;
Comp =:= audibleSignalingPresent ->
<<0:1,24:6>>;
Comp =:= adaptiveTimingPresent ->
<<0:1,25:6>>;
Comp =:= rfSignalRequestPresent ->
<<0:1,26:6>>;
Comp =:= partialCurbIntrusion ->
<<0:1,27:6>>;
Comp =:= taperToLeft ->
<<0:1,28:6>>;
Comp =:= taperToRight ->
<<0:1,29:6>>;
Comp =:= taperToCenterLine ->
<<0:1,30:6>>;
Comp =:= parallelParking ->
<<0:1,31:6>>;
Comp =:= headInParking ->
<<0:1,32:6>>;
Comp =:= freeParking ->
<<0:1,33:6>>;
Comp =:= timeRestrictionsOnParking ->
<<0:1,34:6>>;
Comp =:= costToPark ->
<<0:1,35:6>>;
Comp =:= midBlockCurbPresent ->
<<0:1,36:6>>;
Comp =:= unEvenPavementPresent ->
<<0:1,37:6>>;
true ->
exit({error,{asn1,{illegal_enumerated,Comp}}})
end || Comp <- Val]]
end.



dec_SegmentAttributeXYList(Bytes) ->
%% Length with constraint {1,8}
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components115(V1@Add2, V1@Buf1, []).

enc_ShapePointSet(Val) ->
#{nodeList:=Input@4} = Val,
Input@1 = case Val of
  #{anchor:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{laneWidth:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{directionality:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1>>;
true ->
<<1:1>>
end,
begin
%% attribute anchor(1) with type Position3D
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_Position3D(Input@1)
end
end,
begin
%% attribute laneWidth(2) with type INTEGER
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
Input@2 bsr 15 =:= 0 ->
<<Input@2:15>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end,
begin
%% attribute directionality(3) with type ENUMERATED
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
Input@3 =:= unavailable ->
<<0:2>>;
Input@3 =:= forward ->
<<1:2>>;
Input@3 =:= reverse ->
<<2:2>>;
Input@3 =:= both ->
<<3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@3}}})
end
end|begin
%% attribute nodeList(4) with type NodeListXY
enc_NodeListXY(Input@4)
end].


dec_ShapePointSet(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:3,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute anchor(1) with type Position3D
{Term1,Bytes3} = case (Opt bsr 2) band 1 of
1 ->
dec_Position3D(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute laneWidth(2) with type INTEGER
{Term2,Bytes4} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V3@V0:15,V3@Buf1/bitstring>> = Bytes3,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute directionality(3) with type ENUMERATED
{Term3,Bytes5} = case Opt band 1 of
1 ->
begin
<<V4@V0:2,V4@Buf1/bitstring>> = Bytes4,
V4@Int2 = case V4@V0 of
0 -> unavailable;
1 -> forward;
2 -> reverse;
3 -> both
end,
{V4@Int2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute nodeList(4) with type NodeListXY
{Term4,Bytes6} = dec_NodeListXY(Bytes5),

%% Extensions
{Extensions,Bytes7} = case Ext of
0 -> {<<>>,Bytes6};
1 ->
{V5@V0,V5@Buf1} = case Bytes6 of
<<0:1,V5@V3:6,V5@Buf4/bitstring>> ->
V5@Add5 = V5@V3 + 1,
{V5@Add5,V5@Buf4};
<<1:1,V5@Buf2/bitstring>> ->
{V5@V3,V5@Buf4} = case V5@Buf2 of
<<0:1,V5@V6:7,V5@Buf7/bitstring>> when V5@V6 =/= 0 ->
{V5@V6,V5@Buf7};
<<1:1,0:1,V5@V7:14,V5@Buf8/bitstring>> when V5@V7 =/= 0 ->
{V5@V7,V5@Buf8}
end,
{V5@V3,V5@Buf4}
end,
<<V5@V9:V5@V0/bitstring-unit:1,V5@Buf10/bitstring>> = V5@Buf1,
{V5@V9,V5@Buf10}
end,
Bytes8= skipextensions(Bytes7, 1, Extensions),
Res1 = #{nodeList=>Term4},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{anchor=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{laneWidth=>Term2}
end,
Res4 = case Term3 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{directionality=>Term3}
end,
{Res4,Bytes8}.

enc_SignalRequesterInfo(Val) ->
#{id:=Input@1,request:=Input@2,sequenceNumber:=Input@3} = Val,
Input@4 = case Val of
  #{role:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{typeData:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@4 =:= asn1__MISSING_IN_MAP ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
begin
%% attribute id(1) with type VehicleID
enc_VehicleID(Input@1)
end,
begin
%% attribute request(2) with type INTEGER
if Input@2 bsr 8 =:= 0 ->
Input@2;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end,
begin
%% attribute sequenceNumber(3) with type INTEGER
if Input@3 bsr 7 =:= 0 ->
<<Input@3:7>>;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end,
begin
%% attribute role(4) with type ENUMERATED
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
Input@4 =:= basicVehicle ->
<<0:1,0:5>>;
Input@4 =:= publicTransport ->
<<0:1,1:5>>;
Input@4 =:= specialTransport ->
<<0:1,2:5>>;
Input@4 =:= dangerousGoods ->
<<0:1,3:5>>;
Input@4 =:= roadWork ->
<<0:1,4:5>>;
Input@4 =:= roadRescue ->
<<0:1,5:5>>;
Input@4 =:= emergency ->
<<0:1,6:5>>;
Input@4 =:= safetyCar ->
<<0:1,7:5>>;
Input@4 =:= 'none-unknown' ->
<<0:1,8:5>>;
Input@4 =:= truck ->
<<0:1,9:5>>;
Input@4 =:= motorcycle ->
<<0:1,10:5>>;
Input@4 =:= roadSideSource ->
<<0:1,11:5>>;
Input@4 =:= police ->
<<0:1,12:5>>;
Input@4 =:= fire ->
<<0:1,13:5>>;
Input@4 =:= ambulance ->
<<0:1,14:5>>;
Input@4 =:= dot ->
<<0:1,15:5>>;
Input@4 =:= transit ->
<<0:1,16:5>>;
Input@4 =:= slowMoving ->
<<0:1,17:5>>;
Input@4 =:= stopNgo ->
<<0:1,18:5>>;
Input@4 =:= cyclist ->
<<0:1,19:5>>;
Input@4 =:= pedestrian ->
<<0:1,20:5>>;
Input@4 =:= nonMotorized ->
<<0:1,21:5>>;
Input@4 =:= military ->
<<0:1,22:5>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@4}}})
end
end|begin
%% attribute typeData(5) with type RequestorType
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_RequestorType(Input@5)
end
end].


dec_SignalRequesterInfo(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute id(1) with type VehicleID
{Term1,Bytes3} = dec_VehicleID(Bytes2),

%% attribute request(2) with type INTEGER
{Term2,Bytes4} = begin
<<V3@V0:8,V3@Buf1/bitstring>> = Bytes3,
{V3@V0,V3@Buf1}
end,

%% attribute sequenceNumber(3) with type INTEGER
{Term3,Bytes5} = begin
<<V4@V0:7,V4@Buf1/bitstring>> = Bytes4,
{V4@V0,V4@Buf1}
end,

%% attribute role(4) with type ENUMERATED
{Term4,Bytes6} = case (Opt bsr 1) band 1 of
1 ->
begin
{V5@V0,V5@Buf1} = case Bytes5 of
<<0:1,V5@V3:5,V5@Buf4/bitstring>> ->
V5@Int5 = case V5@V3 of
0 -> basicVehicle;
1 -> publicTransport;
2 -> specialTransport;
3 -> dangerousGoods;
4 -> roadWork;
5 -> roadRescue;
6 -> emergency;
7 -> safetyCar;
8 -> 'none-unknown';
9 -> truck;
10 -> motorcycle;
11 -> roadSideSource;
12 -> police;
13 -> fire;
14 -> ambulance;
15 -> dot;
16 -> transit;
17 -> slowMoving;
18 -> stopNgo;
19 -> cyclist;
20 -> pedestrian;
21 -> nonMotorized;
22 -> military;
_ -> exit({error,{asn1,{decode_enumerated,V5@V3}}})
end,
{V5@Int5,V5@Buf4};
<<1:1,V5@Buf2/bitstring>> ->
{V5@V3,V5@Buf4} = case V5@Buf2 of
<<0:1,V5@V6:6,V5@Buf7/bitstring>> ->
{V5@V6,V5@Buf7};
<<1:1,V5@Buf5/bitstring>> ->
{V5@V6,V5@Buf7} = case V5@Buf5 of
<<0:1,V5@V9:7,V5@Buf10/bitstring>> when V5@V9 =/= 0 ->
{V5@V9,V5@Buf10};
<<1:1,0:1,V5@V10:14,V5@Buf11/bitstring>> when V5@V10 =/= 0 ->
{V5@V10,V5@Buf11}
end,
<<V5@V12:V5@V6/unit:8,V5@Buf13/bitstring>> = V5@Buf7,
{V5@V12,V5@Buf13}
end,
V5@Int14 = case V5@V3 of
_ -> {asn1_enum,V5@V3}
end,
{V5@Int14,V5@Buf4}
end,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute typeData(5) with type RequestorType
{Term5,Bytes7} = case Opt band 1 of
1 ->
dec_RequestorType(Bytes6);
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% Extensions
{Extensions,Bytes8} = case Ext of
0 -> {<<>>,Bytes7};
1 ->
{V6@V0,V6@Buf1} = case Bytes7 of
<<0:1,V6@V3:6,V6@Buf4/bitstring>> ->
V6@Add5 = V6@V3 + 1,
{V6@Add5,V6@Buf4};
<<1:1,V6@Buf2/bitstring>> ->
{V6@V3,V6@Buf4} = case V6@Buf2 of
<<0:1,V6@V6:7,V6@Buf7/bitstring>> when V6@V6 =/= 0 ->
{V6@V6,V6@Buf7};
<<1:1,0:1,V6@V7:14,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
{V6@V7,V6@Buf8}
end,
{V6@V3,V6@Buf4}
end,
<<V6@V9:V6@V0/bitstring-unit:1,V6@Buf10/bitstring>> = V6@Buf1,
{V6@V9,V6@Buf10}
end,
Bytes9= skipextensions(Bytes8, 1, Extensions),
Res1 = #{id=>Term1,request=>Term2,sequenceNumber=>Term3},
Res2 = case Term4 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{role=>Term4}
end,
Res3 = case Term5 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{typeData=>Term5}
end,
{Res3,Bytes9}.

enc_SignalRequestList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 5 =:= 0 ->
[<<Enc1@len@sub:5>>|[enc_SignalRequestPackage(Comp) || Comp <- Val]]
end.



dec_SignalRequestList(Bytes) ->
%% Length with constraint {1,32}
<<V1@V0:5,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components116(V1@Add2, V1@Buf1, []).

enc_SignalRequestPackage(Val) ->
#{request:=Input@1} = Val,
Input@2 = case Val of
  #{minute:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{second:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{duration:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{regional:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@2 =:= asn1__MISSING_IN_MAP ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@4 =:= asn1__MISSING_IN_MAP ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
begin
%% attribute request(1) with type SignalRequest
enc_SignalRequest(Input@1)
end,
begin
%% attribute minute(2) with type INTEGER
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@2, Input@2 < 527041 ->
<<Input@2:20>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end,
begin
%% attribute second(3) with type INTEGER
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
Input@3 bsr 16 =:= 0 ->
<<Input@3:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end,
begin
%% attribute duration(4) with type INTEGER
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
Input@4 bsr 16 =:= 0 ->
<<Input@4:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@4}}})
end
end|begin
%% attribute regional(5) with type SEQUENCE OF
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_SignalRequestPackage_regional(Input@5)
end
end].
enc_SignalRequestPackage_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_SignalRequestPackage_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_SignalRequestPackage_regional_RegionalExtension(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_SignalRequestPackage(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:4,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute request(1) with type SignalRequest
{Term1,Bytes3} = dec_SignalRequest(Bytes2),

%% attribute minute(2) with type INTEGER
{Term2,Bytes4} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V3@V0:20,V3@Buf1/bitstring>> = Bytes3,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute second(3) with type INTEGER
{Term3,Bytes5} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V4@V0:16,V4@Buf1/bitstring>> = Bytes4,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute duration(4) with type INTEGER
{Term4,Bytes6} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V5@V0:16,V5@Buf1/bitstring>> = Bytes5,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute regional(5) with type SEQUENCE OF
{Term5,Bytes7} = case Opt band 1 of
1 ->
dec_SignalRequestPackage_regional(Bytes6);
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% Extensions
{Extensions,Bytes8} = case Ext of
0 -> {<<>>,Bytes7};
1 ->
{V6@V0,V6@Buf1} = case Bytes7 of
<<0:1,V6@V3:6,V6@Buf4/bitstring>> ->
V6@Add5 = V6@V3 + 1,
{V6@Add5,V6@Buf4};
<<1:1,V6@Buf2/bitstring>> ->
{V6@V3,V6@Buf4} = case V6@Buf2 of
<<0:1,V6@V6:7,V6@Buf7/bitstring>> when V6@V6 =/= 0 ->
{V6@V6,V6@Buf7};
<<1:1,0:1,V6@V7:14,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
{V6@V7,V6@Buf8}
end,
{V6@V3,V6@Buf4}
end,
<<V6@V9:V6@V0/bitstring-unit:1,V6@Buf10/bitstring>> = V6@Buf1,
{V6@V9,V6@Buf10}
end,
Bytes9= skipextensions(Bytes8, 1, Extensions),
Res1 = #{request=>Term1},
Res2 = case Term2 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{minute=>Term2}
end,
Res3 = case Term3 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{second=>Term3}
end,
Res4 = case Term4 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{duration=>Term4}
end,
Res5 = case Term5 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{regional=>Term5}
end,
{Res5,Bytes9}.


dec_SignalRequestPackage_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components117(V1@Add2, V1@Buf1, []).


dec_SignalRequestPackage_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_SignalRequest(Val) ->
#{id:=Input@1,requestID:=Input@2,requestType:=Input@3,inBoundLane:=Input@4} = Val,
Input@5 = case Val of
  #{outBoundLane:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@6 = case Val of
  #{regional:=Input@6_0} -> Input@6_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@5 =:= asn1__MISSING_IN_MAP ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
begin
%% attribute id(1) with type IntersectionReferenceID
enc_IntersectionReferenceID(Input@1)
end,
begin
%% attribute requestID(2) with type INTEGER
if Input@2 bsr 8 =:= 0 ->
Input@2;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end,
begin
%% attribute requestType(3) with type ENUMERATED
if Input@3 =:= priorityRequestTypeReserved ->
<<0:1,0:2>>;
Input@3 =:= priorityRequest ->
<<0:1,1:2>>;
Input@3 =:= priorityRequestUpdate ->
<<0:1,2:2>>;
Input@3 =:= priorityCancellation ->
<<0:1,3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@3}}})
end
end,
begin
%% attribute inBoundLane(4) with type IntersectionAccessPoint
enc_IntersectionAccessPoint(Input@4)
end,
begin
%% attribute outBoundLane(5) with type IntersectionAccessPoint
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_IntersectionAccessPoint(Input@5)
end
end|begin
%% attribute regional(6) with type SEQUENCE OF
if Input@6 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_SignalRequest_regional(Input@6)
end
end].
enc_SignalRequest_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_SignalRequest_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_SignalRequest_regional_RegionalExtension(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_SignalRequest(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute id(1) with type IntersectionReferenceID
{Term1,Bytes3} = dec_IntersectionReferenceID(Bytes2),

%% attribute requestID(2) with type INTEGER
{Term2,Bytes4} = begin
<<V3@V0:8,V3@Buf1/bitstring>> = Bytes3,
{V3@V0,V3@Buf1}
end,

%% attribute requestType(3) with type ENUMERATED
{Term3,Bytes5} = begin
{V4@V0,V4@Buf1} = case Bytes4 of
<<0:1,V4@V3:2,V4@Buf4/bitstring>> ->
V4@Int5 = case V4@V3 of
0 -> priorityRequestTypeReserved;
1 -> priorityRequest;
2 -> priorityRequestUpdate;
3 -> priorityCancellation
end,
{V4@Int5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:6,V4@Buf7/bitstring>> ->
{V4@V6,V4@Buf7};
<<1:1,V4@Buf5/bitstring>> ->
{V4@V6,V4@Buf7} = case V4@Buf5 of
<<0:1,V4@V9:7,V4@Buf10/bitstring>> when V4@V9 =/= 0 ->
{V4@V9,V4@Buf10};
<<1:1,0:1,V4@V10:14,V4@Buf11/bitstring>> when V4@V10 =/= 0 ->
{V4@V10,V4@Buf11}
end,
<<V4@V12:V4@V6/unit:8,V4@Buf13/bitstring>> = V4@Buf7,
{V4@V12,V4@Buf13}
end,
V4@Int14 = case V4@V3 of
_ -> {asn1_enum,V4@V3}
end,
{V4@Int14,V4@Buf4}
end,
{V4@V0,V4@Buf1}
end,

%% attribute inBoundLane(4) with type IntersectionAccessPoint
{Term4,Bytes6} = dec_IntersectionAccessPoint(Bytes5),

%% attribute outBoundLane(5) with type IntersectionAccessPoint
{Term5,Bytes7} = case (Opt bsr 1) band 1 of
1 ->
dec_IntersectionAccessPoint(Bytes6);
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute regional(6) with type SEQUENCE OF
{Term6,Bytes8} = case Opt band 1 of
1 ->
dec_SignalRequest_regional(Bytes7);
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% Extensions
{Extensions,Bytes9} = case Ext of
0 -> {<<>>,Bytes8};
1 ->
{V5@V0,V5@Buf1} = case Bytes8 of
<<0:1,V5@V3:6,V5@Buf4/bitstring>> ->
V5@Add5 = V5@V3 + 1,
{V5@Add5,V5@Buf4};
<<1:1,V5@Buf2/bitstring>> ->
{V5@V3,V5@Buf4} = case V5@Buf2 of
<<0:1,V5@V6:7,V5@Buf7/bitstring>> when V5@V6 =/= 0 ->
{V5@V6,V5@Buf7};
<<1:1,0:1,V5@V7:14,V5@Buf8/bitstring>> when V5@V7 =/= 0 ->
{V5@V7,V5@Buf8}
end,
{V5@V3,V5@Buf4}
end,
<<V5@V9:V5@V0/bitstring-unit:1,V5@Buf10/bitstring>> = V5@Buf1,
{V5@V9,V5@Buf10}
end,
Bytes10= skipextensions(Bytes9, 1, Extensions),
Res1 = #{id=>Term1,requestID=>Term2,requestType=>Term3,inBoundLane=>Term4},
Res2 = case Term5 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{outBoundLane=>Term5}
end,
Res3 = case Term6 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{regional=>Term6}
end,
{Res3,Bytes10}.


dec_SignalRequest_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components118(V1@Add2, V1@Buf1, []).


dec_SignalRequest_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_SignalStatusList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 5 =:= 0 ->
[<<Enc1@len@sub:5>>|[enc_SignalStatus(Comp) || Comp <- Val]]
end.



dec_SignalStatusList(Bytes) ->
%% Length with constraint {1,32}
<<V1@V0:5,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components119(V1@Add2, V1@Buf1, []).

enc_SignalStatusPackageList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 5 =:= 0 ->
[<<Enc1@len@sub:5>>|[enc_SignalStatusPackage(Comp) || Comp <- Val]]
end.



dec_SignalStatusPackageList(Bytes) ->
%% Length with constraint {1,32}
<<V1@V0:5,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components120(V1@Add2, V1@Buf1, []).

enc_SignalStatusPackage(Val) ->
#{inboundOn:=Input@2,status:=Input@7} = Val,
Input@1 = case Val of
  #{requester:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{outboundOn:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{minute:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{second:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@6 = case Val of
  #{duration:=Input@6_0} -> Input@6_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@8 = case Val of
  #{regional:=Input@8_0} -> Input@8_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@4 =:= asn1__MISSING_IN_MAP ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@6 =:= asn1__MISSING_IN_MAP ->
if Input@8 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@8 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
begin
%% attribute requester(1) with type SignalRequesterInfo
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_SignalRequesterInfo(Input@1)
end
end,
begin
%% attribute inboundOn(2) with type IntersectionAccessPoint
enc_IntersectionAccessPoint(Input@2)
end,
begin
%% attribute outboundOn(3) with type IntersectionAccessPoint
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_IntersectionAccessPoint(Input@3)
end
end,
begin
%% attribute minute(4) with type INTEGER
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@4, Input@4 < 527041 ->
<<Input@4:20>>;
true ->
exit({error,{asn1,{illegal_integer,Input@4}}})
end
end,
begin
%% attribute second(5) with type INTEGER
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
Input@5 bsr 16 =:= 0 ->
<<Input@5:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@5}}})
end
end,
begin
%% attribute duration(6) with type INTEGER
if Input@6 =:= asn1__MISSING_IN_MAP ->
[];
Input@6 bsr 16 =:= 0 ->
<<Input@6:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@6}}})
end
end,
begin
%% attribute status(7) with type ENUMERATED
if Input@7 =:= unknown ->
<<0:1,0:3>>;
Input@7 =:= requested ->
<<0:1,1:3>>;
Input@7 =:= processing ->
<<0:1,2:3>>;
Input@7 =:= watchOtherTraffic ->
<<0:1,3:3>>;
Input@7 =:= granted ->
<<0:1,4:3>>;
Input@7 =:= rejected ->
<<0:1,5:3>>;
Input@7 =:= maxPresence ->
<<0:1,6:3>>;
Input@7 =:= reserviceLocked ->
<<0:1,7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@7}}})
end
end|begin
%% attribute regional(8) with type SEQUENCE OF
if Input@8 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_SignalStatusPackage_regional(Input@8)
end
end].
enc_SignalStatusPackage_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_SignalStatusPackage_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_SignalStatusPackage_regional_RegionalExtension(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_SignalStatusPackage(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:6,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute requester(1) with type SignalRequesterInfo
{Term1,Bytes3} = case (Opt bsr 5) band 1 of
1 ->
dec_SignalRequesterInfo(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute inboundOn(2) with type IntersectionAccessPoint
{Term2,Bytes4} = dec_IntersectionAccessPoint(Bytes3),

%% attribute outboundOn(3) with type IntersectionAccessPoint
{Term3,Bytes5} = case (Opt bsr 4) band 1 of
1 ->
dec_IntersectionAccessPoint(Bytes4);
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute minute(4) with type INTEGER
{Term4,Bytes6} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V3@V0:20,V3@Buf1/bitstring>> = Bytes5,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute second(5) with type INTEGER
{Term5,Bytes7} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V4@V0:16,V4@Buf1/bitstring>> = Bytes6,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute duration(6) with type INTEGER
{Term6,Bytes8} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V5@V0:16,V5@Buf1/bitstring>> = Bytes7,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute status(7) with type ENUMERATED
{Term7,Bytes9} = begin
{V6@V0,V6@Buf1} = case Bytes8 of
<<0:1,V6@V3:3,V6@Buf4/bitstring>> ->
V6@Int5 = case V6@V3 of
0 -> unknown;
1 -> requested;
2 -> processing;
3 -> watchOtherTraffic;
4 -> granted;
5 -> rejected;
6 -> maxPresence;
7 -> reserviceLocked
end,
{V6@Int5,V6@Buf4};
<<1:1,V6@Buf2/bitstring>> ->
{V6@V3,V6@Buf4} = case V6@Buf2 of
<<0:1,V6@V6:6,V6@Buf7/bitstring>> ->
{V6@V6,V6@Buf7};
<<1:1,V6@Buf5/bitstring>> ->
{V6@V6,V6@Buf7} = case V6@Buf5 of
<<0:1,V6@V9:7,V6@Buf10/bitstring>> when V6@V9 =/= 0 ->
{V6@V9,V6@Buf10};
<<1:1,0:1,V6@V10:14,V6@Buf11/bitstring>> when V6@V10 =/= 0 ->
{V6@V10,V6@Buf11}
end,
<<V6@V12:V6@V6/unit:8,V6@Buf13/bitstring>> = V6@Buf7,
{V6@V12,V6@Buf13}
end,
V6@Int14 = case V6@V3 of
_ -> {asn1_enum,V6@V3}
end,
{V6@Int14,V6@Buf4}
end,
{V6@V0,V6@Buf1}
end,

%% attribute regional(8) with type SEQUENCE OF
{Term8,Bytes10} = case Opt band 1 of
1 ->
dec_SignalStatusPackage_regional(Bytes9);
0 ->
{asn1_NOVALUE,Bytes9}
end,

%% Extensions
{Extensions,Bytes11} = case Ext of
0 -> {<<>>,Bytes10};
1 ->
{V7@V0,V7@Buf1} = case Bytes10 of
<<0:1,V7@V3:6,V7@Buf4/bitstring>> ->
V7@Add5 = V7@V3 + 1,
{V7@Add5,V7@Buf4};
<<1:1,V7@Buf2/bitstring>> ->
{V7@V3,V7@Buf4} = case V7@Buf2 of
<<0:1,V7@V6:7,V7@Buf7/bitstring>> when V7@V6 =/= 0 ->
{V7@V6,V7@Buf7};
<<1:1,0:1,V7@V7:14,V7@Buf8/bitstring>> when V7@V7 =/= 0 ->
{V7@V7,V7@Buf8}
end,
{V7@V3,V7@Buf4}
end,
<<V7@V9:V7@V0/bitstring-unit:1,V7@Buf10/bitstring>> = V7@Buf1,
{V7@V9,V7@Buf10}
end,
Bytes12= skipextensions(Bytes11, 1, Extensions),
Res1 = #{inboundOn=>Term2,status=>Term7},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{requester=>Term1}
end,
Res3 = case Term3 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{outboundOn=>Term3}
end,
Res4 = case Term4 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{minute=>Term4}
end,
Res5 = case Term5 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{second=>Term5}
end,
Res6 = case Term6 of
  asn1_NOVALUE -> Res5;
  _ -> Res5#{duration=>Term6}
end,
Res7 = case Term8 of
  asn1_NOVALUE -> Res6;
  _ -> Res6#{regional=>Term8}
end,
{Res7,Bytes12}.


dec_SignalStatusPackage_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components121(V1@Add2, V1@Buf1, []).


dec_SignalStatusPackage_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_SignalStatus(Val) ->
#{sequenceNumber:=Input@1,id:=Input@2,sigStatus:=Input@3} = Val,
Input@4 = case Val of
  #{regional:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@4 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end,
begin
%% attribute sequenceNumber(1) with type INTEGER
if Input@1 bsr 7 =:= 0 ->
<<Input@1:7>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute id(2) with type IntersectionReferenceID
enc_IntersectionReferenceID(Input@2)
end,
begin
%% attribute sigStatus(3) with type SignalStatusPackageList
enc_SignalStatusPackageList(Input@3)
end|begin
%% attribute regional(4) with type SEQUENCE OF
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_SignalStatus_regional(Input@4)
end
end].
enc_SignalStatus_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_SignalStatus_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_SignalStatus_regional_RegionalExtension(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_SignalStatus(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:1,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute sequenceNumber(1) with type INTEGER
{Term1,Bytes3} = begin
<<V3@V0:7,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute id(2) with type IntersectionReferenceID
{Term2,Bytes4} = dec_IntersectionReferenceID(Bytes3),

%% attribute sigStatus(3) with type SignalStatusPackageList
{Term3,Bytes5} = dec_SignalStatusPackageList(Bytes4),

%% attribute regional(4) with type SEQUENCE OF
{Term4,Bytes6} = case Opt band 1 of
1 ->
dec_SignalStatus_regional(Bytes5);
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% Extensions
{Extensions,Bytes7} = case Ext of
0 -> {<<>>,Bytes6};
1 ->
{V4@V0,V4@Buf1} = case Bytes6 of
<<0:1,V4@V3:6,V4@Buf4/bitstring>> ->
V4@Add5 = V4@V3 + 1,
{V4@Add5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:7,V4@Buf7/bitstring>> when V4@V6 =/= 0 ->
{V4@V6,V4@Buf7};
<<1:1,0:1,V4@V7:14,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
{V4@V7,V4@Buf8}
end,
{V4@V3,V4@Buf4}
end,
<<V4@V9:V4@V0/bitstring-unit:1,V4@Buf10/bitstring>> = V4@Buf1,
{V4@V9,V4@Buf10}
end,
Bytes8= skipextensions(Bytes7, 1, Extensions),
Res1 = #{sequenceNumber=>Term1,id=>Term2,sigStatus=>Term3},
Res2 = case Term4 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{regional=>Term4}
end,
{Res2,Bytes8}.


dec_SignalStatus_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components122(V1@Add2, V1@Buf1, []).


dec_SignalStatus_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_SnapshotDistance(Val) ->
#{distance1:=Input@1,speed1:=Input@2,distance2:=Input@3,speed2:=Input@4} = Val,
[begin
%% attribute distance1(1) with type INTEGER
if Input@1 bsr 10 =:= 0 ->
<<Input@1:10>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute speed1(2) with type INTEGER
if Input@2 bsr 5 =:= 0 ->
<<Input@2:5>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end,
begin
%% attribute distance2(3) with type INTEGER
if Input@3 bsr 10 =:= 0 ->
<<Input@3:10>>;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end|begin
%% attribute speed2(4) with type INTEGER
if Input@4 bsr 5 =:= 0 ->
<<Input@4:5>>;
true ->
exit({error,{asn1,{illegal_integer,Input@4}}})
end
end].


dec_SnapshotDistance(Bytes) ->

%% attribute distance1(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:10,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute speed1(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:5,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute distance2(3) with type INTEGER
{Term3,Bytes3} = begin
<<V3@V0:10,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute speed2(4) with type INTEGER
{Term4,Bytes4} = begin
<<V4@V0:5,V4@Buf1/bitstring>> = Bytes3,
{V4@V0,V4@Buf1}
end,
Res1 = #{distance1=>Term1,speed1=>Term2,distance2=>Term3,speed2=>Term4},
{Res1,Bytes4}.

enc_Snapshot(Val) ->
#{thePosition:=Input@1} = Val,
Input@2 = case Val of
  #{safetyExt:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{dataSet:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@2 =:= asn1__MISSING_IN_MAP ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
begin
%% attribute thePosition(1) with type FullPositionVector
enc_FullPositionVector(Input@1)
end,
begin
%% attribute safetyExt(2) with type VehicleSafetyExtensions
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_VehicleSafetyExtensions(Input@2)
end
end|begin
%% attribute dataSet(3) with type VehicleStatus
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_VehicleStatus(Input@3)
end
end].


dec_Snapshot(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute thePosition(1) with type FullPositionVector
{Term1,Bytes3} = dec_FullPositionVector(Bytes2),

%% attribute safetyExt(2) with type VehicleSafetyExtensions
{Term2,Bytes4} = case (Opt bsr 1) band 1 of
1 ->
dec_VehicleSafetyExtensions(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute dataSet(3) with type VehicleStatus
{Term3,Bytes5} = case Opt band 1 of
1 ->
dec_VehicleStatus(Bytes4);
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% Extensions
{Extensions,Bytes6} = case Ext of
0 -> {<<>>,Bytes5};
1 ->
{V3@V0,V3@Buf1} = case Bytes5 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V9:V3@V0/bitstring-unit:1,V3@Buf10/bitstring>> = V3@Buf1,
{V3@V9,V3@Buf10}
end,
Bytes7= skipextensions(Bytes6, 1, Extensions),
Res1 = #{thePosition=>Term1},
Res2 = case Term2 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{safetyExt=>Term2}
end,
Res3 = case Term3 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{dataSet=>Term3}
end,
{Res3,Bytes7}.

enc_SnapshotTime(Val) ->
#{speed1:=Input@1,time1:=Input@2,speed2:=Input@3,time2:=Input@4} = Val,
[begin
%% attribute speed1(1) with type INTEGER
if Input@1 bsr 5 =:= 0 ->
<<Input@1:5>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute time1(2) with type INTEGER
if 0 =< Input@2, Input@2 < 62 ->
<<Input@2:6>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end,
begin
%% attribute speed2(3) with type INTEGER
if Input@3 bsr 5 =:= 0 ->
<<Input@3:5>>;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end|begin
%% attribute time2(4) with type INTEGER
if 0 =< Input@4, Input@4 < 62 ->
<<Input@4:6>>;
true ->
exit({error,{asn1,{illegal_integer,Input@4}}})
end
end].


dec_SnapshotTime(Bytes) ->

%% attribute speed1(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:5,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute time1(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:6,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute speed2(3) with type INTEGER
{Term3,Bytes3} = begin
<<V3@V0:5,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute time2(4) with type INTEGER
{Term4,Bytes4} = begin
<<V4@V0:6,V4@Buf1/bitstring>> = Bytes3,
{V4@V0,V4@Buf1}
end,
Res1 = #{speed1=>Term1,time1=>Term2,speed2=>Term3,time2=>Term4},
{Res1,Bytes4}.

enc_SpecialVehicleExtensions(Val) ->
Input@1 = case Val of
  #{vehicleAlerts:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{description:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{trailers:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1>>;
true ->
<<1:1>>
end,
begin
%% attribute vehicleAlerts(1) with type EmergencyDetails
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_EmergencyDetails(Input@1)
end
end,
begin
%% attribute description(2) with type EventDescription
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_EventDescription(Input@2)
end
end|begin
%% attribute trailers(3) with type TrailerData
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_TrailerData(Input@3)
end
end].


dec_SpecialVehicleExtensions(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:3,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute vehicleAlerts(1) with type EmergencyDetails
{Term1,Bytes3} = case (Opt bsr 2) band 1 of
1 ->
dec_EmergencyDetails(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute description(2) with type EventDescription
{Term2,Bytes4} = case (Opt bsr 1) band 1 of
1 ->
dec_EventDescription(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute trailers(3) with type TrailerData
{Term3,Bytes5} = case Opt band 1 of
1 ->
dec_TrailerData(Bytes4);
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% Extensions
{Extensions,Bytes6} = case Ext of
0 -> {<<>>,Bytes5};
1 ->
{V3@V0,V3@Buf1} = case Bytes5 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V9:V3@V0/bitstring-unit:1,V3@Buf10/bitstring>> = V3@Buf1,
{V3@V9,V3@Buf10}
end,
Bytes7= skipextensions(Bytes6, 1, Extensions),
Res1 = #{},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{vehicleAlerts=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{description=>Term2}
end,
Res4 = case Term3 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{trailers=>Term3}
end,
{Res4,Bytes7}.

enc_SpeedandHeadingandThrottleConfidence(Val) ->
#{heading:=Input@1,speed:=Input@2,throttle:=Input@3} = Val,
[begin
%% attribute heading(1) with type ENUMERATED
if Input@1 =:= unavailable ->
<<0:3>>;
Input@1 =:= prec10deg ->
<<1:3>>;
Input@1 =:= prec05deg ->
<<2:3>>;
Input@1 =:= prec01deg ->
<<3:3>>;
Input@1 =:= 'prec0-1deg' ->
<<4:3>>;
Input@1 =:= 'prec0-05deg' ->
<<5:3>>;
Input@1 =:= 'prec0-01deg' ->
<<6:3>>;
Input@1 =:= 'prec0-0125deg' ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@1}}})
end
end,
begin
%% attribute speed(2) with type ENUMERATED
if Input@2 =:= unavailable ->
<<0:3>>;
Input@2 =:= prec100ms ->
<<1:3>>;
Input@2 =:= prec10ms ->
<<2:3>>;
Input@2 =:= prec5ms ->
<<3:3>>;
Input@2 =:= prec1ms ->
<<4:3>>;
Input@2 =:= 'prec0-1ms' ->
<<5:3>>;
Input@2 =:= 'prec0-05ms' ->
<<6:3>>;
Input@2 =:= 'prec0-01ms' ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@2}}})
end
end|begin
%% attribute throttle(3) with type ENUMERATED
if Input@3 =:= unavailable ->
<<0:2>>;
Input@3 =:= prec10percent ->
<<1:2>>;
Input@3 =:= prec1percent ->
<<2:2>>;
Input@3 =:= 'prec0-5percent' ->
<<3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@3}}})
end
end].


dec_SpeedandHeadingandThrottleConfidence(Bytes) ->

%% attribute heading(1) with type ENUMERATED
{Term1,Bytes1} = begin
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> unavailable;
1 -> prec10deg;
2 -> prec05deg;
3 -> prec01deg;
4 -> 'prec0-1deg';
5 -> 'prec0-05deg';
6 -> 'prec0-01deg';
7 -> 'prec0-0125deg'
end,
{V1@Int2,V1@Buf1}
end,

%% attribute speed(2) with type ENUMERATED
{Term2,Bytes2} = begin
<<V2@V0:3,V2@Buf1/bitstring>> = Bytes1,
V2@Int2 = case V2@V0 of
0 -> unavailable;
1 -> prec100ms;
2 -> prec10ms;
3 -> prec5ms;
4 -> prec1ms;
5 -> 'prec0-1ms';
6 -> 'prec0-05ms';
7 -> 'prec0-01ms'
end,
{V2@Int2,V2@Buf1}
end,

%% attribute throttle(3) with type ENUMERATED
{Term3,Bytes3} = begin
<<V3@V0:2,V3@Buf1/bitstring>> = Bytes2,
V3@Int2 = case V3@V0 of
0 -> unavailable;
1 -> prec10percent;
2 -> prec1percent;
3 -> 'prec0-5percent'
end,
{V3@Int2,V3@Buf1}
end,
Res1 = #{heading=>Term1,speed=>Term2,throttle=>Term3},
{Res1,Bytes3}.

enc_SpeedLimitList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if 0 =< Enc1@len@sub, Enc1@len@sub < 9 ->
[<<Enc1@len@sub:4>>|[enc_RegulatorySpeedLimit(Comp) || Comp <- Val]]
end.



dec_SpeedLimitList(Bytes) ->
%% Length with constraint {1,9}
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components123(V1@Add2, V1@Buf1, []).

enc_SpeedProfileMeasurementList(Val) ->
Enc2@len = length(Val),
Enc2@len@sub = Enc2@len - 1,
if 0 =< Enc2@len@sub, Enc2@len@sub < 20 ->
[<<Enc2@len@sub:5>>|[if Comp bsr 5 =:= 0 ->
<<Comp:5>>;
true ->
exit({error,{asn1,{illegal_integer,Comp}}})
end || Comp <- Val]]
end.



dec_SpeedProfileMeasurementList(Bytes) ->
%% Length with constraint {1,20}
<<V1@V0:5,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components124(V1@Add2, V1@Buf1, []).

enc_SpeedProfile(Val) ->
#{speedReports:=Input@1} = Val,
[<<0:1>>|begin
%% attribute speedReports(1) with type SpeedProfileMeasurementList
enc_SpeedProfileMeasurementList(Input@1)
end].


dec_SpeedProfile(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute speedReports(1) with type SpeedProfileMeasurementList
{Term1,Bytes2} = dec_SpeedProfileMeasurementList(Bytes1),

%% Extensions
{Extensions,Bytes3} = case Ext of
0 -> {<<>>,Bytes2};
1 ->
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:6,V2@Buf4/bitstring>> ->
V2@Add5 = V2@V3 + 1,
{V2@Add5,V2@Buf4};
<<1:1,V2@Buf2/bitstring>> ->
{V2@V3,V2@Buf4} = case V2@Buf2 of
<<0:1,V2@V6:7,V2@Buf7/bitstring>> when V2@V6 =/= 0 ->
{V2@V6,V2@Buf7};
<<1:1,0:1,V2@V7:14,V2@Buf8/bitstring>> when V2@V7 =/= 0 ->
{V2@V7,V2@Buf8}
end,
{V2@V3,V2@Buf4}
end,
<<V2@V9:V2@V0/bitstring-unit:1,V2@Buf10/bitstring>> = V2@Buf1,
{V2@V9,V2@Buf10}
end,
Bytes4= skipextensions(Bytes3, 1, Extensions),
Res1 = #{speedReports=>Term1},
{Res1,Bytes4}.

enc_SupplementalVehicleExtensions(Val) ->
Input@1 = case Val of
  #{classification:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{classDetails:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{vehicleData:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{weatherReport:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{weatherProbe:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@6 = case Val of
  #{obstacle:=Input@6_0} -> Input@6_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@7 = case Val of
  #{status:=Input@7_0} -> Input@7_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@8 = case Val of
  #{speedProfile:=Input@8_0} -> Input@8_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@9 = case Val of
  #{theRTCM:=Input@9_0} -> Input@9_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@10 = case Val of
  #{regional:=Input@10_0} -> Input@10_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@3 =:= asn1__MISSING_IN_MAP ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@5 =:= asn1__MISSING_IN_MAP ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@7 =:= asn1__MISSING_IN_MAP ->
if Input@8 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@8 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@9 =:= asn1__MISSING_IN_MAP ->
if Input@10 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@10 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
begin
%% attribute classification(1) with type INTEGER
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute classDetails(2) with type VehicleClassification
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_VehicleClassification(Input@2)
end
end,
begin
%% attribute vehicleData(3) with type VehicleData
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_VehicleData(Input@3)
end
end,
begin
%% attribute weatherReport(4) with type WeatherReport
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_WeatherReport(Input@4)
end
end,
begin
%% attribute weatherProbe(5) with type WeatherProbe
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_WeatherProbe(Input@5)
end
end,
begin
%% attribute obstacle(6) with type ObstacleDetection
if Input@6 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_ObstacleDetection(Input@6)
end
end,
begin
%% attribute status(7) with type DisabledVehicle
if Input@7 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_DisabledVehicle(Input@7)
end
end,
begin
%% attribute speedProfile(8) with type SpeedProfile
if Input@8 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_SpeedProfile(Input@8)
end
end,
begin
%% attribute theRTCM(9) with type RTCMPackage
if Input@9 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_RTCMPackage(Input@9)
end
end|begin
%% attribute regional(10) with type SEQUENCE OF
if Input@10 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_SupplementalVehicleExtensions_regional(Input@10)
end
end].
enc_SupplementalVehicleExtensions_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_SupplementalVehicleExtensions_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_SupplementalVehicleExtensions_regional_RegionalExtension(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_SupplementalVehicleExtensions(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:10,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute classification(1) with type INTEGER
{Term1,Bytes3} = case (Opt bsr 9) band 1 of
1 ->
begin
<<V3@V0:8,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute classDetails(2) with type VehicleClassification
{Term2,Bytes4} = case (Opt bsr 8) band 1 of
1 ->
dec_VehicleClassification(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute vehicleData(3) with type VehicleData
{Term3,Bytes5} = case (Opt bsr 7) band 1 of
1 ->
dec_VehicleData(Bytes4);
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute weatherReport(4) with type WeatherReport
{Term4,Bytes6} = case (Opt bsr 6) band 1 of
1 ->
dec_WeatherReport(Bytes5);
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute weatherProbe(5) with type WeatherProbe
{Term5,Bytes7} = case (Opt bsr 5) band 1 of
1 ->
dec_WeatherProbe(Bytes6);
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute obstacle(6) with type ObstacleDetection
{Term6,Bytes8} = case (Opt bsr 4) band 1 of
1 ->
dec_ObstacleDetection(Bytes7);
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute status(7) with type DisabledVehicle
{Term7,Bytes9} = case (Opt bsr 3) band 1 of
1 ->
dec_DisabledVehicle(Bytes8);
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% attribute speedProfile(8) with type SpeedProfile
{Term8,Bytes10} = case (Opt bsr 2) band 1 of
1 ->
dec_SpeedProfile(Bytes9);
0 ->
{asn1_NOVALUE,Bytes9}
end,

%% attribute theRTCM(9) with type RTCMPackage
{Term9,Bytes11} = case (Opt bsr 1) band 1 of
1 ->
dec_RTCMPackage(Bytes10);
0 ->
{asn1_NOVALUE,Bytes10}
end,

%% attribute regional(10) with type SEQUENCE OF
{Term10,Bytes12} = case Opt band 1 of
1 ->
dec_SupplementalVehicleExtensions_regional(Bytes11);
0 ->
{asn1_NOVALUE,Bytes11}
end,

%% Extensions
{Extensions,Bytes13} = case Ext of
0 -> {<<>>,Bytes12};
1 ->
{V4@V0,V4@Buf1} = case Bytes12 of
<<0:1,V4@V3:6,V4@Buf4/bitstring>> ->
V4@Add5 = V4@V3 + 1,
{V4@Add5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:7,V4@Buf7/bitstring>> when V4@V6 =/= 0 ->
{V4@V6,V4@Buf7};
<<1:1,0:1,V4@V7:14,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
{V4@V7,V4@Buf8}
end,
{V4@V3,V4@Buf4}
end,
<<V4@V9:V4@V0/bitstring-unit:1,V4@Buf10/bitstring>> = V4@Buf1,
{V4@V9,V4@Buf10}
end,
Bytes14= skipextensions(Bytes13, 1, Extensions),
Res1 = #{},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{classification=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{classDetails=>Term2}
end,
Res4 = case Term3 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{vehicleData=>Term3}
end,
Res5 = case Term4 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{weatherReport=>Term4}
end,
Res6 = case Term5 of
  asn1_NOVALUE -> Res5;
  _ -> Res5#{weatherProbe=>Term5}
end,
Res7 = case Term6 of
  asn1_NOVALUE -> Res6;
  _ -> Res6#{obstacle=>Term6}
end,
Res8 = case Term7 of
  asn1_NOVALUE -> Res7;
  _ -> Res7#{status=>Term7}
end,
Res9 = case Term8 of
  asn1_NOVALUE -> Res8;
  _ -> Res8#{speedProfile=>Term8}
end,
Res10 = case Term9 of
  asn1_NOVALUE -> Res9;
  _ -> Res9#{theRTCM=>Term9}
end,
Res11 = case Term10 of
  asn1_NOVALUE -> Res10;
  _ -> Res10#{regional=>Term10}
end,
{Res11,Bytes14}.


dec_SupplementalVehicleExtensions_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components125(V1@Add2, V1@Buf1, []).


dec_SupplementalVehicleExtensions_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_TimeChangeDetails(Val) ->
#{minEndTime:=Input@2} = Val,
Input@1 = case Val of
  #{startTime:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{maxEndTime:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{likelyTime:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{confidence:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@6 = case Val of
  #{nextTime:=Input@6_0} -> Input@6_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@4 =:= asn1__MISSING_IN_MAP ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<0:1>>;
true ->
<<1:1>>
end,
begin
%% attribute startTime(1) with type INTEGER
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@1, Input@1 < 36002 ->
<<Input@1:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute minEndTime(2) with type INTEGER
if 0 =< Input@2, Input@2 < 36002 ->
<<Input@2:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end,
begin
%% attribute maxEndTime(3) with type INTEGER
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@3, Input@3 < 36002 ->
<<Input@3:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end,
begin
%% attribute likelyTime(4) with type INTEGER
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@4, Input@4 < 36002 ->
<<Input@4:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@4}}})
end
end,
begin
%% attribute confidence(5) with type INTEGER
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
Input@5 bsr 4 =:= 0 ->
<<Input@5:4>>;
true ->
exit({error,{asn1,{illegal_integer,Input@5}}})
end
end|begin
%% attribute nextTime(6) with type INTEGER
if Input@6 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@6, Input@6 < 36002 ->
<<Input@6:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@6}}})
end
end].


dec_TimeChangeDetails(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:5,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute startTime(1) with type INTEGER
{Term1,Bytes2} = case (Opt bsr 4) band 1 of
1 ->
begin
<<V2@V0:16,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes1}
end,

%% attribute minEndTime(2) with type INTEGER
{Term2,Bytes3} = begin
<<V3@V0:16,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute maxEndTime(3) with type INTEGER
{Term3,Bytes4} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V4@V0:16,V4@Buf1/bitstring>> = Bytes3,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute likelyTime(4) with type INTEGER
{Term4,Bytes5} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V5@V0:16,V5@Buf1/bitstring>> = Bytes4,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute confidence(5) with type INTEGER
{Term5,Bytes6} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V6@V0:4,V6@Buf1/bitstring>> = Bytes5,
{V6@V0,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute nextTime(6) with type INTEGER
{Term6,Bytes7} = case Opt band 1 of
1 ->
begin
<<V7@V0:16,V7@Buf1/bitstring>> = Bytes6,
{V7@V0,V7@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,
Res1 = #{minEndTime=>Term2},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{startTime=>Term1}
end,
Res3 = case Term3 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{maxEndTime=>Term3}
end,
Res4 = case Term4 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{likelyTime=>Term4}
end,
Res5 = case Term5 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{confidence=>Term5}
end,
Res6 = case Term6 of
  asn1_NOVALUE -> Res5;
  _ -> Res5#{nextTime=>Term6}
end,
{Res6,Bytes7}.

enc_TrailerData(Val) ->
#{sspRights:=Input@1,connection:=Input@2,units:=Input@3} = Val,
[begin
%% attribute sspRights(1) with type INTEGER
if Input@1 bsr 5 =:= 0 ->
<<0:1,Input@1:5>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute connection(2) with type PivotPointDescription
enc_PivotPointDescription(Input@2)
end|begin
%% attribute units(3) with type TrailerUnitDescriptionList
enc_TrailerUnitDescriptionList(Input@3)
end].


dec_TrailerData(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute sspRights(1) with type INTEGER
{Term1,Bytes2} = begin
<<V2@V0:5,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute connection(2) with type PivotPointDescription
{Term2,Bytes3} = dec_PivotPointDescription(Bytes2),

%% attribute units(3) with type TrailerUnitDescriptionList
{Term3,Bytes4} = dec_TrailerUnitDescriptionList(Bytes3),

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V3@V0,V3@Buf1} = case Bytes4 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V9:V3@V0/bitstring-unit:1,V3@Buf10/bitstring>> = V3@Buf1,
{V3@V9,V3@Buf10}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = #{sspRights=>Term1,connection=>Term2,units=>Term3},
{Res1,Bytes6}.

enc_TrailerHistoryPointList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if 0 =< Enc1@len@sub, Enc1@len@sub < 23 ->
[<<Enc1@len@sub:5>>|[enc_TrailerHistoryPoint(Comp) || Comp <- Val]]
end.



dec_TrailerHistoryPointList(Bytes) ->
%% Length with constraint {1,23}
<<V1@V0:5,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components126(V1@Add2, V1@Buf1, []).

enc_TrailerHistoryPoint(Val) ->
#{pivotAngle:=Input@1,timeOffset:=Input@2,positionOffset:=Input@3} = Val,
Input@4 = case Val of
  #{elevationOffset:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{heading:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@4 =:= asn1__MISSING_IN_MAP ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
begin
%% attribute pivotAngle(1) with type INTEGER
if 0 =< Input@1, Input@1 < 28801 ->
<<Input@1:15>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute timeOffset(2) with type INTEGER
Input@2@sub = Input@2 - 1,
if 0 =< Input@2@sub, Input@2@sub < 65535 ->
<<Input@2@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end,
begin
%% attribute positionOffset(3) with type Node-XY-24b
'enc_Node-XY-24b'(Input@3)
end,
begin
%% attribute elevationOffset(4) with type INTEGER
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Input@4@sub = Input@4 - -64,
if Input@4@sub bsr 7 =:= 0 ->
<<Input@4@sub:7>>;
true ->
exit({error,{asn1,{illegal_integer,Input@4}}})
end
end
end
end|begin
%% attribute heading(5) with type INTEGER
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@5, Input@5 < 241 ->
[Input@5];
true ->
exit({error,{asn1,{illegal_integer,Input@5}}})
end
end].


dec_TrailerHistoryPoint(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute pivotAngle(1) with type INTEGER
{Term1,Bytes3} = begin
<<V3@V0:15,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute timeOffset(2) with type INTEGER
{Term2,Bytes4} = begin
<<V4@V0:16,V4@Buf1/bitstring>> = Bytes3,
V4@Add2 = V4@V0 + 1,
{V4@Add2,V4@Buf1}
end,

%% attribute positionOffset(3) with type Node-XY-24b
{Term3,Bytes5} = 'dec_Node-XY-24b'(Bytes4),

%% attribute elevationOffset(4) with type INTEGER
{Term4,Bytes6} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V5@V0:7,V5@Buf1/bitstring>> = Bytes5,
V5@Add2 = V5@V0 + -64,
{V5@Add2,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute heading(5) with type INTEGER
{Term5,Bytes7} = case Opt band 1 of
1 ->
begin
<<V6@V0:8,V6@Buf1/bitstring>> = Bytes6,
{V6@V0,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% Extensions
{Extensions,Bytes8} = case Ext of
0 -> {<<>>,Bytes7};
1 ->
{V7@V0,V7@Buf1} = case Bytes7 of
<<0:1,V7@V3:6,V7@Buf4/bitstring>> ->
V7@Add5 = V7@V3 + 1,
{V7@Add5,V7@Buf4};
<<1:1,V7@Buf2/bitstring>> ->
{V7@V3,V7@Buf4} = case V7@Buf2 of
<<0:1,V7@V6:7,V7@Buf7/bitstring>> when V7@V6 =/= 0 ->
{V7@V6,V7@Buf7};
<<1:1,0:1,V7@V7:14,V7@Buf8/bitstring>> when V7@V7 =/= 0 ->
{V7@V7,V7@Buf8}
end,
{V7@V3,V7@Buf4}
end,
<<V7@V9:V7@V0/bitstring-unit:1,V7@Buf10/bitstring>> = V7@Buf1,
{V7@V9,V7@Buf10}
end,
Bytes9= skipextensions(Bytes8, 1, Extensions),
Res1 = #{pivotAngle=>Term1,timeOffset=>Term2,positionOffset=>Term3},
Res2 = case Term4 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{elevationOffset=>Term4}
end,
Res3 = case Term5 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{heading=>Term5}
end,
{Res3,Bytes9}.

enc_TrailerUnitDescriptionList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 3 =:= 0 ->
[<<Enc1@len@sub:3>>|[enc_TrailerUnitDescription(Comp) || Comp <- Val]]
end.



dec_TrailerUnitDescriptionList(Bytes) ->
%% Length with constraint {1,8}
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components127(V1@Add2, V1@Buf1, []).

enc_TrailerUnitDescription(Val) ->
#{isDolly:=Input@1,width:=Input@2,length:=Input@3,frontPivot:=Input@8,positionOffset:=Input@11} = Val,
Input@4 = case Val of
  #{height:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{mass:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@6 = case Val of
  #{bumperHeights:=Input@6_0} -> Input@6_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@7 = case Val of
  #{centerOfGravity:=Input@7_0} -> Input@7_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@9 = case Val of
  #{rearPivot:=Input@9_0} -> Input@9_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@10 = case Val of
  #{rearWheelOffset:=Input@10_0} -> Input@10_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@12 = case Val of
  #{elevationOffset:=Input@12_0} -> Input@12_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@13 = case Val of
  #{crumbData:=Input@13_0} -> Input@13_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@4 =:= asn1__MISSING_IN_MAP ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@6 =:= asn1__MISSING_IN_MAP ->
if Input@7 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@7 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@9 =:= asn1__MISSING_IN_MAP ->
if Input@10 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@10 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@12 =:= asn1__MISSING_IN_MAP ->
if Input@13 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@13 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
begin
%% attribute isDolly(1) with type BOOLEAN
if Input@1 =:= false ->
<<0:1>>;
Input@1 =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Input@1}}})
end
end,
begin
%% attribute width(2) with type INTEGER
if Input@2 bsr 10 =:= 0 ->
<<Input@2:10>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end,
begin
%% attribute length(3) with type INTEGER
if Input@3 bsr 12 =:= 0 ->
<<Input@3:12>>;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end,
begin
%% attribute height(4) with type INTEGER
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
Input@4 bsr 7 =:= 0 ->
<<Input@4:7>>;
true ->
exit({error,{asn1,{illegal_integer,Input@4}}})
end
end,
begin
%% attribute mass(5) with type INTEGER
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
Input@5 bsr 8 =:= 0 ->
Input@5;
true ->
exit({error,{asn1,{illegal_integer,Input@5}}})
end
end,
begin
%% attribute bumperHeights(6) with type BumperHeights
if Input@6 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_BumperHeights(Input@6)
end
end,
begin
%% attribute centerOfGravity(7) with type INTEGER
if Input@7 =:= asn1__MISSING_IN_MAP ->
[];
Input@7 bsr 7 =:= 0 ->
<<Input@7:7>>;
true ->
exit({error,{asn1,{illegal_integer,Input@7}}})
end
end,
begin
%% attribute frontPivot(8) with type PivotPointDescription
enc_PivotPointDescription(Input@8)
end,
begin
%% attribute rearPivot(9) with type PivotPointDescription
if Input@9 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_PivotPointDescription(Input@9)
end
end,
begin
%% attribute rearWheelOffset(10) with type INTEGER
if Input@10 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Input@10@sub = Input@10 - -2048,
if Input@10@sub bsr 12 =:= 0 ->
<<Input@10@sub:12>>;
true ->
exit({error,{asn1,{illegal_integer,Input@10}}})
end
end
end
end,
begin
%% attribute positionOffset(11) with type Node-XY-24b
'enc_Node-XY-24b'(Input@11)
end,
begin
%% attribute elevationOffset(12) with type INTEGER
if Input@12 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Input@12@sub = Input@12 - -64,
if Input@12@sub bsr 7 =:= 0 ->
<<Input@12@sub:7>>;
true ->
exit({error,{asn1,{illegal_integer,Input@12}}})
end
end
end
end|begin
%% attribute crumbData(13) with type TrailerHistoryPointList
if Input@13 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_TrailerHistoryPointList(Input@13)
end
end].


dec_TrailerUnitDescription(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute isDolly(1) with type BOOLEAN
{Term1,Bytes3} = begin
<<V3@V0:1,V3@Buf1/bitstring>> = Bytes2,
V3@Int2 = case V3@V0 of
0 -> false;
1 -> true
end,
{V3@Int2,V3@Buf1}
end,

%% attribute width(2) with type INTEGER
{Term2,Bytes4} = begin
<<V4@V0:10,V4@Buf1/bitstring>> = Bytes3,
{V4@V0,V4@Buf1}
end,

%% attribute length(3) with type INTEGER
{Term3,Bytes5} = begin
<<V5@V0:12,V5@Buf1/bitstring>> = Bytes4,
{V5@V0,V5@Buf1}
end,

%% attribute height(4) with type INTEGER
{Term4,Bytes6} = case (Opt bsr 7) band 1 of
1 ->
begin
<<V6@V0:7,V6@Buf1/bitstring>> = Bytes5,
{V6@V0,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute mass(5) with type INTEGER
{Term5,Bytes7} = case (Opt bsr 6) band 1 of
1 ->
begin
<<V7@V0:8,V7@Buf1/bitstring>> = Bytes6,
{V7@V0,V7@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute bumperHeights(6) with type BumperHeights
{Term6,Bytes8} = case (Opt bsr 5) band 1 of
1 ->
dec_BumperHeights(Bytes7);
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute centerOfGravity(7) with type INTEGER
{Term7,Bytes9} = case (Opt bsr 4) band 1 of
1 ->
begin
<<V8@V0:7,V8@Buf1/bitstring>> = Bytes8,
{V8@V0,V8@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% attribute frontPivot(8) with type PivotPointDescription
{Term8,Bytes10} = dec_PivotPointDescription(Bytes9),

%% attribute rearPivot(9) with type PivotPointDescription
{Term9,Bytes11} = case (Opt bsr 3) band 1 of
1 ->
dec_PivotPointDescription(Bytes10);
0 ->
{asn1_NOVALUE,Bytes10}
end,

%% attribute rearWheelOffset(10) with type INTEGER
{Term10,Bytes12} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V9@V0:12,V9@Buf1/bitstring>> = Bytes11,
V9@Add2 = V9@V0 + -2048,
{V9@Add2,V9@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes11}
end,

%% attribute positionOffset(11) with type Node-XY-24b
{Term11,Bytes13} = 'dec_Node-XY-24b'(Bytes12),

%% attribute elevationOffset(12) with type INTEGER
{Term12,Bytes14} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V10@V0:7,V10@Buf1/bitstring>> = Bytes13,
V10@Add2 = V10@V0 + -64,
{V10@Add2,V10@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes13}
end,

%% attribute crumbData(13) with type TrailerHistoryPointList
{Term13,Bytes15} = case Opt band 1 of
1 ->
dec_TrailerHistoryPointList(Bytes14);
0 ->
{asn1_NOVALUE,Bytes14}
end,

%% Extensions
{Extensions,Bytes16} = case Ext of
0 -> {<<>>,Bytes15};
1 ->
{V11@V0,V11@Buf1} = case Bytes15 of
<<0:1,V11@V3:6,V11@Buf4/bitstring>> ->
V11@Add5 = V11@V3 + 1,
{V11@Add5,V11@Buf4};
<<1:1,V11@Buf2/bitstring>> ->
{V11@V3,V11@Buf4} = case V11@Buf2 of
<<0:1,V11@V6:7,V11@Buf7/bitstring>> when V11@V6 =/= 0 ->
{V11@V6,V11@Buf7};
<<1:1,0:1,V11@V7:14,V11@Buf8/bitstring>> when V11@V7 =/= 0 ->
{V11@V7,V11@Buf8}
end,
{V11@V3,V11@Buf4}
end,
<<V11@V9:V11@V0/bitstring-unit:1,V11@Buf10/bitstring>> = V11@Buf1,
{V11@V9,V11@Buf10}
end,
Bytes17= skipextensions(Bytes16, 1, Extensions),
Res1 = #{isDolly=>Term1,width=>Term2,length=>Term3,frontPivot=>Term8,positionOffset=>Term11},
Res2 = case Term4 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{height=>Term4}
end,
Res3 = case Term5 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{mass=>Term5}
end,
Res4 = case Term6 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{bumperHeights=>Term6}
end,
Res5 = case Term7 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{centerOfGravity=>Term7}
end,
Res6 = case Term9 of
  asn1_NOVALUE -> Res5;
  _ -> Res5#{rearPivot=>Term9}
end,
Res7 = case Term10 of
  asn1_NOVALUE -> Res6;
  _ -> Res6#{rearWheelOffset=>Term10}
end,
Res8 = case Term12 of
  asn1_NOVALUE -> Res7;
  _ -> Res7#{elevationOffset=>Term12}
end,
Res9 = case Term13 of
  asn1_NOVALUE -> Res8;
  _ -> Res8#{crumbData=>Term13}
end,
{Res9,Bytes17}.

enc_TransmissionAndSpeed(Val) ->
#{transmisson:=Input@1,speed:=Input@2} = Val,
[begin
%% attribute transmisson(1) with type ENUMERATED
if Input@1 =:= neutral ->
<<0:3>>;
Input@1 =:= park ->
<<1:3>>;
Input@1 =:= forwardGears ->
<<2:3>>;
Input@1 =:= reverseGears ->
<<3:3>>;
Input@1 =:= reserved1 ->
<<4:3>>;
Input@1 =:= reserved2 ->
<<5:3>>;
Input@1 =:= reserved3 ->
<<6:3>>;
Input@1 =:= unavailable ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@1}}})
end
end|begin
%% attribute speed(2) with type INTEGER
if Input@2 bsr 13 =:= 0 ->
<<Input@2:13>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end].


dec_TransmissionAndSpeed(Bytes) ->

%% attribute transmisson(1) with type ENUMERATED
{Term1,Bytes1} = begin
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> neutral;
1 -> park;
2 -> forwardGears;
3 -> reverseGears;
4 -> reserved1;
5 -> reserved2;
6 -> reserved3;
7 -> unavailable
end,
{V1@Int2,V1@Buf1}
end,

%% attribute speed(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:13,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,
Res1 = #{transmisson=>Term1,speed=>Term2},
{Res1,Bytes2}.

enc_TravelerDataFrameList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 3 =:= 0 ->
[<<Enc1@len@sub:3>>|[enc_TravelerDataFrame(Comp) || Comp <- Val]]
end.



dec_TravelerDataFrameList(Bytes) ->
%% Length with constraint {1,8}
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components128(V1@Add2, V1@Buf1, []).

enc_TravelerDataFrame(Val) ->
#{sspTimRights:=Input@1,frameType:=Input@2,msgId:=Input@3,startTime:=Input@5,duratonTime:=Input@6,priority:=Input@7,sspLocationRights:=Input@8,regions:=Input@9,sspMsgRights1:=Input@10,sspMsgRights2:=Input@11,content:=Input@12} = Val,
Input@4 = case Val of
  #{startYear:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@13 = case Val of
  #{url:=Input@13_0} -> Input@13_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@4 =:= asn1__MISSING_IN_MAP ->
if Input@13 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@13 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
begin
%% attribute sspTimRights(1) with type INTEGER
if Input@1 bsr 5 =:= 0 ->
<<Input@1:5>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute frameType(2) with type ENUMERATED
if Input@2 =:= unknown ->
<<0:1,0:2>>;
Input@2 =:= advisory ->
<<0:1,1:2>>;
Input@2 =:= roadSignage ->
<<0:1,2:2>>;
Input@2 =:= commercialSignage ->
<<0:1,3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@2}}})
end
end,
begin
%% attribute msgId(3) with type CHOICE
enc_TravelerDataFrame_msgId(Input@3)
end,
begin
%% attribute startYear(4) with type INTEGER
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
Input@4 bsr 12 =:= 0 ->
<<Input@4:12>>;
true ->
exit({error,{asn1,{illegal_integer,Input@4}}})
end
end,
begin
%% attribute startTime(5) with type INTEGER
if 0 =< Input@5, Input@5 < 527041 ->
<<Input@5:20>>;
true ->
exit({error,{asn1,{illegal_integer,Input@5}}})
end
end,
begin
%% attribute duratonTime(6) with type INTEGER
if 0 =< Input@6, Input@6 < 32001 ->
<<Input@6:15>>;
true ->
exit({error,{asn1,{illegal_integer,Input@6}}})
end
end,
begin
%% attribute priority(7) with type INTEGER
if Input@7 bsr 3 =:= 0 ->
<<Input@7:3>>;
true ->
exit({error,{asn1,{illegal_integer,Input@7}}})
end
end,
begin
%% attribute sspLocationRights(8) with type INTEGER
if Input@8 bsr 5 =:= 0 ->
<<Input@8:5>>;
true ->
exit({error,{asn1,{illegal_integer,Input@8}}})
end
end,
begin
%% attribute regions(9) with type SEQUENCE OF
enc_TravelerDataFrame_regions(Input@9)
end,
begin
%% attribute sspMsgRights1(10) with type INTEGER
if Input@10 bsr 5 =:= 0 ->
<<Input@10:5>>;
true ->
exit({error,{asn1,{illegal_integer,Input@10}}})
end
end,
begin
%% attribute sspMsgRights2(11) with type INTEGER
if Input@11 bsr 5 =:= 0 ->
<<Input@11:5>>;
true ->
exit({error,{asn1,{illegal_integer,Input@11}}})
end
end,
begin
%% attribute content(12) with type CHOICE
enc_TravelerDataFrame_content(Input@12)
end|begin
%% attribute url(13) with type IA5String
if Input@13 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Enc12@len = length(Input@13),
Enc12@bin = encode_chars(Input@13, 7),
Enc12@len@sub = Enc12@len - 1,
if 0 =< Enc12@len@sub, Enc12@len@sub < 15 ->
[<<Enc12@len@sub:4>>|Enc12@bin]
end
end
end
end].
enc_TravelerDataFrame_msgId(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= furtherInfoID ->
begin
[<<0:1>>|enc_Binary_Id(ChoiceVal, 2)]
end;
ChoiceTag =:= roadSignID ->
[<<1:1>>|enc_RoadSignID(ChoiceVal)]
end.
enc_TravelerDataFrame_regions(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 4 =:= 0 ->
[<<Enc1@len@sub:4>>|[enc_GeographicalPath(Comp) || Comp <- Val]]
end.

enc_TravelerDataFrame_content(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= advisory ->
[<<0:3>>|'ITIS':enc_ITIScodesAndText(ChoiceVal)];
ChoiceTag =:= workZone ->
[<<1:3>>|enc_WorkZone(ChoiceVal)];
ChoiceTag =:= genericSign ->
[<<2:3>>|enc_GenericSignage(ChoiceVal)];
ChoiceTag =:= speedLimit ->
[<<3:3>>|enc_SpeedLimit(ChoiceVal)];
ChoiceTag =:= exitService ->
[<<4:3>>|enc_ExitService(ChoiceVal)]
end.


dec_TravelerDataFrame(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute sspTimRights(1) with type INTEGER
{Term1,Bytes3} = begin
<<V3@V0:5,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute frameType(2) with type ENUMERATED
{Term2,Bytes4} = begin
{V4@V0,V4@Buf1} = case Bytes3 of
<<0:1,V4@V3:2,V4@Buf4/bitstring>> ->
V4@Int5 = case V4@V3 of
0 -> unknown;
1 -> advisory;
2 -> roadSignage;
3 -> commercialSignage
end,
{V4@Int5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:6,V4@Buf7/bitstring>> ->
{V4@V6,V4@Buf7};
<<1:1,V4@Buf5/bitstring>> ->
{V4@V6,V4@Buf7} = case V4@Buf5 of
<<0:1,V4@V9:7,V4@Buf10/bitstring>> when V4@V9 =/= 0 ->
{V4@V9,V4@Buf10};
<<1:1,0:1,V4@V10:14,V4@Buf11/bitstring>> when V4@V10 =/= 0 ->
{V4@V10,V4@Buf11}
end,
<<V4@V12:V4@V6/unit:8,V4@Buf13/bitstring>> = V4@Buf7,
{V4@V12,V4@Buf13}
end,
V4@Int14 = case V4@V3 of
_ -> {asn1_enum,V4@V3}
end,
{V4@Int14,V4@Buf4}
end,
{V4@V0,V4@Buf1}
end,

%% attribute msgId(3) with type CHOICE
{Term3,Bytes5} = dec_TravelerDataFrame_msgId(Bytes4),

%% attribute startYear(4) with type INTEGER
{Term4,Bytes6} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V5@V0:12,V5@Buf1/bitstring>> = Bytes5,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute startTime(5) with type INTEGER
{Term5,Bytes7} = begin
<<V6@V0:20,V6@Buf1/bitstring>> = Bytes6,
{V6@V0,V6@Buf1}
end,

%% attribute duratonTime(6) with type INTEGER
{Term6,Bytes8} = begin
<<V7@V0:15,V7@Buf1/bitstring>> = Bytes7,
{V7@V0,V7@Buf1}
end,

%% attribute priority(7) with type INTEGER
{Term7,Bytes9} = begin
<<V8@V0:3,V8@Buf1/bitstring>> = Bytes8,
{V8@V0,V8@Buf1}
end,

%% attribute sspLocationRights(8) with type INTEGER
{Term8,Bytes10} = begin
<<V9@V0:5,V9@Buf1/bitstring>> = Bytes9,
{V9@V0,V9@Buf1}
end,

%% attribute regions(9) with type SEQUENCE OF
{Term9,Bytes11} = dec_TravelerDataFrame_regions(Bytes10),

%% attribute sspMsgRights1(10) with type INTEGER
{Term10,Bytes12} = begin
<<V10@V0:5,V10@Buf1/bitstring>> = Bytes11,
{V10@V0,V10@Buf1}
end,

%% attribute sspMsgRights2(11) with type INTEGER
{Term11,Bytes13} = begin
<<V11@V0:5,V11@Buf1/bitstring>> = Bytes12,
{V11@V0,V11@Buf1}
end,

%% attribute content(12) with type CHOICE
{Term12,Bytes14} = dec_TravelerDataFrame_content(Bytes13),

%% attribute url(13) with type IA5String
{Term13,Bytes15} = case Opt band 1 of
1 ->
begin
<<V12@V0:4,V12@Buf1/bitstring>> = Bytes14,
V12@Add2 = V12@V0 + 1,
<<V12@V3:V12@Add2/binary-unit:7,V12@Buf4/bitstring>> = V12@Buf1,
{V12@V5,V12@Buf6}  = {decode_chars(V12@V3, 7),V12@Buf4},
{V12@V5,V12@Buf6}
end;
0 ->
{asn1_NOVALUE,Bytes14}
end,

%% Extensions
{Extensions,Bytes16} = case Ext of
0 -> {<<>>,Bytes15};
1 ->
{V13@V0,V13@Buf1} = case Bytes15 of
<<0:1,V13@V3:6,V13@Buf4/bitstring>> ->
V13@Add5 = V13@V3 + 1,
{V13@Add5,V13@Buf4};
<<1:1,V13@Buf2/bitstring>> ->
{V13@V3,V13@Buf4} = case V13@Buf2 of
<<0:1,V13@V6:7,V13@Buf7/bitstring>> when V13@V6 =/= 0 ->
{V13@V6,V13@Buf7};
<<1:1,0:1,V13@V7:14,V13@Buf8/bitstring>> when V13@V7 =/= 0 ->
{V13@V7,V13@Buf8}
end,
{V13@V3,V13@Buf4}
end,
<<V13@V9:V13@V0/bitstring-unit:1,V13@Buf10/bitstring>> = V13@Buf1,
{V13@V9,V13@Buf10}
end,
Bytes17= skipextensions(Bytes16, 1, Extensions),
Res1 = #{sspTimRights=>Term1,frameType=>Term2,msgId=>Term3,startTime=>Term5,duratonTime=>Term6,priority=>Term7,sspLocationRights=>Term8,regions=>Term9,sspMsgRights1=>Term10,sspMsgRights2=>Term11,content=>Term12},
Res2 = case Term4 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{startYear=>Term4}
end,
Res3 = case Term13 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{url=>Term13}
end,
{Res3,Bytes17}.


dec_TravelerDataFrame_msgId(Bytes) ->
{Choice,Bytes1} = 
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
begin
<<V2@V0:2/binary-unit:8,V2@Buf1/bitstring>> = Bytes1,
V2@Conv2 = binary:copy(V2@V0),
{V2@Conv2,V2@Buf1}
end
end,
{{furtherInfoID,dec_Binary_Id(Val)},NewBytes};
1 ->
{Val,NewBytes} = begin
dec_RoadSignID(Bytes1)
end,
{{roadSignID,Val},NewBytes}
end.

dec_TravelerDataFrame_regions(Bytes) ->
%% Length with constraint {1,16}
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components129(V1@Add2, V1@Buf1, []).


dec_TravelerDataFrame_content(Bytes) ->
{Choice,Bytes1} = 
begin
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
'ITIS':dec_ITIScodesAndText(Bytes1)
end,
{{advisory,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
dec_WorkZone(Bytes1)
end,
{{workZone,Val},NewBytes};
2 ->
{Val,NewBytes} = begin
dec_GenericSignage(Bytes1)
end,
{{genericSign,Val},NewBytes};
3 ->
{Val,NewBytes} = begin
dec_SpeedLimit(Bytes1)
end,
{{speedLimit,Val},NewBytes};
4 ->
{Val,NewBytes} = begin
dec_ExitService(Bytes1)
end,
{{exitService,Val},NewBytes}
end.
enc_ValidRegion(Val) ->
#{direction:=Input@1,area:=Input@3} = Val,
Input@2 = case Val of
  #{extent:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1>>;
true ->
<<1:1>>
end,
begin
%% attribute direction(1) with type BIT STRING
Enc1@bs = try bit_string_name2pos_23(Input@1) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(Input@1, 16)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 16 ->
Enc1@bs
end
end,
begin
%% attribute extent(2) with type ENUMERATED
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
Input@2 =:= useInstantlyOnly ->
<<0:4>>;
Input@2 =:= useFor3meters ->
<<1:4>>;
Input@2 =:= useFor10meters ->
<<2:4>>;
Input@2 =:= useFor50meters ->
<<3:4>>;
Input@2 =:= useFor100meters ->
<<4:4>>;
Input@2 =:= useFor500meters ->
<<5:4>>;
Input@2 =:= useFor1000meters ->
<<6:4>>;
Input@2 =:= useFor5000meters ->
<<7:4>>;
Input@2 =:= useFor10000meters ->
<<8:4>>;
Input@2 =:= useFor50000meters ->
<<9:4>>;
Input@2 =:= useFor100000meters ->
<<10:4>>;
Input@2 =:= useFor500000meters ->
<<11:4>>;
Input@2 =:= useFor1000000meters ->
<<12:4>>;
Input@2 =:= useFor5000000meters ->
<<13:4>>;
Input@2 =:= useFor10000000meters ->
<<14:4>>;
Input@2 =:= forever ->
<<15:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@2}}})
end
end|begin
%% attribute area(3) with type CHOICE
enc_ValidRegion_area(Input@3)
end].
enc_ValidRegion_area(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= shapePointSet ->
[<<0:2>>|enc_ShapePointSet(ChoiceVal)];
ChoiceTag =:= circle ->
[<<1:2>>|enc_Circle(ChoiceVal)];
ChoiceTag =:= regionPointSet ->
[<<2:2>>|enc_RegionPointSet(ChoiceVal)]
end.


dec_ValidRegion(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute direction(1) with type BIT STRING
{Term1,Bytes2} = begin
<<V2@V0:16/binary-unit:1,V2@Buf1/bitstring>> = Bytes1,
{V2@V2,V2@Buf3}  = {decode_named_bit_string(V2@V0, [{'from000-0to022-5degrees',0},{'from022-5to045-0degrees',1},{'from045-0to067-5degrees',2},{'from067-5to090-0degrees',3},{'from090-0to112-5degrees',4},{'from112-5to135-0degrees',5},{'from135-0to157-5degrees',6},{'from157-5to180-0degrees',7},{'from180-0to202-5degrees',8},{'from202-5to225-0degrees',9},{'from225-0to247-5degrees',10},{'from247-5to270-0degrees',11},{'from270-0to292-5degrees',12},{'from292-5to315-0degrees',13},{'from315-0to337-5degrees',14},{'from337-5to360-0degrees',15}]),V2@Buf1},
{V2@V2,V2@Buf3}
end,

%% attribute extent(2) with type ENUMERATED
{Term2,Bytes3} = case Opt band 1 of
1 ->
begin
<<V3@V0:4,V3@Buf1/bitstring>> = Bytes2,
V3@Int2 = case V3@V0 of
0 -> useInstantlyOnly;
1 -> useFor3meters;
2 -> useFor10meters;
3 -> useFor50meters;
4 -> useFor100meters;
5 -> useFor500meters;
6 -> useFor1000meters;
7 -> useFor5000meters;
8 -> useFor10000meters;
9 -> useFor50000meters;
10 -> useFor100000meters;
11 -> useFor500000meters;
12 -> useFor1000000meters;
13 -> useFor5000000meters;
14 -> useFor10000000meters;
15 -> forever
end,
{V3@Int2,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute area(3) with type CHOICE
{Term3,Bytes4} = dec_ValidRegion_area(Bytes3),
Res1 = #{direction=>Term1,area=>Term3},
Res2 = case Term2 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{extent=>Term2}
end,
{Res2,Bytes4}.


dec_ValidRegion_area(Bytes) ->
{Choice,Bytes1} = 
begin
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
dec_ShapePointSet(Bytes1)
end,
{{shapePointSet,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
dec_Circle(Bytes1)
end,
{{circle,Val},NewBytes};
2 ->
{Val,NewBytes} = begin
dec_RegionPointSet(Bytes1)
end,
{{regionPointSet,Val},NewBytes}
end.
enc_VehicleClassification(Val) ->
Input@1 = case Val of
  #{keyType:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{role:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{iso3883:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{hpmsType:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{vehicleType:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@6 = case Val of
  #{responseEquip:=Input@6_0} -> Input@6_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@7 = case Val of
  #{responderType:=Input@7_0} -> Input@7_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@8 = case Val of
  #{fuelType:=Input@8_0} -> Input@8_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@9 = case Val of
  #{regional:=Input@9_0} -> Input@9_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@3 =:= asn1__MISSING_IN_MAP ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@5 =:= asn1__MISSING_IN_MAP ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@7 =:= asn1__MISSING_IN_MAP ->
if Input@8 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@8 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@9 =:= asn1__MISSING_IN_MAP ->
<<0:1>>;
true ->
<<1:1>>
end,
begin
%% attribute keyType(1) with type INTEGER
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute role(2) with type ENUMERATED
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
Input@2 =:= basicVehicle ->
<<0:1,0:5>>;
Input@2 =:= publicTransport ->
<<0:1,1:5>>;
Input@2 =:= specialTransport ->
<<0:1,2:5>>;
Input@2 =:= dangerousGoods ->
<<0:1,3:5>>;
Input@2 =:= roadWork ->
<<0:1,4:5>>;
Input@2 =:= roadRescue ->
<<0:1,5:5>>;
Input@2 =:= emergency ->
<<0:1,6:5>>;
Input@2 =:= safetyCar ->
<<0:1,7:5>>;
Input@2 =:= 'none-unknown' ->
<<0:1,8:5>>;
Input@2 =:= truck ->
<<0:1,9:5>>;
Input@2 =:= motorcycle ->
<<0:1,10:5>>;
Input@2 =:= roadSideSource ->
<<0:1,11:5>>;
Input@2 =:= police ->
<<0:1,12:5>>;
Input@2 =:= fire ->
<<0:1,13:5>>;
Input@2 =:= ambulance ->
<<0:1,14:5>>;
Input@2 =:= dot ->
<<0:1,15:5>>;
Input@2 =:= transit ->
<<0:1,16:5>>;
Input@2 =:= slowMoving ->
<<0:1,17:5>>;
Input@2 =:= stopNgo ->
<<0:1,18:5>>;
Input@2 =:= cyclist ->
<<0:1,19:5>>;
Input@2 =:= pedestrian ->
<<0:1,20:5>>;
Input@2 =:= nonMotorized ->
<<0:1,21:5>>;
Input@2 =:= military ->
<<0:1,22:5>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@2}}})
end
end,
begin
%% attribute iso3883(3) with type INTEGER
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@3, Input@3 < 101 ->
<<Input@3:7>>;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end,
begin
%% attribute hpmsType(4) with type ENUMERATED
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
Input@4 =:= none ->
<<0:1,0:4>>;
Input@4 =:= unknown ->
<<0:1,1:4>>;
Input@4 =:= special ->
<<0:1,2:4>>;
Input@4 =:= moto ->
<<0:1,3:4>>;
Input@4 =:= car ->
<<0:1,4:4>>;
Input@4 =:= carOther ->
<<0:1,5:4>>;
Input@4 =:= bus ->
<<0:1,6:4>>;
Input@4 =:= axleCnt2 ->
<<0:1,7:4>>;
Input@4 =:= axleCnt3 ->
<<0:1,8:4>>;
Input@4 =:= axleCnt4 ->
<<0:1,9:4>>;
Input@4 =:= axleCnt4Trailer ->
<<0:1,10:4>>;
Input@4 =:= axleCnt5Trailer ->
<<0:1,11:4>>;
Input@4 =:= axleCnt6Trailer ->
<<0:1,12:4>>;
Input@4 =:= axleCnt5MultiTrailer ->
<<0:1,13:4>>;
Input@4 =:= axleCnt6MultiTrailer ->
<<0:1,14:4>>;
Input@4 =:= axleCnt7MultiTrailer ->
<<0:1,15:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@4}}})
end
end,
begin
%% attribute vehicleType(5) with type ENUMERATED
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
Input@5 =:= 'all-vehicles' ->
<<0:1,0:6>>;
Input@5 =:= bicycles ->
<<0:1,1:6>>;
Input@5 =:= motorcycles ->
<<0:1,2:6>>;
Input@5 =:= cars ->
<<0:1,3:6>>;
Input@5 =:= 'light-vehicles' ->
<<0:1,4:6>>;
Input@5 =:= 'cars-and-light-vehicles' ->
<<0:1,5:6>>;
Input@5 =:= 'cars-with-trailers' ->
<<0:1,6:6>>;
Input@5 =:= 'cars-with-recreational-trailers' ->
<<0:1,7:6>>;
Input@5 =:= 'vehicles-with-trailers' ->
<<0:1,8:6>>;
Input@5 =:= 'heavy-vehicles' ->
<<0:1,9:6>>;
Input@5 =:= trucks ->
<<0:1,10:6>>;
Input@5 =:= buses ->
<<0:1,11:6>>;
Input@5 =:= 'articulated-buses' ->
<<0:1,12:6>>;
Input@5 =:= 'school-buses' ->
<<0:1,13:6>>;
Input@5 =:= 'vehicles-with-semi-trailers' ->
<<0:1,14:6>>;
Input@5 =:= 'vehicles-with-double-trailers' ->
<<0:1,15:6>>;
Input@5 =:= 'high-profile-vehicles' ->
<<0:1,16:6>>;
Input@5 =:= 'wide-vehicles' ->
<<0:1,17:6>>;
Input@5 =:= 'long-vehicles' ->
<<0:1,18:6>>;
Input@5 =:= 'hazardous-loads' ->
<<0:1,19:6>>;
Input@5 =:= 'exceptional-loads' ->
<<0:1,20:6>>;
Input@5 =:= 'abnormal-loads' ->
<<0:1,21:6>>;
Input@5 =:= convoys ->
<<0:1,22:6>>;
Input@5 =:= 'maintenance-vehicles' ->
<<0:1,23:6>>;
Input@5 =:= 'delivery-vehicles' ->
<<0:1,24:6>>;
Input@5 =:= 'vehicles-with-even-numbered-license-plates' ->
<<0:1,25:6>>;
Input@5 =:= 'vehicles-with-odd-numbered-license-plates' ->
<<0:1,26:6>>;
Input@5 =:= 'vehicles-with-parking-permits' ->
<<0:1,27:6>>;
Input@5 =:= 'vehicles-with-catalytic-converters' ->
<<0:1,28:6>>;
Input@5 =:= 'vehicles-without-catalytic-converters' ->
<<0:1,29:6>>;
Input@5 =:= 'gas-powered-vehicles' ->
<<0:1,30:6>>;
Input@5 =:= 'diesel-powered-vehicles' ->
<<0:1,31:6>>;
Input@5 =:= 'lPG-vehicles' ->
<<0:1,32:6>>;
Input@5 =:= 'military-convoys' ->
<<0:1,33:6>>;
Input@5 =:= 'military-vehicles' ->
<<0:1,34:6>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@5}}})
end
end,
begin
%% attribute responseEquip(6) with type ENUMERATED
if Input@6 =:= asn1__MISSING_IN_MAP ->
[];
Input@6 =:= 'ground-fire-suppression' ->
<<0:1,0:7>>;
Input@6 =:= 'heavy-ground-equipment' ->
<<0:1,1:7>>;
Input@6 =:= aircraft ->
<<0:1,2:7>>;
Input@6 =:= 'marine-equipment' ->
<<0:1,3:7>>;
Input@6 =:= 'support-equipment' ->
<<0:1,4:7>>;
Input@6 =:= 'medical-rescue-unit' ->
<<0:1,5:7>>;
Input@6 =:= other ->
<<0:1,6:7>>;
Input@6 =:= 'ground-fire-suppression-other' ->
<<0:1,7:7>>;
Input@6 =:= engine ->
<<0:1,8:7>>;
Input@6 =:= 'truck-or-aerial' ->
<<0:1,9:7>>;
Input@6 =:= quint ->
<<0:1,10:7>>;
Input@6 =:= 'tanker-pumper-combination' ->
<<0:1,11:7>>;
Input@6 =:= 'brush-truck' ->
<<0:1,12:7>>;
Input@6 =:= 'aircraft-rescue-firefighting' ->
<<0:1,13:7>>;
Input@6 =:= 'heavy-ground-equipment-other' ->
<<0:1,14:7>>;
Input@6 =:= 'dozer-or-plow' ->
<<0:1,15:7>>;
Input@6 =:= tractor ->
<<0:1,16:7>>;
Input@6 =:= 'tanker-or-tender' ->
<<0:1,17:7>>;
Input@6 =:= 'aircraft-other' ->
<<0:1,18:7>>;
Input@6 =:= 'aircraft-fixed-wing-tanker' ->
<<0:1,19:7>>;
Input@6 =:= helitanker ->
<<0:1,20:7>>;
Input@6 =:= helicopter ->
<<0:1,21:7>>;
Input@6 =:= 'marine-equipment-other' ->
<<0:1,22:7>>;
Input@6 =:= 'fire-boat-with-pump' ->
<<0:1,23:7>>;
Input@6 =:= 'boat-no-pump' ->
<<0:1,24:7>>;
Input@6 =:= 'support-apparatus-other' ->
<<0:1,25:7>>;
Input@6 =:= 'breathing-apparatus-support' ->
<<0:1,26:7>>;
Input@6 =:= 'light-and-air-unit' ->
<<0:1,27:7>>;
Input@6 =:= 'medical-rescue-unit-other' ->
<<0:1,28:7>>;
Input@6 =:= 'rescue-unit' ->
<<0:1,29:7>>;
Input@6 =:= 'urban-search-rescue-unit' ->
<<0:1,30:7>>;
Input@6 =:= 'high-angle-rescue' ->
<<0:1,31:7>>;
Input@6 =:= 'crash-fire-rescue' ->
<<0:1,32:7>>;
Input@6 =:= 'bLS-unit' ->
<<0:1,33:7>>;
Input@6 =:= 'aLS-unit' ->
<<0:1,34:7>>;
Input@6 =:= 'mobile-command-post' ->
<<0:1,35:7>>;
Input@6 =:= 'chief-officer-car' ->
<<0:1,36:7>>;
Input@6 =:= 'hAZMAT-unit' ->
<<0:1,37:7>>;
Input@6 =:= 'type-i-hand-crew' ->
<<0:1,38:7>>;
Input@6 =:= 'type-ii-hand-crew' ->
<<0:1,39:7>>;
Input@6 =:= 'privately-owned-vehicle' ->
<<0:1,40:7>>;
Input@6 =:= 'other-apparatus-resource' ->
<<0:1,41:7>>;
Input@6 =:= ambulance ->
<<0:1,42:7>>;
Input@6 =:= 'bomb-squad-van' ->
<<0:1,43:7>>;
Input@6 =:= 'combine-harvester' ->
<<0:1,44:7>>;
Input@6 =:= 'construction-vehicle' ->
<<0:1,45:7>>;
Input@6 =:= 'farm-tractor' ->
<<0:1,46:7>>;
Input@6 =:= 'grass-cutting-machines' ->
<<0:1,47:7>>;
Input@6 =:= 'hAZMAT-containment-tow' ->
<<0:1,48:7>>;
Input@6 =:= 'heavy-tow' ->
<<0:1,49:7>>;
Input@6 =:= 'hedge-cutting-machines' ->
<<0:1,50:7>>;
Input@6 =:= 'light-tow' ->
<<0:1,51:7>>;
Input@6 =:= 'mobile-crane' ->
<<0:1,52:7>>;
Input@6 =:= 'refuse-collection-vehicle' ->
<<0:1,53:7>>;
Input@6 =:= 'resurfacing-vehicle' ->
<<0:1,54:7>>;
Input@6 =:= 'road-sweeper' ->
<<0:1,55:7>>;
Input@6 =:= 'roadside-litter-collection-crews' ->
<<0:1,56:7>>;
Input@6 =:= 'salvage-vehicle' ->
<<0:1,57:7>>;
Input@6 =:= 'sand-truck' ->
<<0:1,58:7>>;
Input@6 =:= snowplow ->
<<0:1,59:7>>;
Input@6 =:= 'steam-roller' ->
<<0:1,60:7>>;
Input@6 =:= 'swat-team-van' ->
<<0:1,61:7>>;
Input@6 =:= 'track-laying-vehicle' ->
<<0:1,62:7>>;
Input@6 =:= 'unknown-vehicle' ->
<<0:1,63:7>>;
Input@6 =:= 'white-lining-vehicle' ->
<<0:1,64:7>>;
Input@6 =:= 'dump-truck' ->
<<0:1,65:7>>;
Input@6 =:= 'supervisor-vehicle' ->
<<0:1,66:7>>;
Input@6 =:= 'snow-blower' ->
<<0:1,67:7>>;
Input@6 =:= 'rotary-snow-blower' ->
<<0:1,68:7>>;
Input@6 =:= 'road-grader' ->
<<0:1,69:7>>;
Input@6 =:= 'steam-truck' ->
<<0:1,70:7>>;
Input@6 =:= 'flatbed-tow' ->
<<0:1,71:7>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@6}}})
end
end,
begin
%% attribute responderType(7) with type ENUMERATED
if Input@7 =:= asn1__MISSING_IN_MAP ->
[];
Input@7 =:= 'emergency-vehicle-units' ->
<<0:1,0:4>>;
Input@7 =:= 'federal-law-enforcement-units' ->
<<0:1,1:4>>;
Input@7 =:= 'state-police-units' ->
<<0:1,2:4>>;
Input@7 =:= 'county-police-units' ->
<<0:1,3:4>>;
Input@7 =:= 'local-police-units' ->
<<0:1,4:4>>;
Input@7 =:= 'ambulance-units' ->
<<0:1,5:4>>;
Input@7 =:= 'rescue-units' ->
<<0:1,6:4>>;
Input@7 =:= 'fire-units' ->
<<0:1,7:4>>;
Input@7 =:= 'hAZMAT-units' ->
<<0:1,8:4>>;
Input@7 =:= 'light-tow-unit' ->
<<0:1,9:4>>;
Input@7 =:= 'heavy-tow-unit' ->
<<0:1,10:4>>;
Input@7 =:= 'freeway-service-patrols' ->
<<0:1,11:4>>;
Input@7 =:= 'transportation-response-units' ->
<<0:1,12:4>>;
Input@7 =:= 'private-contractor-response-units' ->
<<0:1,13:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@7}}})
end
end,
begin
%% attribute fuelType(8) with type INTEGER
if Input@8 =:= asn1__MISSING_IN_MAP ->
[];
Input@8 bsr 4 =:= 0 ->
<<Input@8:4>>;
true ->
exit({error,{asn1,{illegal_integer,Input@8}}})
end
end|begin
%% attribute regional(9) with type SEQUENCE OF
if Input@9 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_VehicleClassification_regional(Input@9)
end
end].
enc_VehicleClassification_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_VehicleClassification_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_VehicleClassification_regional_RegionalExtension(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_VehicleClassification(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:9,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute keyType(1) with type INTEGER
{Term1,Bytes3} = case (Opt bsr 8) band 1 of
1 ->
begin
<<V3@V0:8,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute role(2) with type ENUMERATED
{Term2,Bytes4} = case (Opt bsr 7) band 1 of
1 ->
begin
{V4@V0,V4@Buf1} = case Bytes3 of
<<0:1,V4@V3:5,V4@Buf4/bitstring>> ->
V4@Int5 = case V4@V3 of
0 -> basicVehicle;
1 -> publicTransport;
2 -> specialTransport;
3 -> dangerousGoods;
4 -> roadWork;
5 -> roadRescue;
6 -> emergency;
7 -> safetyCar;
8 -> 'none-unknown';
9 -> truck;
10 -> motorcycle;
11 -> roadSideSource;
12 -> police;
13 -> fire;
14 -> ambulance;
15 -> dot;
16 -> transit;
17 -> slowMoving;
18 -> stopNgo;
19 -> cyclist;
20 -> pedestrian;
21 -> nonMotorized;
22 -> military;
_ -> exit({error,{asn1,{decode_enumerated,V4@V3}}})
end,
{V4@Int5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:6,V4@Buf7/bitstring>> ->
{V4@V6,V4@Buf7};
<<1:1,V4@Buf5/bitstring>> ->
{V4@V6,V4@Buf7} = case V4@Buf5 of
<<0:1,V4@V9:7,V4@Buf10/bitstring>> when V4@V9 =/= 0 ->
{V4@V9,V4@Buf10};
<<1:1,0:1,V4@V10:14,V4@Buf11/bitstring>> when V4@V10 =/= 0 ->
{V4@V10,V4@Buf11}
end,
<<V4@V12:V4@V6/unit:8,V4@Buf13/bitstring>> = V4@Buf7,
{V4@V12,V4@Buf13}
end,
V4@Int14 = case V4@V3 of
_ -> {asn1_enum,V4@V3}
end,
{V4@Int14,V4@Buf4}
end,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute iso3883(3) with type INTEGER
{Term3,Bytes5} = case (Opt bsr 6) band 1 of
1 ->
begin
<<V5@V0:7,V5@Buf1/bitstring>> = Bytes4,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute hpmsType(4) with type ENUMERATED
{Term4,Bytes6} = case (Opt bsr 5) band 1 of
1 ->
begin
{V6@V0,V6@Buf1} = case Bytes5 of
<<0:1,V6@V3:4,V6@Buf4/bitstring>> ->
V6@Int5 = case V6@V3 of
0 -> none;
1 -> unknown;
2 -> special;
3 -> moto;
4 -> car;
5 -> carOther;
6 -> bus;
7 -> axleCnt2;
8 -> axleCnt3;
9 -> axleCnt4;
10 -> axleCnt4Trailer;
11 -> axleCnt5Trailer;
12 -> axleCnt6Trailer;
13 -> axleCnt5MultiTrailer;
14 -> axleCnt6MultiTrailer;
15 -> axleCnt7MultiTrailer
end,
{V6@Int5,V6@Buf4};
<<1:1,V6@Buf2/bitstring>> ->
{V6@V3,V6@Buf4} = case V6@Buf2 of
<<0:1,V6@V6:6,V6@Buf7/bitstring>> ->
{V6@V6,V6@Buf7};
<<1:1,V6@Buf5/bitstring>> ->
{V6@V6,V6@Buf7} = case V6@Buf5 of
<<0:1,V6@V9:7,V6@Buf10/bitstring>> when V6@V9 =/= 0 ->
{V6@V9,V6@Buf10};
<<1:1,0:1,V6@V10:14,V6@Buf11/bitstring>> when V6@V10 =/= 0 ->
{V6@V10,V6@Buf11}
end,
<<V6@V12:V6@V6/unit:8,V6@Buf13/bitstring>> = V6@Buf7,
{V6@V12,V6@Buf13}
end,
V6@Int14 = case V6@V3 of
_ -> {asn1_enum,V6@V3}
end,
{V6@Int14,V6@Buf4}
end,
{V6@V0,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute vehicleType(5) with type ENUMERATED
{Term5,Bytes7} = case (Opt bsr 4) band 1 of
1 ->
begin
{V7@V0,V7@Buf1} = case Bytes6 of
<<0:1,V7@V3:6,V7@Buf4/bitstring>> ->
V7@Int5 = case V7@V3 of
0 -> 'all-vehicles';
1 -> bicycles;
2 -> motorcycles;
3 -> cars;
4 -> 'light-vehicles';
5 -> 'cars-and-light-vehicles';
6 -> 'cars-with-trailers';
7 -> 'cars-with-recreational-trailers';
8 -> 'vehicles-with-trailers';
9 -> 'heavy-vehicles';
10 -> trucks;
11 -> buses;
12 -> 'articulated-buses';
13 -> 'school-buses';
14 -> 'vehicles-with-semi-trailers';
15 -> 'vehicles-with-double-trailers';
16 -> 'high-profile-vehicles';
17 -> 'wide-vehicles';
18 -> 'long-vehicles';
19 -> 'hazardous-loads';
20 -> 'exceptional-loads';
21 -> 'abnormal-loads';
22 -> convoys;
23 -> 'maintenance-vehicles';
24 -> 'delivery-vehicles';
25 -> 'vehicles-with-even-numbered-license-plates';
26 -> 'vehicles-with-odd-numbered-license-plates';
27 -> 'vehicles-with-parking-permits';
28 -> 'vehicles-with-catalytic-converters';
29 -> 'vehicles-without-catalytic-converters';
30 -> 'gas-powered-vehicles';
31 -> 'diesel-powered-vehicles';
32 -> 'lPG-vehicles';
33 -> 'military-convoys';
34 -> 'military-vehicles';
_ -> exit({error,{asn1,{decode_enumerated,V7@V3}}})
end,
{V7@Int5,V7@Buf4};
<<1:1,V7@Buf2/bitstring>> ->
{V7@V3,V7@Buf4} = case V7@Buf2 of
<<0:1,V7@V6:6,V7@Buf7/bitstring>> ->
{V7@V6,V7@Buf7};
<<1:1,V7@Buf5/bitstring>> ->
{V7@V6,V7@Buf7} = case V7@Buf5 of
<<0:1,V7@V9:7,V7@Buf10/bitstring>> when V7@V9 =/= 0 ->
{V7@V9,V7@Buf10};
<<1:1,0:1,V7@V10:14,V7@Buf11/bitstring>> when V7@V10 =/= 0 ->
{V7@V10,V7@Buf11}
end,
<<V7@V12:V7@V6/unit:8,V7@Buf13/bitstring>> = V7@Buf7,
{V7@V12,V7@Buf13}
end,
V7@Int14 = case V7@V3 of
_ -> {asn1_enum,V7@V3}
end,
{V7@Int14,V7@Buf4}
end,
{V7@V0,V7@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute responseEquip(6) with type ENUMERATED
{Term6,Bytes8} = case (Opt bsr 3) band 1 of
1 ->
begin
{V8@V0,V8@Buf1} = case Bytes7 of
<<0:1,V8@V3:7,V8@Buf4/bitstring>> ->
V8@Int5 = case V8@V3 of
0 -> 'ground-fire-suppression';
1 -> 'heavy-ground-equipment';
2 -> aircraft;
3 -> 'marine-equipment';
4 -> 'support-equipment';
5 -> 'medical-rescue-unit';
6 -> other;
7 -> 'ground-fire-suppression-other';
8 -> engine;
9 -> 'truck-or-aerial';
10 -> quint;
11 -> 'tanker-pumper-combination';
12 -> 'brush-truck';
13 -> 'aircraft-rescue-firefighting';
14 -> 'heavy-ground-equipment-other';
15 -> 'dozer-or-plow';
16 -> tractor;
17 -> 'tanker-or-tender';
18 -> 'aircraft-other';
19 -> 'aircraft-fixed-wing-tanker';
20 -> helitanker;
21 -> helicopter;
22 -> 'marine-equipment-other';
23 -> 'fire-boat-with-pump';
24 -> 'boat-no-pump';
25 -> 'support-apparatus-other';
26 -> 'breathing-apparatus-support';
27 -> 'light-and-air-unit';
28 -> 'medical-rescue-unit-other';
29 -> 'rescue-unit';
30 -> 'urban-search-rescue-unit';
31 -> 'high-angle-rescue';
32 -> 'crash-fire-rescue';
33 -> 'bLS-unit';
34 -> 'aLS-unit';
35 -> 'mobile-command-post';
36 -> 'chief-officer-car';
37 -> 'hAZMAT-unit';
38 -> 'type-i-hand-crew';
39 -> 'type-ii-hand-crew';
40 -> 'privately-owned-vehicle';
41 -> 'other-apparatus-resource';
42 -> ambulance;
43 -> 'bomb-squad-van';
44 -> 'combine-harvester';
45 -> 'construction-vehicle';
46 -> 'farm-tractor';
47 -> 'grass-cutting-machines';
48 -> 'hAZMAT-containment-tow';
49 -> 'heavy-tow';
50 -> 'hedge-cutting-machines';
51 -> 'light-tow';
52 -> 'mobile-crane';
53 -> 'refuse-collection-vehicle';
54 -> 'resurfacing-vehicle';
55 -> 'road-sweeper';
56 -> 'roadside-litter-collection-crews';
57 -> 'salvage-vehicle';
58 -> 'sand-truck';
59 -> snowplow;
60 -> 'steam-roller';
61 -> 'swat-team-van';
62 -> 'track-laying-vehicle';
63 -> 'unknown-vehicle';
64 -> 'white-lining-vehicle';
65 -> 'dump-truck';
66 -> 'supervisor-vehicle';
67 -> 'snow-blower';
68 -> 'rotary-snow-blower';
69 -> 'road-grader';
70 -> 'steam-truck';
71 -> 'flatbed-tow';
_ -> exit({error,{asn1,{decode_enumerated,V8@V3}}})
end,
{V8@Int5,V8@Buf4};
<<1:1,V8@Buf2/bitstring>> ->
{V8@V3,V8@Buf4} = case V8@Buf2 of
<<0:1,V8@V6:6,V8@Buf7/bitstring>> ->
{V8@V6,V8@Buf7};
<<1:1,V8@Buf5/bitstring>> ->
{V8@V6,V8@Buf7} = case V8@Buf5 of
<<0:1,V8@V9:7,V8@Buf10/bitstring>> when V8@V9 =/= 0 ->
{V8@V9,V8@Buf10};
<<1:1,0:1,V8@V10:14,V8@Buf11/bitstring>> when V8@V10 =/= 0 ->
{V8@V10,V8@Buf11}
end,
<<V8@V12:V8@V6/unit:8,V8@Buf13/bitstring>> = V8@Buf7,
{V8@V12,V8@Buf13}
end,
V8@Int14 = case V8@V3 of
_ -> {asn1_enum,V8@V3}
end,
{V8@Int14,V8@Buf4}
end,
{V8@V0,V8@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute responderType(7) with type ENUMERATED
{Term7,Bytes9} = case (Opt bsr 2) band 1 of
1 ->
begin
{V9@V0,V9@Buf1} = case Bytes8 of
<<0:1,V9@V3:4,V9@Buf4/bitstring>> ->
V9@Int5 = case V9@V3 of
0 -> 'emergency-vehicle-units';
1 -> 'federal-law-enforcement-units';
2 -> 'state-police-units';
3 -> 'county-police-units';
4 -> 'local-police-units';
5 -> 'ambulance-units';
6 -> 'rescue-units';
7 -> 'fire-units';
8 -> 'hAZMAT-units';
9 -> 'light-tow-unit';
10 -> 'heavy-tow-unit';
11 -> 'freeway-service-patrols';
12 -> 'transportation-response-units';
13 -> 'private-contractor-response-units';
_ -> exit({error,{asn1,{decode_enumerated,V9@V3}}})
end,
{V9@Int5,V9@Buf4};
<<1:1,V9@Buf2/bitstring>> ->
{V9@V3,V9@Buf4} = case V9@Buf2 of
<<0:1,V9@V6:6,V9@Buf7/bitstring>> ->
{V9@V6,V9@Buf7};
<<1:1,V9@Buf5/bitstring>> ->
{V9@V6,V9@Buf7} = case V9@Buf5 of
<<0:1,V9@V9:7,V9@Buf10/bitstring>> when V9@V9 =/= 0 ->
{V9@V9,V9@Buf10};
<<1:1,0:1,V9@V10:14,V9@Buf11/bitstring>> when V9@V10 =/= 0 ->
{V9@V10,V9@Buf11}
end,
<<V9@V12:V9@V6/unit:8,V9@Buf13/bitstring>> = V9@Buf7,
{V9@V12,V9@Buf13}
end,
V9@Int14 = case V9@V3 of
_ -> {asn1_enum,V9@V3}
end,
{V9@Int14,V9@Buf4}
end,
{V9@V0,V9@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% attribute fuelType(8) with type INTEGER
{Term8,Bytes10} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V10@V0:4,V10@Buf1/bitstring>> = Bytes9,
{V10@V0,V10@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes9}
end,

%% attribute regional(9) with type SEQUENCE OF
{Term9,Bytes11} = case Opt band 1 of
1 ->
dec_VehicleClassification_regional(Bytes10);
0 ->
{asn1_NOVALUE,Bytes10}
end,

%% Extensions
{Extensions,Bytes12} = case Ext of
0 -> {<<>>,Bytes11};
1 ->
{V11@V0,V11@Buf1} = case Bytes11 of
<<0:1,V11@V3:6,V11@Buf4/bitstring>> ->
V11@Add5 = V11@V3 + 1,
{V11@Add5,V11@Buf4};
<<1:1,V11@Buf2/bitstring>> ->
{V11@V3,V11@Buf4} = case V11@Buf2 of
<<0:1,V11@V6:7,V11@Buf7/bitstring>> when V11@V6 =/= 0 ->
{V11@V6,V11@Buf7};
<<1:1,0:1,V11@V7:14,V11@Buf8/bitstring>> when V11@V7 =/= 0 ->
{V11@V7,V11@Buf8}
end,
{V11@V3,V11@Buf4}
end,
<<V11@V9:V11@V0/bitstring-unit:1,V11@Buf10/bitstring>> = V11@Buf1,
{V11@V9,V11@Buf10}
end,
Bytes13= skipextensions(Bytes12, 1, Extensions),
Res1 = #{},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{keyType=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{role=>Term2}
end,
Res4 = case Term3 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{iso3883=>Term3}
end,
Res5 = case Term4 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{hpmsType=>Term4}
end,
Res6 = case Term5 of
  asn1_NOVALUE -> Res5;
  _ -> Res5#{vehicleType=>Term5}
end,
Res7 = case Term6 of
  asn1_NOVALUE -> Res6;
  _ -> Res6#{responseEquip=>Term6}
end,
Res8 = case Term7 of
  asn1_NOVALUE -> Res7;
  _ -> Res7#{responderType=>Term7}
end,
Res9 = case Term8 of
  asn1_NOVALUE -> Res8;
  _ -> Res8#{fuelType=>Term8}
end,
Res10 = case Term9 of
  asn1_NOVALUE -> Res9;
  _ -> Res9#{regional=>Term9}
end,
{Res10,Bytes13}.


dec_VehicleClassification_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components130(V1@Add2, V1@Buf1, []).


dec_VehicleClassification_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_VehicleData(Val) ->
Input@1 = case Val of
  #{height:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{bumpers:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{mass:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{trailerWeight:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@3 =:= asn1__MISSING_IN_MAP ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
begin
%% attribute height(1) with type INTEGER
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
Input@1 bsr 7 =:= 0 ->
<<Input@1:7>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute bumpers(2) with type BumperHeights
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_BumperHeights(Input@2)
end
end,
begin
%% attribute mass(3) with type INTEGER
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
Input@3 bsr 8 =:= 0 ->
Input@3;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end|begin
%% attribute trailerWeight(4) with type INTEGER
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@4, Input@4 < 64256 ->
<<Input@4:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@4}}})
end
end].


dec_VehicleData(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:4,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute height(1) with type INTEGER
{Term1,Bytes3} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V3@V0:7,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute bumpers(2) with type BumperHeights
{Term2,Bytes4} = case (Opt bsr 2) band 1 of
1 ->
dec_BumperHeights(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute mass(3) with type INTEGER
{Term3,Bytes5} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V4@V0:8,V4@Buf1/bitstring>> = Bytes4,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute trailerWeight(4) with type INTEGER
{Term4,Bytes6} = case Opt band 1 of
1 ->
begin
<<V5@V0:16,V5@Buf1/bitstring>> = Bytes5,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% Extensions
{Extensions,Bytes7} = case Ext of
0 -> {<<>>,Bytes6};
1 ->
{V6@V0,V6@Buf1} = case Bytes6 of
<<0:1,V6@V3:6,V6@Buf4/bitstring>> ->
V6@Add5 = V6@V3 + 1,
{V6@Add5,V6@Buf4};
<<1:1,V6@Buf2/bitstring>> ->
{V6@V3,V6@Buf4} = case V6@Buf2 of
<<0:1,V6@V6:7,V6@Buf7/bitstring>> when V6@V6 =/= 0 ->
{V6@V6,V6@Buf7};
<<1:1,0:1,V6@V7:14,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
{V6@V7,V6@Buf8}
end,
{V6@V3,V6@Buf4}
end,
<<V6@V9:V6@V0/bitstring-unit:1,V6@Buf10/bitstring>> = V6@Buf1,
{V6@V9,V6@Buf10}
end,
Bytes8= skipextensions(Bytes7, 1, Extensions),
Res1 = #{},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{height=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{bumpers=>Term2}
end,
Res4 = case Term3 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{mass=>Term3}
end,
Res5 = case Term4 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{trailerWeight=>Term4}
end,
{Res5,Bytes8}.

enc_VehicleIdent(Val) ->
Input@1 = case Val of
  #{name:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{vin:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{ownerCode:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{id:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{vehicleType:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@6 = case Val of
  #{vehicleClass:=Input@6_0} -> Input@6_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@3 =:= asn1__MISSING_IN_MAP ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@5 =:= asn1__MISSING_IN_MAP ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
begin
%% attribute name(1) with type IA5String
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Enc2@len = length(Input@1),
Enc2@bin = encode_chars(Input@1, 7),
Enc2@len@sub = Enc2@len - 1,
if 0 =< Enc2@len@sub, Enc2@len@sub < 63 ->
[<<Enc2@len@sub:6>>|Enc2@bin]
end
end
end
end,
begin
%% attribute vin(2) with type OCTET STRING
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Enc4@len = byte_size(Input@2),
Enc4@len@sub = Enc4@len - 1,
if 0 =< Enc4@len@sub, Enc4@len@sub < 17 ->
[<<Enc4@len@sub:5>>|Input@2]
end
end
end
end,
begin
%% attribute ownerCode(3) with type IA5String
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Enc6@len = length(Input@3),
Enc6@bin = encode_chars(Input@3, 7),
Enc6@len@sub = Enc6@len - 1,
if Enc6@len@sub bsr 5 =:= 0 ->
[<<Enc6@len@sub:5>>|Enc6@bin]
end
end
end
end,
begin
%% attribute id(4) with type VehicleID
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_VehicleID(Input@4)
end
end,
begin
%% attribute vehicleType(5) with type ENUMERATED
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
Input@5 =:= none ->
<<0:1,0:4>>;
Input@5 =:= unknown ->
<<0:1,1:4>>;
Input@5 =:= special ->
<<0:1,2:4>>;
Input@5 =:= moto ->
<<0:1,3:4>>;
Input@5 =:= car ->
<<0:1,4:4>>;
Input@5 =:= carOther ->
<<0:1,5:4>>;
Input@5 =:= bus ->
<<0:1,6:4>>;
Input@5 =:= axleCnt2 ->
<<0:1,7:4>>;
Input@5 =:= axleCnt3 ->
<<0:1,8:4>>;
Input@5 =:= axleCnt4 ->
<<0:1,9:4>>;
Input@5 =:= axleCnt4Trailer ->
<<0:1,10:4>>;
Input@5 =:= axleCnt5Trailer ->
<<0:1,11:4>>;
Input@5 =:= axleCnt6Trailer ->
<<0:1,12:4>>;
Input@5 =:= axleCnt5MultiTrailer ->
<<0:1,13:4>>;
Input@5 =:= axleCnt6MultiTrailer ->
<<0:1,14:4>>;
Input@5 =:= axleCnt7MultiTrailer ->
<<0:1,15:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@5}}})
end
end|begin
%% attribute vehicleClass(6) with type CHOICE
if Input@6 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_VehicleIdent_vehicleClass(Input@6)
end
end].
enc_VehicleIdent_vehicleClass(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= vGroup ->
if ChoiceVal =:= 'all-vehicles' ->
<<0:2,0:1,0:6>>;
ChoiceVal =:= bicycles ->
<<0:2,0:1,1:6>>;
ChoiceVal =:= motorcycles ->
<<0:2,0:1,2:6>>;
ChoiceVal =:= cars ->
<<0:2,0:1,3:6>>;
ChoiceVal =:= 'light-vehicles' ->
<<0:2,0:1,4:6>>;
ChoiceVal =:= 'cars-and-light-vehicles' ->
<<0:2,0:1,5:6>>;
ChoiceVal =:= 'cars-with-trailers' ->
<<0:2,0:1,6:6>>;
ChoiceVal =:= 'cars-with-recreational-trailers' ->
<<0:2,0:1,7:6>>;
ChoiceVal =:= 'vehicles-with-trailers' ->
<<0:2,0:1,8:6>>;
ChoiceVal =:= 'heavy-vehicles' ->
<<0:2,0:1,9:6>>;
ChoiceVal =:= trucks ->
<<0:2,0:1,10:6>>;
ChoiceVal =:= buses ->
<<0:2,0:1,11:6>>;
ChoiceVal =:= 'articulated-buses' ->
<<0:2,0:1,12:6>>;
ChoiceVal =:= 'school-buses' ->
<<0:2,0:1,13:6>>;
ChoiceVal =:= 'vehicles-with-semi-trailers' ->
<<0:2,0:1,14:6>>;
ChoiceVal =:= 'vehicles-with-double-trailers' ->
<<0:2,0:1,15:6>>;
ChoiceVal =:= 'high-profile-vehicles' ->
<<0:2,0:1,16:6>>;
ChoiceVal =:= 'wide-vehicles' ->
<<0:2,0:1,17:6>>;
ChoiceVal =:= 'long-vehicles' ->
<<0:2,0:1,18:6>>;
ChoiceVal =:= 'hazardous-loads' ->
<<0:2,0:1,19:6>>;
ChoiceVal =:= 'exceptional-loads' ->
<<0:2,0:1,20:6>>;
ChoiceVal =:= 'abnormal-loads' ->
<<0:2,0:1,21:6>>;
ChoiceVal =:= convoys ->
<<0:2,0:1,22:6>>;
ChoiceVal =:= 'maintenance-vehicles' ->
<<0:2,0:1,23:6>>;
ChoiceVal =:= 'delivery-vehicles' ->
<<0:2,0:1,24:6>>;
ChoiceVal =:= 'vehicles-with-even-numbered-license-plates' ->
<<0:2,0:1,25:6>>;
ChoiceVal =:= 'vehicles-with-odd-numbered-license-plates' ->
<<0:2,0:1,26:6>>;
ChoiceVal =:= 'vehicles-with-parking-permits' ->
<<0:2,0:1,27:6>>;
ChoiceVal =:= 'vehicles-with-catalytic-converters' ->
<<0:2,0:1,28:6>>;
ChoiceVal =:= 'vehicles-without-catalytic-converters' ->
<<0:2,0:1,29:6>>;
ChoiceVal =:= 'gas-powered-vehicles' ->
<<0:2,0:1,30:6>>;
ChoiceVal =:= 'diesel-powered-vehicles' ->
<<0:2,0:1,31:6>>;
ChoiceVal =:= 'lPG-vehicles' ->
<<0:2,0:1,32:6>>;
ChoiceVal =:= 'military-convoys' ->
<<0:2,0:1,33:6>>;
ChoiceVal =:= 'military-vehicles' ->
<<0:2,0:1,34:6>>;
true ->
exit({error,{asn1,{illegal_enumerated,ChoiceVal}}})
end;
ChoiceTag =:= rGroup ->
if ChoiceVal =:= 'emergency-vehicle-units' ->
<<1:2,0:1,0:4>>;
ChoiceVal =:= 'federal-law-enforcement-units' ->
<<1:2,0:1,1:4>>;
ChoiceVal =:= 'state-police-units' ->
<<1:2,0:1,2:4>>;
ChoiceVal =:= 'county-police-units' ->
<<1:2,0:1,3:4>>;
ChoiceVal =:= 'local-police-units' ->
<<1:2,0:1,4:4>>;
ChoiceVal =:= 'ambulance-units' ->
<<1:2,0:1,5:4>>;
ChoiceVal =:= 'rescue-units' ->
<<1:2,0:1,6:4>>;
ChoiceVal =:= 'fire-units' ->
<<1:2,0:1,7:4>>;
ChoiceVal =:= 'hAZMAT-units' ->
<<1:2,0:1,8:4>>;
ChoiceVal =:= 'light-tow-unit' ->
<<1:2,0:1,9:4>>;
ChoiceVal =:= 'heavy-tow-unit' ->
<<1:2,0:1,10:4>>;
ChoiceVal =:= 'freeway-service-patrols' ->
<<1:2,0:1,11:4>>;
ChoiceVal =:= 'transportation-response-units' ->
<<1:2,0:1,12:4>>;
ChoiceVal =:= 'private-contractor-response-units' ->
<<1:2,0:1,13:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,ChoiceVal}}})
end;
ChoiceTag =:= rEquip ->
if ChoiceVal =:= 'ground-fire-suppression' ->
<<2:2,0:1,0:7>>;
ChoiceVal =:= 'heavy-ground-equipment' ->
<<2:2,0:1,1:7>>;
ChoiceVal =:= aircraft ->
<<2:2,0:1,2:7>>;
ChoiceVal =:= 'marine-equipment' ->
<<2:2,0:1,3:7>>;
ChoiceVal =:= 'support-equipment' ->
<<2:2,0:1,4:7>>;
ChoiceVal =:= 'medical-rescue-unit' ->
<<2:2,0:1,5:7>>;
ChoiceVal =:= other ->
<<2:2,0:1,6:7>>;
ChoiceVal =:= 'ground-fire-suppression-other' ->
<<2:2,0:1,7:7>>;
ChoiceVal =:= engine ->
<<2:2,0:1,8:7>>;
ChoiceVal =:= 'truck-or-aerial' ->
<<2:2,0:1,9:7>>;
ChoiceVal =:= quint ->
<<2:2,0:1,10:7>>;
ChoiceVal =:= 'tanker-pumper-combination' ->
<<2:2,0:1,11:7>>;
ChoiceVal =:= 'brush-truck' ->
<<2:2,0:1,12:7>>;
ChoiceVal =:= 'aircraft-rescue-firefighting' ->
<<2:2,0:1,13:7>>;
ChoiceVal =:= 'heavy-ground-equipment-other' ->
<<2:2,0:1,14:7>>;
ChoiceVal =:= 'dozer-or-plow' ->
<<2:2,0:1,15:7>>;
ChoiceVal =:= tractor ->
<<2:2,0:1,16:7>>;
ChoiceVal =:= 'tanker-or-tender' ->
<<2:2,0:1,17:7>>;
ChoiceVal =:= 'aircraft-other' ->
<<2:2,0:1,18:7>>;
ChoiceVal =:= 'aircraft-fixed-wing-tanker' ->
<<2:2,0:1,19:7>>;
ChoiceVal =:= helitanker ->
<<2:2,0:1,20:7>>;
ChoiceVal =:= helicopter ->
<<2:2,0:1,21:7>>;
ChoiceVal =:= 'marine-equipment-other' ->
<<2:2,0:1,22:7>>;
ChoiceVal =:= 'fire-boat-with-pump' ->
<<2:2,0:1,23:7>>;
ChoiceVal =:= 'boat-no-pump' ->
<<2:2,0:1,24:7>>;
ChoiceVal =:= 'support-apparatus-other' ->
<<2:2,0:1,25:7>>;
ChoiceVal =:= 'breathing-apparatus-support' ->
<<2:2,0:1,26:7>>;
ChoiceVal =:= 'light-and-air-unit' ->
<<2:2,0:1,27:7>>;
ChoiceVal =:= 'medical-rescue-unit-other' ->
<<2:2,0:1,28:7>>;
ChoiceVal =:= 'rescue-unit' ->
<<2:2,0:1,29:7>>;
ChoiceVal =:= 'urban-search-rescue-unit' ->
<<2:2,0:1,30:7>>;
ChoiceVal =:= 'high-angle-rescue' ->
<<2:2,0:1,31:7>>;
ChoiceVal =:= 'crash-fire-rescue' ->
<<2:2,0:1,32:7>>;
ChoiceVal =:= 'bLS-unit' ->
<<2:2,0:1,33:7>>;
ChoiceVal =:= 'aLS-unit' ->
<<2:2,0:1,34:7>>;
ChoiceVal =:= 'mobile-command-post' ->
<<2:2,0:1,35:7>>;
ChoiceVal =:= 'chief-officer-car' ->
<<2:2,0:1,36:7>>;
ChoiceVal =:= 'hAZMAT-unit' ->
<<2:2,0:1,37:7>>;
ChoiceVal =:= 'type-i-hand-crew' ->
<<2:2,0:1,38:7>>;
ChoiceVal =:= 'type-ii-hand-crew' ->
<<2:2,0:1,39:7>>;
ChoiceVal =:= 'privately-owned-vehicle' ->
<<2:2,0:1,40:7>>;
ChoiceVal =:= 'other-apparatus-resource' ->
<<2:2,0:1,41:7>>;
ChoiceVal =:= ambulance ->
<<2:2,0:1,42:7>>;
ChoiceVal =:= 'bomb-squad-van' ->
<<2:2,0:1,43:7>>;
ChoiceVal =:= 'combine-harvester' ->
<<2:2,0:1,44:7>>;
ChoiceVal =:= 'construction-vehicle' ->
<<2:2,0:1,45:7>>;
ChoiceVal =:= 'farm-tractor' ->
<<2:2,0:1,46:7>>;
ChoiceVal =:= 'grass-cutting-machines' ->
<<2:2,0:1,47:7>>;
ChoiceVal =:= 'hAZMAT-containment-tow' ->
<<2:2,0:1,48:7>>;
ChoiceVal =:= 'heavy-tow' ->
<<2:2,0:1,49:7>>;
ChoiceVal =:= 'hedge-cutting-machines' ->
<<2:2,0:1,50:7>>;
ChoiceVal =:= 'light-tow' ->
<<2:2,0:1,51:7>>;
ChoiceVal =:= 'mobile-crane' ->
<<2:2,0:1,52:7>>;
ChoiceVal =:= 'refuse-collection-vehicle' ->
<<2:2,0:1,53:7>>;
ChoiceVal =:= 'resurfacing-vehicle' ->
<<2:2,0:1,54:7>>;
ChoiceVal =:= 'road-sweeper' ->
<<2:2,0:1,55:7>>;
ChoiceVal =:= 'roadside-litter-collection-crews' ->
<<2:2,0:1,56:7>>;
ChoiceVal =:= 'salvage-vehicle' ->
<<2:2,0:1,57:7>>;
ChoiceVal =:= 'sand-truck' ->
<<2:2,0:1,58:7>>;
ChoiceVal =:= snowplow ->
<<2:2,0:1,59:7>>;
ChoiceVal =:= 'steam-roller' ->
<<2:2,0:1,60:7>>;
ChoiceVal =:= 'swat-team-van' ->
<<2:2,0:1,61:7>>;
ChoiceVal =:= 'track-laying-vehicle' ->
<<2:2,0:1,62:7>>;
ChoiceVal =:= 'unknown-vehicle' ->
<<2:2,0:1,63:7>>;
ChoiceVal =:= 'white-lining-vehicle' ->
<<2:2,0:1,64:7>>;
ChoiceVal =:= 'dump-truck' ->
<<2:2,0:1,65:7>>;
ChoiceVal =:= 'supervisor-vehicle' ->
<<2:2,0:1,66:7>>;
ChoiceVal =:= 'snow-blower' ->
<<2:2,0:1,67:7>>;
ChoiceVal =:= 'rotary-snow-blower' ->
<<2:2,0:1,68:7>>;
ChoiceVal =:= 'road-grader' ->
<<2:2,0:1,69:7>>;
ChoiceVal =:= 'steam-truck' ->
<<2:2,0:1,70:7>>;
ChoiceVal =:= 'flatbed-tow' ->
<<2:2,0:1,71:7>>;
true ->
exit({error,{asn1,{illegal_enumerated,ChoiceVal}}})
end
end.


dec_VehicleIdent(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:6,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute name(1) with type IA5String
{Term1,Bytes3} = case (Opt bsr 5) band 1 of
1 ->
begin
<<V3@V0:6,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + 1,
<<V3@V3:V3@Add2/binary-unit:7,V3@Buf4/bitstring>> = V3@Buf1,
{V3@V5,V3@Buf6}  = {decode_chars(V3@V3, 7),V3@Buf4},
{V3@V5,V3@Buf6}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute vin(2) with type OCTET STRING
{Term2,Bytes4} = case (Opt bsr 4) band 1 of
1 ->
begin
<<V4@V0:5,V4@Buf1/bitstring>> = Bytes3,
V4@Add2 = V4@V0 + 1,
<<V4@V3:V4@Add2/binary-unit:8,V4@Buf4/bitstring>> = V4@Buf1,
V4@Conv5 = binary:copy(V4@V3),
{V4@Conv5,V4@Buf4}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute ownerCode(3) with type IA5String
{Term3,Bytes5} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V5@V0:5,V5@Buf1/bitstring>> = Bytes4,
V5@Add2 = V5@V0 + 1,
<<V5@V3:V5@Add2/binary-unit:7,V5@Buf4/bitstring>> = V5@Buf1,
{V5@V5,V5@Buf6}  = {decode_chars(V5@V3, 7),V5@Buf4},
{V5@V5,V5@Buf6}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute id(4) with type VehicleID
{Term4,Bytes6} = case (Opt bsr 2) band 1 of
1 ->
dec_VehicleID(Bytes5);
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute vehicleType(5) with type ENUMERATED
{Term5,Bytes7} = case (Opt bsr 1) band 1 of
1 ->
begin
{V6@V0,V6@Buf1} = case Bytes6 of
<<0:1,V6@V3:4,V6@Buf4/bitstring>> ->
V6@Int5 = case V6@V3 of
0 -> none;
1 -> unknown;
2 -> special;
3 -> moto;
4 -> car;
5 -> carOther;
6 -> bus;
7 -> axleCnt2;
8 -> axleCnt3;
9 -> axleCnt4;
10 -> axleCnt4Trailer;
11 -> axleCnt5Trailer;
12 -> axleCnt6Trailer;
13 -> axleCnt5MultiTrailer;
14 -> axleCnt6MultiTrailer;
15 -> axleCnt7MultiTrailer
end,
{V6@Int5,V6@Buf4};
<<1:1,V6@Buf2/bitstring>> ->
{V6@V3,V6@Buf4} = case V6@Buf2 of
<<0:1,V6@V6:6,V6@Buf7/bitstring>> ->
{V6@V6,V6@Buf7};
<<1:1,V6@Buf5/bitstring>> ->
{V6@V6,V6@Buf7} = case V6@Buf5 of
<<0:1,V6@V9:7,V6@Buf10/bitstring>> when V6@V9 =/= 0 ->
{V6@V9,V6@Buf10};
<<1:1,0:1,V6@V10:14,V6@Buf11/bitstring>> when V6@V10 =/= 0 ->
{V6@V10,V6@Buf11}
end,
<<V6@V12:V6@V6/unit:8,V6@Buf13/bitstring>> = V6@Buf7,
{V6@V12,V6@Buf13}
end,
V6@Int14 = case V6@V3 of
_ -> {asn1_enum,V6@V3}
end,
{V6@Int14,V6@Buf4}
end,
{V6@V0,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute vehicleClass(6) with type CHOICE
{Term6,Bytes8} = case Opt band 1 of
1 ->
dec_VehicleIdent_vehicleClass(Bytes7);
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% Extensions
{Extensions,Bytes9} = case Ext of
0 -> {<<>>,Bytes8};
1 ->
{V7@V0,V7@Buf1} = case Bytes8 of
<<0:1,V7@V3:6,V7@Buf4/bitstring>> ->
V7@Add5 = V7@V3 + 1,
{V7@Add5,V7@Buf4};
<<1:1,V7@Buf2/bitstring>> ->
{V7@V3,V7@Buf4} = case V7@Buf2 of
<<0:1,V7@V6:7,V7@Buf7/bitstring>> when V7@V6 =/= 0 ->
{V7@V6,V7@Buf7};
<<1:1,0:1,V7@V7:14,V7@Buf8/bitstring>> when V7@V7 =/= 0 ->
{V7@V7,V7@Buf8}
end,
{V7@V3,V7@Buf4}
end,
<<V7@V9:V7@V0/bitstring-unit:1,V7@Buf10/bitstring>> = V7@Buf1,
{V7@V9,V7@Buf10}
end,
Bytes10= skipextensions(Bytes9, 1, Extensions),
Res1 = #{},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{name=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{vin=>Term2}
end,
Res4 = case Term3 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{ownerCode=>Term3}
end,
Res5 = case Term4 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{id=>Term4}
end,
Res6 = case Term5 of
  asn1_NOVALUE -> Res5;
  _ -> Res5#{vehicleType=>Term5}
end,
Res7 = case Term6 of
  asn1_NOVALUE -> Res6;
  _ -> Res6#{vehicleClass=>Term6}
end,
{Res7,Bytes10}.


dec_VehicleIdent_vehicleClass(Bytes) ->
{Choice,Bytes1} = 
begin
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:6,V2@Buf4/bitstring>> ->
V2@Int5 = case V2@V3 of
0 -> 'all-vehicles';
1 -> bicycles;
2 -> motorcycles;
3 -> cars;
4 -> 'light-vehicles';
5 -> 'cars-and-light-vehicles';
6 -> 'cars-with-trailers';
7 -> 'cars-with-recreational-trailers';
8 -> 'vehicles-with-trailers';
9 -> 'heavy-vehicles';
10 -> trucks;
11 -> buses;
12 -> 'articulated-buses';
13 -> 'school-buses';
14 -> 'vehicles-with-semi-trailers';
15 -> 'vehicles-with-double-trailers';
16 -> 'high-profile-vehicles';
17 -> 'wide-vehicles';
18 -> 'long-vehicles';
19 -> 'hazardous-loads';
20 -> 'exceptional-loads';
21 -> 'abnormal-loads';
22 -> convoys;
23 -> 'maintenance-vehicles';
24 -> 'delivery-vehicles';
25 -> 'vehicles-with-even-numbered-license-plates';
26 -> 'vehicles-with-odd-numbered-license-plates';
27 -> 'vehicles-with-parking-permits';
28 -> 'vehicles-with-catalytic-converters';
29 -> 'vehicles-without-catalytic-converters';
30 -> 'gas-powered-vehicles';
31 -> 'diesel-powered-vehicles';
32 -> 'lPG-vehicles';
33 -> 'military-convoys';
34 -> 'military-vehicles';
_ -> exit({error,{asn1,{decode_enumerated,V2@V3}}})
end,
{V2@Int5,V2@Buf4};
<<1:1,V2@Buf2/bitstring>> ->
{V2@V3,V2@Buf4} = case V2@Buf2 of
<<0:1,V2@V6:6,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7} = case V2@Buf5 of
<<0:1,V2@V9:7,V2@Buf10/bitstring>> when V2@V9 =/= 0 ->
{V2@V9,V2@Buf10};
<<1:1,0:1,V2@V10:14,V2@Buf11/bitstring>> when V2@V10 =/= 0 ->
{V2@V10,V2@Buf11}
end,
<<V2@V12:V2@V6/unit:8,V2@Buf13/bitstring>> = V2@Buf7,
{V2@V12,V2@Buf13}
end,
V2@Int14 = case V2@V3 of
_ -> {asn1_enum,V2@V3}
end,
{V2@Int14,V2@Buf4}
end,
{V2@V0,V2@Buf1}
end
end,
{{vGroup,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
begin
{V3@V0,V3@Buf1} = case Bytes1 of
<<0:1,V3@V3:4,V3@Buf4/bitstring>> ->
V3@Int5 = case V3@V3 of
0 -> 'emergency-vehicle-units';
1 -> 'federal-law-enforcement-units';
2 -> 'state-police-units';
3 -> 'county-police-units';
4 -> 'local-police-units';
5 -> 'ambulance-units';
6 -> 'rescue-units';
7 -> 'fire-units';
8 -> 'hAZMAT-units';
9 -> 'light-tow-unit';
10 -> 'heavy-tow-unit';
11 -> 'freeway-service-patrols';
12 -> 'transportation-response-units';
13 -> 'private-contractor-response-units';
_ -> exit({error,{asn1,{decode_enumerated,V3@V3}}})
end,
{V3@Int5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:6,V3@Buf7/bitstring>> ->
{V3@V6,V3@Buf7};
<<1:1,V3@Buf5/bitstring>> ->
{V3@V6,V3@Buf7} = case V3@Buf5 of
<<0:1,V3@V9:7,V3@Buf10/bitstring>> when V3@V9 =/= 0 ->
{V3@V9,V3@Buf10};
<<1:1,0:1,V3@V10:14,V3@Buf11/bitstring>> when V3@V10 =/= 0 ->
{V3@V10,V3@Buf11}
end,
<<V3@V12:V3@V6/unit:8,V3@Buf13/bitstring>> = V3@Buf7,
{V3@V12,V3@Buf13}
end,
V3@Int14 = case V3@V3 of
_ -> {asn1_enum,V3@V3}
end,
{V3@Int14,V3@Buf4}
end,
{V3@V0,V3@Buf1}
end
end,
{{rGroup,Val},NewBytes};
2 ->
{Val,NewBytes} = begin
begin
{V4@V0,V4@Buf1} = case Bytes1 of
<<0:1,V4@V3:7,V4@Buf4/bitstring>> ->
V4@Int5 = case V4@V3 of
0 -> 'ground-fire-suppression';
1 -> 'heavy-ground-equipment';
2 -> aircraft;
3 -> 'marine-equipment';
4 -> 'support-equipment';
5 -> 'medical-rescue-unit';
6 -> other;
7 -> 'ground-fire-suppression-other';
8 -> engine;
9 -> 'truck-or-aerial';
10 -> quint;
11 -> 'tanker-pumper-combination';
12 -> 'brush-truck';
13 -> 'aircraft-rescue-firefighting';
14 -> 'heavy-ground-equipment-other';
15 -> 'dozer-or-plow';
16 -> tractor;
17 -> 'tanker-or-tender';
18 -> 'aircraft-other';
19 -> 'aircraft-fixed-wing-tanker';
20 -> helitanker;
21 -> helicopter;
22 -> 'marine-equipment-other';
23 -> 'fire-boat-with-pump';
24 -> 'boat-no-pump';
25 -> 'support-apparatus-other';
26 -> 'breathing-apparatus-support';
27 -> 'light-and-air-unit';
28 -> 'medical-rescue-unit-other';
29 -> 'rescue-unit';
30 -> 'urban-search-rescue-unit';
31 -> 'high-angle-rescue';
32 -> 'crash-fire-rescue';
33 -> 'bLS-unit';
34 -> 'aLS-unit';
35 -> 'mobile-command-post';
36 -> 'chief-officer-car';
37 -> 'hAZMAT-unit';
38 -> 'type-i-hand-crew';
39 -> 'type-ii-hand-crew';
40 -> 'privately-owned-vehicle';
41 -> 'other-apparatus-resource';
42 -> ambulance;
43 -> 'bomb-squad-van';
44 -> 'combine-harvester';
45 -> 'construction-vehicle';
46 -> 'farm-tractor';
47 -> 'grass-cutting-machines';
48 -> 'hAZMAT-containment-tow';
49 -> 'heavy-tow';
50 -> 'hedge-cutting-machines';
51 -> 'light-tow';
52 -> 'mobile-crane';
53 -> 'refuse-collection-vehicle';
54 -> 'resurfacing-vehicle';
55 -> 'road-sweeper';
56 -> 'roadside-litter-collection-crews';
57 -> 'salvage-vehicle';
58 -> 'sand-truck';
59 -> snowplow;
60 -> 'steam-roller';
61 -> 'swat-team-van';
62 -> 'track-laying-vehicle';
63 -> 'unknown-vehicle';
64 -> 'white-lining-vehicle';
65 -> 'dump-truck';
66 -> 'supervisor-vehicle';
67 -> 'snow-blower';
68 -> 'rotary-snow-blower';
69 -> 'road-grader';
70 -> 'steam-truck';
71 -> 'flatbed-tow';
_ -> exit({error,{asn1,{decode_enumerated,V4@V3}}})
end,
{V4@Int5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:6,V4@Buf7/bitstring>> ->
{V4@V6,V4@Buf7};
<<1:1,V4@Buf5/bitstring>> ->
{V4@V6,V4@Buf7} = case V4@Buf5 of
<<0:1,V4@V9:7,V4@Buf10/bitstring>> when V4@V9 =/= 0 ->
{V4@V9,V4@Buf10};
<<1:1,0:1,V4@V10:14,V4@Buf11/bitstring>> when V4@V10 =/= 0 ->
{V4@V10,V4@Buf11}
end,
<<V4@V12:V4@V6/unit:8,V4@Buf13/bitstring>> = V4@Buf7,
{V4@V12,V4@Buf13}
end,
V4@Int14 = case V4@V3 of
_ -> {asn1_enum,V4@V3}
end,
{V4@Int14,V4@Buf4}
end,
{V4@V0,V4@Buf1}
end
end,
{{rEquip,Val},NewBytes}
end.
enc_VehicleID(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= entityID ->
begin
[<<0:1>>|enc_Binary_Id(ChoiceVal)]
end;
ChoiceTag =:= stationID ->
if ChoiceVal bsr 32 =:= 0 ->
<<1:1,ChoiceVal:32>>;
true ->
exit({error,{asn1,{illegal_integer,ChoiceVal}}})
end
end.


dec_VehicleID(Bytes) ->
{Choice,Bytes1} = 
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
begin
<<V2@V0:4/binary-unit:8,V2@Buf1/bitstring>> = Bytes1,
V2@Conv2 = binary:copy(V2@V0),
{V2@Conv2,V2@Buf1}
end
end,
{{entityID, dec_Binary_Id(Val)},NewBytes};
1 ->
{Val,NewBytes} = begin
begin
<<V3@V0:32,V3@Buf1/bitstring>> = Bytes1,
{V3@V0,V3@Buf1}
end
end,
{{stationID,Val},NewBytes}
end.
enc_VehicleSafetyExtensions(Val) ->
Input@1 = case Val of
  #{events:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{pathHistory:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{pathPrediction:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{lights:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@3 =:= asn1__MISSING_IN_MAP ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
begin
%% attribute events(1) with type BIT STRING
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Enc2@bs = try bit_string_name2pos_11(Input@1) of
Enc2@positions ->
bitstring_from_positions(Enc2@positions, 13)
catch throw:invalid ->
adjust_trailing_zeroes(Input@1, 13)
end,
Enc2@bits = bit_size(Enc2@bs),
if Enc2@bits =:= 13 ->
[<<0:1>>|Enc2@bs];
Enc2@bits < 128 ->
[<<1:1,Enc2@bits:8>>|Enc2@bs];
Enc2@bits < 16384 ->
[<<1:1,2:2,Enc2@bits:14>>|Enc2@bs];
true ->
[<<1:1>>|encode_fragmented(Enc2@bs, 1)]
end
end
end
end,
begin
%% attribute pathHistory(2) with type PathHistory
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_PathHistory(Input@2)
end
end,
begin
%% attribute pathPrediction(3) with type PathPrediction
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_PathPrediction(Input@3)
end
end|begin
%% attribute lights(4) with type BIT STRING
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Enc6@bs = try bit_string_name2pos_131(Input@4) of
Enc6@positions ->
bitstring_from_positions(Enc6@positions, 9)
catch throw:invalid ->
adjust_trailing_zeroes(Input@4, 9)
end,
Enc6@bits = bit_size(Enc6@bs),
if Enc6@bits =:= 9 ->
[<<0:1>>|Enc6@bs];
Enc6@bits < 128 ->
[<<1:1,Enc6@bits:8>>|Enc6@bs];
Enc6@bits < 16384 ->
[<<1:1,2:2,Enc6@bits:14>>|Enc6@bs];
true ->
[<<1:1>>|encode_fragmented(Enc6@bs, 1)]
end
end
end
end].


dec_VehicleSafetyExtensions(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:4,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute events(1) with type BIT STRING
{Term1,Bytes3} = case (Opt bsr 3) band 1 of
1 ->
begin
{V3@V0,V3@Buf1} = case Bytes2 of
<<0:1,V3@V3:13/binary-unit:1,V3@Buf4/bitstring>> ->
{V3@V3,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@V8:V3@V6/binary-unit:1,V3@Buf9/bitstring>> ->
{V3@V8,V3@Buf9};
<<1:1,0:1,V3@V7:14,V3@V9:V3@V7/binary-unit:1,V3@Buf10/bitstring>> ->
{V3@V9,V3@Buf10};
<<1:1,1:1,V3@V7:6,V3@Buf8/bitstring>> ->
{V3@V9,V3@Buf10}  = decode_fragmented(V3@V7, V3@Buf8, 1),
{V3@V9,V3@Buf10}
end,
{V3@V3,V3@Buf4}
end,
{V3@V11,V3@Buf12}  = {decode_named_bit_string(V3@V0, [{eventHazardLights,0},{eventStopLineViolation,1},{eventABSactivated,2},{eventTractionControlLoss,3},{eventStabilityControlactivated,4},{eventHazardousMaterials,5},{eventReserved1,6},{eventHardBraking,7},{eventLightsChanged,8},{eventWipersChanged,9},{eventFlatTire,10},{eventDisabledVehicle,11},{eventAirBagDeployment,12}]),V3@Buf1},
{V3@V11,V3@Buf12}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute pathHistory(2) with type PathHistory
{Term2,Bytes4} = case (Opt bsr 2) band 1 of
1 ->
dec_PathHistory(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute pathPrediction(3) with type PathPrediction
{Term3,Bytes5} = case (Opt bsr 1) band 1 of
1 ->
dec_PathPrediction(Bytes4);
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute lights(4) with type BIT STRING
{Term4,Bytes6} = case Opt band 1 of
1 ->
begin
{V4@V0,V4@Buf1} = case Bytes5 of
<<0:1,V4@V3:9/binary-unit:1,V4@Buf4/bitstring>> ->
{V4@V3,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:7,V4@V8:V4@V6/binary-unit:1,V4@Buf9/bitstring>> ->
{V4@V8,V4@Buf9};
<<1:1,0:1,V4@V7:14,V4@V9:V4@V7/binary-unit:1,V4@Buf10/bitstring>> ->
{V4@V9,V4@Buf10};
<<1:1,1:1,V4@V7:6,V4@Buf8/bitstring>> ->
{V4@V9,V4@Buf10}  = decode_fragmented(V4@V7, V4@Buf8, 1),
{V4@V9,V4@Buf10}
end,
{V4@V3,V4@Buf4}
end,
{V4@V11,V4@Buf12}  = {decode_named_bit_string(V4@V0, [{lowBeamHeadlightsOn,0},{highBeamHeadlightsOn,1},{leftTurnSignalOn,2},{rightTurnSignalOn,3},{hazardSignalOn,4},{automaticLightControlOn,5},{daytimeRunningLightsOn,6},{fogLightOn,7},{parkingLightsOn,8}]),V4@Buf1},
{V4@V11,V4@Buf12}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% Extensions
{Extensions,Bytes7} = case Ext of
0 -> {<<>>,Bytes6};
1 ->
{V5@V0,V5@Buf1} = case Bytes6 of
<<0:1,V5@V3:6,V5@Buf4/bitstring>> ->
V5@Add5 = V5@V3 + 1,
{V5@Add5,V5@Buf4};
<<1:1,V5@Buf2/bitstring>> ->
{V5@V3,V5@Buf4} = case V5@Buf2 of
<<0:1,V5@V6:7,V5@Buf7/bitstring>> when V5@V6 =/= 0 ->
{V5@V6,V5@Buf7};
<<1:1,0:1,V5@V7:14,V5@Buf8/bitstring>> when V5@V7 =/= 0 ->
{V5@V7,V5@Buf8}
end,
{V5@V3,V5@Buf4}
end,
<<V5@V9:V5@V0/bitstring-unit:1,V5@Buf10/bitstring>> = V5@Buf1,
{V5@V9,V5@Buf10}
end,
Bytes8= skipextensions(Bytes7, 1, Extensions),
Res1 = #{},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{events=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{pathHistory=>Term2}
end,
Res4 = case Term3 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{pathPrediction=>Term3}
end,
Res5 = case Term4 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{lights=>Term4}
end,
{Res5,Bytes8}.

enc_VehicleSize(Val) ->
#{width:=Input@1,length:=Input@2} = Val,
[begin
%% attribute width(1) with type INTEGER
if Input@1 bsr 10 =:= 0 ->
<<Input@1:10>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute length(2) with type INTEGER
if Input@2 bsr 12 =:= 0 ->
<<Input@2:12>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end].


dec_VehicleSize(Bytes) ->

%% attribute width(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:10,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute length(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:12,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,
Res1 = #{width=>Term1,length=>Term2},
{Res1,Bytes2}.

enc_VehicleStatusRequest(Val) ->
#{dataType:=Input@1} = Val,
Input@2 = case Val of
  #{subType:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{sendOnLessThenValue:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{sendOnMoreThenValue:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{sendAll:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@2 =:= asn1__MISSING_IN_MAP ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@4 =:= asn1__MISSING_IN_MAP ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
begin
%% attribute dataType(1) with type ENUMERATED
if Input@1 =:= unknown ->
<<0:1,0:5>>;
Input@1 =:= lights ->
<<0:1,1:5>>;
Input@1 =:= wipers ->
<<0:1,2:5>>;
Input@1 =:= brakes ->
<<0:1,3:5>>;
Input@1 =:= stab ->
<<0:1,4:5>>;
Input@1 =:= trac ->
<<0:1,5:5>>;
Input@1 =:= abs ->
<<0:1,6:5>>;
Input@1 =:= sunS ->
<<0:1,7:5>>;
Input@1 =:= rainS ->
<<0:1,8:5>>;
Input@1 =:= airTemp ->
<<0:1,9:5>>;
Input@1 =:= steering ->
<<0:1,10:5>>;
Input@1 =:= vertAccelThres ->
<<0:1,11:5>>;
Input@1 =:= vertAccel ->
<<0:1,12:5>>;
Input@1 =:= hozAccelLong ->
<<0:1,13:5>>;
Input@1 =:= hozAccelLat ->
<<0:1,14:5>>;
Input@1 =:= hozAccelCon ->
<<0:1,15:5>>;
Input@1 =:= accel4way ->
<<0:1,16:5>>;
Input@1 =:= confidenceSet ->
<<0:1,17:5>>;
Input@1 =:= obDist ->
<<0:1,18:5>>;
Input@1 =:= obDirect ->
<<0:1,19:5>>;
Input@1 =:= yaw ->
<<0:1,20:5>>;
Input@1 =:= yawRateCon ->
<<0:1,21:5>>;
Input@1 =:= dateTime ->
<<0:1,22:5>>;
Input@1 =:= fullPos ->
<<0:1,23:5>>;
Input@1 =:= position2D ->
<<0:1,24:5>>;
Input@1 =:= position3D ->
<<0:1,25:5>>;
Input@1 =:= vehicle ->
<<0:1,26:5>>;
Input@1 =:= speedHeadC ->
<<0:1,27:5>>;
Input@1 =:= speedC ->
<<0:1,28:5>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@1}}})
end
end,
begin
%% attribute subType(2) with type INTEGER
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Input@2@sub = Input@2 - 1,
if 0 =< Input@2@sub, Input@2@sub < 15 ->
<<Input@2@sub:4>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end
end
end,
begin
%% attribute sendOnLessThenValue(3) with type INTEGER
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Input@3@sub = Input@3 - -32767,
if 0 =< Input@3@sub, Input@3@sub < 65535 ->
<<Input@3@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end
end
end,
begin
%% attribute sendOnMoreThenValue(4) with type INTEGER
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Input@4@sub = Input@4 - -32767,
if 0 =< Input@4@sub, Input@4@sub < 65535 ->
<<Input@4@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@4}}})
end
end
end
end|begin
%% attribute sendAll(5) with type BOOLEAN
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
Input@5 =:= false ->
<<0:1>>;
Input@5 =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Input@5}}})
end
end].


dec_VehicleStatusRequest(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:4,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute dataType(1) with type ENUMERATED
{Term1,Bytes3} = begin
{V3@V0,V3@Buf1} = case Bytes2 of
<<0:1,V3@V3:5,V3@Buf4/bitstring>> ->
V3@Int5 = case V3@V3 of
0 -> unknown;
1 -> lights;
2 -> wipers;
3 -> brakes;
4 -> stab;
5 -> trac;
6 -> abs;
7 -> sunS;
8 -> rainS;
9 -> airTemp;
10 -> steering;
11 -> vertAccelThres;
12 -> vertAccel;
13 -> hozAccelLong;
14 -> hozAccelLat;
15 -> hozAccelCon;
16 -> accel4way;
17 -> confidenceSet;
18 -> obDist;
19 -> obDirect;
20 -> yaw;
21 -> yawRateCon;
22 -> dateTime;
23 -> fullPos;
24 -> position2D;
25 -> position3D;
26 -> vehicle;
27 -> speedHeadC;
28 -> speedC;
_ -> exit({error,{asn1,{decode_enumerated,V3@V3}}})
end,
{V3@Int5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:6,V3@Buf7/bitstring>> ->
{V3@V6,V3@Buf7};
<<1:1,V3@Buf5/bitstring>> ->
{V3@V6,V3@Buf7} = case V3@Buf5 of
<<0:1,V3@V9:7,V3@Buf10/bitstring>> when V3@V9 =/= 0 ->
{V3@V9,V3@Buf10};
<<1:1,0:1,V3@V10:14,V3@Buf11/bitstring>> when V3@V10 =/= 0 ->
{V3@V10,V3@Buf11}
end,
<<V3@V12:V3@V6/unit:8,V3@Buf13/bitstring>> = V3@Buf7,
{V3@V12,V3@Buf13}
end,
V3@Int14 = case V3@V3 of
_ -> {asn1_enum,V3@V3}
end,
{V3@Int14,V3@Buf4}
end,
{V3@V0,V3@Buf1}
end,

%% attribute subType(2) with type INTEGER
{Term2,Bytes4} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V4@V0:4,V4@Buf1/bitstring>> = Bytes3,
V4@Add2 = V4@V0 + 1,
{V4@Add2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute sendOnLessThenValue(3) with type INTEGER
{Term3,Bytes5} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V5@V0:16,V5@Buf1/bitstring>> = Bytes4,
V5@Add2 = V5@V0 + -32767,
{V5@Add2,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute sendOnMoreThenValue(4) with type INTEGER
{Term4,Bytes6} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V6@V0:16,V6@Buf1/bitstring>> = Bytes5,
V6@Add2 = V6@V0 + -32767,
{V6@Add2,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute sendAll(5) with type BOOLEAN
{Term5,Bytes7} = case Opt band 1 of
1 ->
begin
<<V7@V0:1,V7@Buf1/bitstring>> = Bytes6,
V7@Int2 = case V7@V0 of
0 -> false;
1 -> true
end,
{V7@Int2,V7@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% Extensions
{Extensions,Bytes8} = case Ext of
0 -> {<<>>,Bytes7};
1 ->
{V8@V0,V8@Buf1} = case Bytes7 of
<<0:1,V8@V3:6,V8@Buf4/bitstring>> ->
V8@Add5 = V8@V3 + 1,
{V8@Add5,V8@Buf4};
<<1:1,V8@Buf2/bitstring>> ->
{V8@V3,V8@Buf4} = case V8@Buf2 of
<<0:1,V8@V6:7,V8@Buf7/bitstring>> when V8@V6 =/= 0 ->
{V8@V6,V8@Buf7};
<<1:1,0:1,V8@V7:14,V8@Buf8/bitstring>> when V8@V7 =/= 0 ->
{V8@V7,V8@Buf8}
end,
{V8@V3,V8@Buf4}
end,
<<V8@V9:V8@V0/bitstring-unit:1,V8@Buf10/bitstring>> = V8@Buf1,
{V8@V9,V8@Buf10}
end,
Bytes9= skipextensions(Bytes8, 1, Extensions),
Res1 = #{dataType=>Term1},
Res2 = case Term2 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{subType=>Term2}
end,
Res3 = case Term3 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{sendOnLessThenValue=>Term3}
end,
Res4 = case Term4 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{sendOnMoreThenValue=>Term4}
end,
Res5 = case Term5 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{sendAll=>Term5}
end,
{Res5,Bytes9}.

enc_VehicleStatusRequestList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 5 =:= 0 ->
[<<Enc1@len@sub:5>>|[enc_VehicleStatusRequest(Comp) || Comp <- Val]]
end.



dec_VehicleStatusRequestList(Bytes) ->
%% Length with constraint {1,32}
<<V1@V0:5,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components132(V1@Add2, V1@Buf1, []).

enc_VehicleStatus(Val) ->
Input@1 = case Val of
  #{lights:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{lightBar:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{wipers:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{brakeStatus:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{brakePressure:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@6 = case Val of
  #{roadFriction:=Input@6_0} -> Input@6_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@7 = case Val of
  #{sunData:=Input@7_0} -> Input@7_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@8 = case Val of
  #{rainData:=Input@8_0} -> Input@8_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@9 = case Val of
  #{airTemp:=Input@9_0} -> Input@9_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@10 = case Val of
  #{airPres:=Input@10_0} -> Input@10_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@11 = case Val of
  #{steering:=Input@11_0} -> Input@11_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@12 = case Val of
  #{accelSets:=Input@12_0} -> Input@12_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@13 = case Val of
  #{object:=Input@13_0} -> Input@13_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@14 = case Val of
  #{fullPos:=Input@14_0} -> Input@14_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@15 = case Val of
  #{throttlePos:=Input@15_0} -> Input@15_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@16 = case Val of
  #{speedHeadC:=Input@16_0} -> Input@16_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@17 = case Val of
  #{speedC:=Input@17_0} -> Input@17_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@18 = case Val of
  #{vehicleData:=Input@18_0} -> Input@18_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@19 = case Val of
  #{vehicleIdent:=Input@19_0} -> Input@19_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@20 = case Val of
  #{j1939data:=Input@20_0} -> Input@20_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@21 = case Val of
  #{weatherReport:=Input@21_0} -> Input@21_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@22 = case Val of
  #{gnssStatus:=Input@22_0} -> Input@22_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@3 =:= asn1__MISSING_IN_MAP ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@5 =:= asn1__MISSING_IN_MAP ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@6 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@7 =:= asn1__MISSING_IN_MAP ->
if Input@8 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@8 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@9 =:= asn1__MISSING_IN_MAP ->
if Input@10 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@10 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@11 =:= asn1__MISSING_IN_MAP ->
if Input@12 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@12 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@13 =:= asn1__MISSING_IN_MAP ->
if Input@14 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@14 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@15 =:= asn1__MISSING_IN_MAP ->
if Input@16 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@16 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@17 =:= asn1__MISSING_IN_MAP ->
if Input@18 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@18 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@19 =:= asn1__MISSING_IN_MAP ->
if Input@20 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@20 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@21 =:= asn1__MISSING_IN_MAP ->
if Input@22 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@22 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
begin
%% attribute lights(1) with type BIT STRING
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Enc2@bs = try bit_string_name2pos_131(Input@1) of
Enc2@positions ->
bitstring_from_positions(Enc2@positions, 9)
catch throw:invalid ->
adjust_trailing_zeroes(Input@1, 9)
end,
Enc2@bits = bit_size(Enc2@bs),
if Enc2@bits =:= 9 ->
[<<0:1>>|Enc2@bs];
Enc2@bits < 128 ->
[<<1:1,Enc2@bits:8>>|Enc2@bs];
Enc2@bits < 16384 ->
[<<1:1,2:2,Enc2@bits:14>>|Enc2@bs];
true ->
[<<1:1>>|encode_fragmented(Enc2@bs, 1)]
end
end
end
end,
begin
%% attribute lightBar(2) with type ENUMERATED
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
Input@2 =:= unavailable ->
<<0:3>>;
Input@2 =:= notInUse ->
<<1:3>>;
Input@2 =:= inUse ->
<<2:3>>;
Input@2 =:= yellowCautionLights ->
<<3:3>>;
Input@2 =:= schooldBusLights ->
<<4:3>>;
Input@2 =:= arrowSignsActive ->
<<5:3>>;
Input@2 =:= slowMovingVehicle ->
<<6:3>>;
Input@2 =:= freqStops ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@2}}})
end
end,
begin
%% attribute wipers(3) with type WiperSet
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_WiperSet(Input@3)
end
end,
begin
%% attribute brakeStatus(4) with type BrakeSystemStatus
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_BrakeSystemStatus(Input@4)
end
end,
begin
%% attribute brakePressure(5) with type ENUMERATED
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
Input@5 =:= unavailable ->
<<0:4>>;
Input@5 =:= minPressure ->
<<1:4>>;
Input@5 =:= 'bkLvl-2' ->
<<2:4>>;
Input@5 =:= 'bkLvl-3' ->
<<3:4>>;
Input@5 =:= 'bkLvl-4' ->
<<4:4>>;
Input@5 =:= 'bkLvl-5' ->
<<5:4>>;
Input@5 =:= 'bkLvl-6' ->
<<6:4>>;
Input@5 =:= 'bkLvl-7' ->
<<7:4>>;
Input@5 =:= 'bkLvl-8' ->
<<8:4>>;
Input@5 =:= 'bkLvl-9' ->
<<9:4>>;
Input@5 =:= 'bkLvl-10' ->
<<10:4>>;
Input@5 =:= 'bkLvl-11' ->
<<11:4>>;
Input@5 =:= 'bkLvl-12' ->
<<12:4>>;
Input@5 =:= 'bkLvl-13' ->
<<13:4>>;
Input@5 =:= 'bkLvl-14' ->
<<14:4>>;
Input@5 =:= maxPressure ->
<<15:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@5}}})
end
end,
begin
%% attribute roadFriction(6) with type INTEGER
if Input@6 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@6, Input@6 < 51 ->
<<Input@6:6>>;
true ->
exit({error,{asn1,{illegal_integer,Input@6}}})
end
end,
begin
%% attribute sunData(7) with type INTEGER
if Input@7 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@7, Input@7 < 1001 ->
<<Input@7:10>>;
true ->
exit({error,{asn1,{illegal_integer,Input@7}}})
end
end,
begin
%% attribute rainData(8) with type ENUMERATED
if Input@8 =:= asn1__MISSING_IN_MAP ->
[];
Input@8 =:= none ->
<<0:3>>;
Input@8 =:= lightMist ->
<<1:3>>;
Input@8 =:= heavyMist ->
<<2:3>>;
Input@8 =:= lightRainOrDrizzle ->
<<3:3>>;
Input@8 =:= rain ->
<<4:3>>;
Input@8 =:= moderateRain ->
<<5:3>>;
Input@8 =:= heavyRain ->
<<6:3>>;
Input@8 =:= heavyDownpour ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@8}}})
end
end,
begin
%% attribute airTemp(9) with type INTEGER
if Input@9 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@9, Input@9 < 192 ->
Input@9;
true ->
exit({error,{asn1,{illegal_integer,Input@9}}})
end
end,
begin
%% attribute airPres(10) with type INTEGER
if Input@10 =:= asn1__MISSING_IN_MAP ->
[];
Input@10 bsr 8 =:= 0 ->
Input@10;
true ->
exit({error,{asn1,{illegal_integer,Input@10}}})
end
end,
begin
%% attribute steering(11) with type SEQUENCE
if Input@11 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_VehicleStatus_steering(Input@11)
end
end,
begin
%% attribute accelSets(12) with type SEQUENCE
if Input@12 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_VehicleStatus_accelSets(Input@12)
end
end,
begin
%% attribute object(13) with type SEQUENCE
if Input@13 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_VehicleStatus_object(Input@13)
end
end,
begin
%% attribute fullPos(14) with type FullPositionVector
if Input@14 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_FullPositionVector(Input@14)
end
end,
begin
%% attribute throttlePos(15) with type INTEGER
if Input@15 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@15, Input@15 < 201 ->
Input@15;
true ->
exit({error,{asn1,{illegal_integer,Input@15}}})
end
end,
begin
%% attribute speedHeadC(16) with type SpeedandHeadingandThrottleConfidence
if Input@16 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_SpeedandHeadingandThrottleConfidence(Input@16)
end
end,
begin
%% attribute speedC(17) with type ENUMERATED
if Input@17 =:= asn1__MISSING_IN_MAP ->
[];
Input@17 =:= unavailable ->
<<0:3>>;
Input@17 =:= prec100ms ->
<<1:3>>;
Input@17 =:= prec10ms ->
<<2:3>>;
Input@17 =:= prec5ms ->
<<3:3>>;
Input@17 =:= prec1ms ->
<<4:3>>;
Input@17 =:= 'prec0-1ms' ->
<<5:3>>;
Input@17 =:= 'prec0-05ms' ->
<<6:3>>;
Input@17 =:= 'prec0-01ms' ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@17}}})
end
end,
begin
%% attribute vehicleData(18) with type SEQUENCE
if Input@18 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_VehicleStatus_vehicleData(Input@18)
end
end,
begin
%% attribute vehicleIdent(19) with type VehicleIdent
if Input@19 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_VehicleIdent(Input@19)
end
end,
begin
%% attribute j1939data(20) with type J1939data
if Input@20 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_J1939data(Input@20)
end
end,
begin
%% attribute weatherReport(21) with type SEQUENCE
if Input@21 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_VehicleStatus_weatherReport(Input@21)
end
end|begin
%% attribute gnssStatus(22) with type BIT STRING
if Input@22 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Enc33@bs = try bit_string_name2pos_94(Input@22) of
Enc33@positions ->
bitstring_from_positions(Enc33@positions, 8)
catch throw:invalid ->
adjust_trailing_zeroes(Input@22, 8)
end,
Enc33@bits = bit_size(Enc33@bs),
if Enc33@bits =:= 8 ->
Enc33@bs
end
end
end
end].
enc_VehicleStatus_steering(Val) ->
#{angle:=Input@1} = Val,
Input@2 = case Val of
  #{confidence:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{rate:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{wheels:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@2 =:= asn1__MISSING_IN_MAP ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<0:1>>;
true ->
<<1:1>>
end,
begin
%% attribute angle(1) with type INTEGER
Input@1@sub = Input@1 - -126,
if 0 =< Input@1@sub, Input@1@sub < 254 ->
Input@1@sub;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute confidence(2) with type ENUMERATED
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
Input@2 =:= unavailable ->
<<0:2>>;
Input@2 =:= prec2deg ->
<<1:2>>;
Input@2 =:= prec1deg ->
<<2:2>>;
Input@2 =:= 'prec0-02deg' ->
<<3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@2}}})
end
end,
begin
%% attribute rate(3) with type INTEGER
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Input@3@sub = Input@3 - -127,
if 0 =< Input@3@sub, Input@3@sub < 255 ->
Input@3@sub;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end
end
end|begin
%% attribute wheels(4) with type INTEGER
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Input@4@sub = Input@4 - -128,
if Input@4@sub bsr 8 =:= 0 ->
[Input@4@sub];
true ->
exit({error,{asn1,{illegal_integer,Input@4}}})
end
end
end
end].
enc_VehicleStatus_accelSets(Val) ->
Input@1 = case Val of
  #{accel4way:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{vertAccelThres:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{yawRateCon:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{hozAccelCon:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{confidenceSet:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@3 =:= asn1__MISSING_IN_MAP ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<0:1>>;
true ->
<<1:1>>
end,
begin
%% attribute accel4way(1) with type AccelerationSet4Way
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_AccelerationSet4Way(Input@1)
end
end,
begin
%% attribute vertAccelThres(2) with type BIT STRING
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
true ->
begin
Enc2@bs = try bit_string_name2pos_92(Input@2) of
Enc2@positions ->
bitstring_from_positions(Enc2@positions, 5)
catch throw:invalid ->
adjust_trailing_zeroes(Input@2, 5)
end,
Enc2@bits = bit_size(Enc2@bs),
if Enc2@bits =:= 5 ->
Enc2@bs
end
end
end
end,
begin
%% attribute yawRateCon(3) with type ENUMERATED
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
Input@3 =:= unavailable ->
<<0:3>>;
Input@3 =:= 'degSec-100-00' ->
<<1:3>>;
Input@3 =:= 'degSec-010-00' ->
<<2:3>>;
Input@3 =:= 'degSec-005-00' ->
<<3:3>>;
Input@3 =:= 'degSec-001-00' ->
<<4:3>>;
Input@3 =:= 'degSec-000-10' ->
<<5:3>>;
Input@3 =:= 'degSec-000-05' ->
<<6:3>>;
Input@3 =:= 'degSec-000-01' ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@3}}})
end
end,
begin
%% attribute hozAccelCon(4) with type ENUMERATED
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
Input@4 =:= unavailable ->
<<0:3>>;
Input@4 =:= 'accl-100-00' ->
<<1:3>>;
Input@4 =:= 'accl-010-00' ->
<<2:3>>;
Input@4 =:= 'accl-005-00' ->
<<3:3>>;
Input@4 =:= 'accl-001-00' ->
<<4:3>>;
Input@4 =:= 'accl-000-10' ->
<<5:3>>;
Input@4 =:= 'accl-000-05' ->
<<6:3>>;
Input@4 =:= 'accl-000-01' ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@4}}})
end
end|begin
%% attribute confidenceSet(5) with type ConfidenceSet
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_ConfidenceSet(Input@5)
end
end].
enc_VehicleStatus_object(Val) ->
#{obDist:=Input@1,obDirect:=Input@2,dateTime:=Input@3} = Val,
[begin
%% attribute obDist(1) with type INTEGER
if Input@1 bsr 15 =:= 0 ->
<<Input@1:15>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute obDirect(2) with type INTEGER
if 0 =< Input@2, Input@2 < 28801 ->
<<Input@2:15>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end|begin
%% attribute dateTime(3) with type DDateTime
enc_DDateTime(Input@3)
end].
enc_VehicleStatus_vehicleData(Val) ->
#{height:=Input@1,bumpers:=Input@2,mass:=Input@3,trailerWeight:=Input@4,type:=Input@5} = Val,
[begin
%% attribute height(1) with type INTEGER
if Input@1 bsr 7 =:= 0 ->
<<Input@1:7>>;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute bumpers(2) with type BumperHeights
enc_BumperHeights(Input@2)
end,
begin
%% attribute mass(3) with type INTEGER
if Input@3 bsr 8 =:= 0 ->
Input@3;
true ->
exit({error,{asn1,{illegal_integer,Input@3}}})
end
end,
begin
%% attribute trailerWeight(4) with type INTEGER
if 0 =< Input@4, Input@4 < 64256 ->
<<Input@4:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@4}}})
end
end|begin
%% attribute type(5) with type ENUMERATED
if Input@5 =:= none ->
<<0:1,0:4>>;
Input@5 =:= unknown ->
<<0:1,1:4>>;
Input@5 =:= special ->
<<0:1,2:4>>;
Input@5 =:= moto ->
<<0:1,3:4>>;
Input@5 =:= car ->
<<0:1,4:4>>;
Input@5 =:= carOther ->
<<0:1,5:4>>;
Input@5 =:= bus ->
<<0:1,6:4>>;
Input@5 =:= axleCnt2 ->
<<0:1,7:4>>;
Input@5 =:= axleCnt3 ->
<<0:1,8:4>>;
Input@5 =:= axleCnt4 ->
<<0:1,9:4>>;
Input@5 =:= axleCnt4Trailer ->
<<0:1,10:4>>;
Input@5 =:= axleCnt5Trailer ->
<<0:1,11:4>>;
Input@5 =:= axleCnt6Trailer ->
<<0:1,12:4>>;
Input@5 =:= axleCnt5MultiTrailer ->
<<0:1,13:4>>;
Input@5 =:= axleCnt6MultiTrailer ->
<<0:1,14:4>>;
Input@5 =:= axleCnt7MultiTrailer ->
<<0:1,15:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@5}}})
end
end].
enc_VehicleStatus_weatherReport(Val) ->
#{isRaining:=Input@1} = Val,
Input@2 = case Val of
  #{rainRate:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{precipSituation:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{solarRadiation:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{friction:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@2 =:= asn1__MISSING_IN_MAP ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
if Input@4 =:= asn1__MISSING_IN_MAP ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
begin
%% attribute isRaining(1) with type ENUMERATED
if Input@1 =:= precip ->
<<0:2>>;
Input@1 =:= noPrecip ->
<<1:2>>;
Input@1 =:= error ->
<<2:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@1}}})
end
end,
begin
%% attribute rainRate(2) with type INTEGER
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
Input@2 bsr 16 =:= 0 ->
<<Input@2:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end,
begin
%% attribute precipSituation(3) with type ENUMERATED
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
Input@3 =:= other ->
<<0:4>>;
Input@3 =:= unknown ->
<<1:4>>;
Input@3 =:= noPrecipitation ->
<<2:4>>;
Input@3 =:= unidentifiedSlight ->
<<3:4>>;
Input@3 =:= unidentifiedModerate ->
<<4:4>>;
Input@3 =:= unidentifiedHeavy ->
<<5:4>>;
Input@3 =:= snowSlight ->
<<6:4>>;
Input@3 =:= snowModerate ->
<<7:4>>;
Input@3 =:= snowHeavy ->
<<8:4>>;
Input@3 =:= rainSlight ->
<<9:4>>;
Input@3 =:= rainModerate ->
<<10:4>>;
Input@3 =:= rainHeavy ->
<<11:4>>;
Input@3 =:= frozenPrecipitationSlight ->
<<12:4>>;
Input@3 =:= frozenPrecipitationModerate ->
<<13:4>>;
Input@3 =:= frozenPrecipitationHeavy ->
<<14:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@3}}})
end
end,
begin
%% attribute solarRadiation(4) with type INTEGER
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
Input@4 bsr 16 =:= 0 ->
<<Input@4:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@4}}})
end
end|begin
%% attribute friction(5) with type INTEGER
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@5, Input@5 < 102 ->
<<Input@5:7>>;
true ->
exit({error,{asn1,{illegal_integer,Input@5}}})
end
end].


dec_VehicleStatus(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:22,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute lights(1) with type BIT STRING
{Term1,Bytes3} = case (Opt bsr 21) band 1 of
1 ->
begin
{V3@V0,V3@Buf1} = case Bytes2 of
<<0:1,V3@V3:9/binary-unit:1,V3@Buf4/bitstring>> ->
{V3@V3,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@V8:V3@V6/binary-unit:1,V3@Buf9/bitstring>> ->
{V3@V8,V3@Buf9};
<<1:1,0:1,V3@V7:14,V3@V9:V3@V7/binary-unit:1,V3@Buf10/bitstring>> ->
{V3@V9,V3@Buf10};
<<1:1,1:1,V3@V7:6,V3@Buf8/bitstring>> ->
{V3@V9,V3@Buf10}  = decode_fragmented(V3@V7, V3@Buf8, 1),
{V3@V9,V3@Buf10}
end,
{V3@V3,V3@Buf4}
end,
{V3@V11,V3@Buf12}  = {decode_named_bit_string(V3@V0, [{lowBeamHeadlightsOn,0},{highBeamHeadlightsOn,1},{leftTurnSignalOn,2},{rightTurnSignalOn,3},{hazardSignalOn,4},{automaticLightControlOn,5},{daytimeRunningLightsOn,6},{fogLightOn,7},{parkingLightsOn,8}]),V3@Buf1},
{V3@V11,V3@Buf12}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute lightBar(2) with type ENUMERATED
{Term2,Bytes4} = case (Opt bsr 20) band 1 of
1 ->
begin
<<V4@V0:3,V4@Buf1/bitstring>> = Bytes3,
V4@Int2 = case V4@V0 of
0 -> unavailable;
1 -> notInUse;
2 -> inUse;
3 -> yellowCautionLights;
4 -> schooldBusLights;
5 -> arrowSignsActive;
6 -> slowMovingVehicle;
7 -> freqStops
end,
{V4@Int2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute wipers(3) with type WiperSet
{Term3,Bytes5} = case (Opt bsr 19) band 1 of
1 ->
dec_WiperSet(Bytes4);
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute brakeStatus(4) with type BrakeSystemStatus
{Term4,Bytes6} = case (Opt bsr 18) band 1 of
1 ->
dec_BrakeSystemStatus(Bytes5);
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute brakePressure(5) with type ENUMERATED
{Term5,Bytes7} = case (Opt bsr 17) band 1 of
1 ->
begin
<<V5@V0:4,V5@Buf1/bitstring>> = Bytes6,
V5@Int2 = case V5@V0 of
0 -> unavailable;
1 -> minPressure;
2 -> 'bkLvl-2';
3 -> 'bkLvl-3';
4 -> 'bkLvl-4';
5 -> 'bkLvl-5';
6 -> 'bkLvl-6';
7 -> 'bkLvl-7';
8 -> 'bkLvl-8';
9 -> 'bkLvl-9';
10 -> 'bkLvl-10';
11 -> 'bkLvl-11';
12 -> 'bkLvl-12';
13 -> 'bkLvl-13';
14 -> 'bkLvl-14';
15 -> maxPressure
end,
{V5@Int2,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute roadFriction(6) with type INTEGER
{Term6,Bytes8} = case (Opt bsr 16) band 1 of
1 ->
begin
<<V6@V0:6,V6@Buf1/bitstring>> = Bytes7,
{V6@V0,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute sunData(7) with type INTEGER
{Term7,Bytes9} = case (Opt bsr 15) band 1 of
1 ->
begin
<<V7@V0:10,V7@Buf1/bitstring>> = Bytes8,
{V7@V0,V7@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% attribute rainData(8) with type ENUMERATED
{Term8,Bytes10} = case (Opt bsr 14) band 1 of
1 ->
begin
<<V8@V0:3,V8@Buf1/bitstring>> = Bytes9,
V8@Int2 = case V8@V0 of
0 -> none;
1 -> lightMist;
2 -> heavyMist;
3 -> lightRainOrDrizzle;
4 -> rain;
5 -> moderateRain;
6 -> heavyRain;
7 -> heavyDownpour
end,
{V8@Int2,V8@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes9}
end,

%% attribute airTemp(9) with type INTEGER
{Term9,Bytes11} = case (Opt bsr 13) band 1 of
1 ->
begin
<<V9@V0:8,V9@Buf1/bitstring>> = Bytes10,
{V9@V0,V9@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes10}
end,

%% attribute airPres(10) with type INTEGER
{Term10,Bytes12} = case (Opt bsr 12) band 1 of
1 ->
begin
<<V10@V0:8,V10@Buf1/bitstring>> = Bytes11,
{V10@V0,V10@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes11}
end,

%% attribute steering(11) with type SEQUENCE
{Term11,Bytes13} = case (Opt bsr 11) band 1 of
1 ->
dec_VehicleStatus_steering(Bytes12);
0 ->
{asn1_NOVALUE,Bytes12}
end,

%% attribute accelSets(12) with type SEQUENCE
{Term12,Bytes14} = case (Opt bsr 10) band 1 of
1 ->
dec_VehicleStatus_accelSets(Bytes13);
0 ->
{asn1_NOVALUE,Bytes13}
end,

%% attribute object(13) with type SEQUENCE
{Term13,Bytes15} = case (Opt bsr 9) band 1 of
1 ->
dec_VehicleStatus_object(Bytes14);
0 ->
{asn1_NOVALUE,Bytes14}
end,

%% attribute fullPos(14) with type FullPositionVector
{Term14,Bytes16} = case (Opt bsr 8) band 1 of
1 ->
dec_FullPositionVector(Bytes15);
0 ->
{asn1_NOVALUE,Bytes15}
end,

%% attribute throttlePos(15) with type INTEGER
{Term15,Bytes17} = case (Opt bsr 7) band 1 of
1 ->
begin
<<V11@V0:8,V11@Buf1/bitstring>> = Bytes16,
{V11@V0,V11@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes16}
end,

%% attribute speedHeadC(16) with type SpeedandHeadingandThrottleConfidence
{Term16,Bytes18} = case (Opt bsr 6) band 1 of
1 ->
dec_SpeedandHeadingandThrottleConfidence(Bytes17);
0 ->
{asn1_NOVALUE,Bytes17}
end,

%% attribute speedC(17) with type ENUMERATED
{Term17,Bytes19} = case (Opt bsr 5) band 1 of
1 ->
begin
<<V12@V0:3,V12@Buf1/bitstring>> = Bytes18,
V12@Int2 = case V12@V0 of
0 -> unavailable;
1 -> prec100ms;
2 -> prec10ms;
3 -> prec5ms;
4 -> prec1ms;
5 -> 'prec0-1ms';
6 -> 'prec0-05ms';
7 -> 'prec0-01ms'
end,
{V12@Int2,V12@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes18}
end,

%% attribute vehicleData(18) with type SEQUENCE
{Term18,Bytes20} = case (Opt bsr 4) band 1 of
1 ->
dec_VehicleStatus_vehicleData(Bytes19);
0 ->
{asn1_NOVALUE,Bytes19}
end,

%% attribute vehicleIdent(19) with type VehicleIdent
{Term19,Bytes21} = case (Opt bsr 3) band 1 of
1 ->
dec_VehicleIdent(Bytes20);
0 ->
{asn1_NOVALUE,Bytes20}
end,

%% attribute j1939data(20) with type J1939data
{Term20,Bytes22} = case (Opt bsr 2) band 1 of
1 ->
dec_J1939data(Bytes21);
0 ->
{asn1_NOVALUE,Bytes21}
end,

%% attribute weatherReport(21) with type SEQUENCE
{Term21,Bytes23} = case (Opt bsr 1) band 1 of
1 ->
dec_VehicleStatus_weatherReport(Bytes22);
0 ->
{asn1_NOVALUE,Bytes22}
end,

%% attribute gnssStatus(22) with type BIT STRING
{Term22,Bytes24} = case Opt band 1 of
1 ->
begin
<<V13@V0:8/binary-unit:1,V13@Buf1/bitstring>> = Bytes23,
{V13@V2,V13@Buf3}  = {decode_named_bit_string(V13@V0, [{unavailable,0},{isHealthy,1},{isMonitored,2},{baseStationType,3},{aPDOPofUnder5,4},{inViewOfUnder5,5},{localCorrectionsPresent,6},{networkCorrectionsPresent,7}]),V13@Buf1},
{V13@V2,V13@Buf3}
end;
0 ->
{asn1_NOVALUE,Bytes23}
end,

%% Extensions
{Extensions,Bytes25} = case Ext of
0 -> {<<>>,Bytes24};
1 ->
{V14@V0,V14@Buf1} = case Bytes24 of
<<0:1,V14@V3:6,V14@Buf4/bitstring>> ->
V14@Add5 = V14@V3 + 1,
{V14@Add5,V14@Buf4};
<<1:1,V14@Buf2/bitstring>> ->
{V14@V3,V14@Buf4} = case V14@Buf2 of
<<0:1,V14@V6:7,V14@Buf7/bitstring>> when V14@V6 =/= 0 ->
{V14@V6,V14@Buf7};
<<1:1,0:1,V14@V7:14,V14@Buf8/bitstring>> when V14@V7 =/= 0 ->
{V14@V7,V14@Buf8}
end,
{V14@V3,V14@Buf4}
end,
<<V14@V9:V14@V0/bitstring-unit:1,V14@Buf10/bitstring>> = V14@Buf1,
{V14@V9,V14@Buf10}
end,
Bytes26= skipextensions(Bytes25, 1, Extensions),
Res1 = #{},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{lights=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{lightBar=>Term2}
end,
Res4 = case Term3 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{wipers=>Term3}
end,
Res5 = case Term4 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{brakeStatus=>Term4}
end,
Res6 = case Term5 of
  asn1_NOVALUE -> Res5;
  _ -> Res5#{brakePressure=>Term5}
end,
Res7 = case Term6 of
  asn1_NOVALUE -> Res6;
  _ -> Res6#{roadFriction=>Term6}
end,
Res8 = case Term7 of
  asn1_NOVALUE -> Res7;
  _ -> Res7#{sunData=>Term7}
end,
Res9 = case Term8 of
  asn1_NOVALUE -> Res8;
  _ -> Res8#{rainData=>Term8}
end,
Res10 = case Term9 of
  asn1_NOVALUE -> Res9;
  _ -> Res9#{airTemp=>Term9}
end,
Res11 = case Term10 of
  asn1_NOVALUE -> Res10;
  _ -> Res10#{airPres=>Term10}
end,
Res12 = case Term11 of
  asn1_NOVALUE -> Res11;
  _ -> Res11#{steering=>Term11}
end,
Res13 = case Term12 of
  asn1_NOVALUE -> Res12;
  _ -> Res12#{accelSets=>Term12}
end,
Res14 = case Term13 of
  asn1_NOVALUE -> Res13;
  _ -> Res13#{object=>Term13}
end,
Res15 = case Term14 of
  asn1_NOVALUE -> Res14;
  _ -> Res14#{fullPos=>Term14}
end,
Res16 = case Term15 of
  asn1_NOVALUE -> Res15;
  _ -> Res15#{throttlePos=>Term15}
end,
Res17 = case Term16 of
  asn1_NOVALUE -> Res16;
  _ -> Res16#{speedHeadC=>Term16}
end,
Res18 = case Term17 of
  asn1_NOVALUE -> Res17;
  _ -> Res17#{speedC=>Term17}
end,
Res19 = case Term18 of
  asn1_NOVALUE -> Res18;
  _ -> Res18#{vehicleData=>Term18}
end,
Res20 = case Term19 of
  asn1_NOVALUE -> Res19;
  _ -> Res19#{vehicleIdent=>Term19}
end,
Res21 = case Term20 of
  asn1_NOVALUE -> Res20;
  _ -> Res20#{j1939data=>Term20}
end,
Res22 = case Term21 of
  asn1_NOVALUE -> Res21;
  _ -> Res21#{weatherReport=>Term21}
end,
Res23 = case Term22 of
  asn1_NOVALUE -> Res22;
  _ -> Res22#{gnssStatus=>Term22}
end,
{Res23,Bytes26}.


dec_VehicleStatus_steering(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute angle(1) with type INTEGER
{Term1,Bytes2} = begin
<<V2@V0:8,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + -126,
{V2@Add2,V2@Buf1}
end,

%% attribute confidence(2) with type ENUMERATED
{Term2,Bytes3} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V3@V0:2,V3@Buf1/bitstring>> = Bytes2,
V3@Int2 = case V3@V0 of
0 -> unavailable;
1 -> prec2deg;
2 -> prec1deg;
3 -> 'prec0-02deg'
end,
{V3@Int2,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute rate(3) with type INTEGER
{Term3,Bytes4} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V4@V0:8,V4@Buf1/bitstring>> = Bytes3,
V4@Add2 = V4@V0 + -127,
{V4@Add2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute wheels(4) with type INTEGER
{Term4,Bytes5} = case Opt band 1 of
1 ->
begin
<<V5@V0:8,V5@Buf1/bitstring>> = Bytes4,
V5@Add2 = V5@V0 + -128,
{V5@Add2,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,
Res1 = #{angle=>Term1},
Res2 = case Term2 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{confidence=>Term2}
end,
Res3 = case Term3 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{rate=>Term3}
end,
Res4 = case Term4 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{wheels=>Term4}
end,
{Res4,Bytes5}.


dec_VehicleStatus_accelSets(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:5,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute accel4way(1) with type AccelerationSet4Way
{Term1,Bytes2} = case (Opt bsr 4) band 1 of
1 ->
dec_AccelerationSet4Way(Bytes1);
0 ->
{asn1_NOVALUE,Bytes1}
end,

%% attribute vertAccelThres(2) with type BIT STRING
{Term2,Bytes3} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V2@V0:5/binary-unit:1,V2@Buf1/bitstring>> = Bytes2,
{V2@V2,V2@Buf3}  = {decode_named_bit_string(V2@V0, [{notEquipped,0},{leftFront,1},{leftRear,2},{rightFront,3},{rightRear,4}]),V2@Buf1},
{V2@V2,V2@Buf3}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute yawRateCon(3) with type ENUMERATED
{Term3,Bytes4} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V3@V0:3,V3@Buf1/bitstring>> = Bytes3,
V3@Int2 = case V3@V0 of
0 -> unavailable;
1 -> 'degSec-100-00';
2 -> 'degSec-010-00';
3 -> 'degSec-005-00';
4 -> 'degSec-001-00';
5 -> 'degSec-000-10';
6 -> 'degSec-000-05';
7 -> 'degSec-000-01'
end,
{V3@Int2,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute hozAccelCon(4) with type ENUMERATED
{Term4,Bytes5} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V4@V0:3,V4@Buf1/bitstring>> = Bytes4,
V4@Int2 = case V4@V0 of
0 -> unavailable;
1 -> 'accl-100-00';
2 -> 'accl-010-00';
3 -> 'accl-005-00';
4 -> 'accl-001-00';
5 -> 'accl-000-10';
6 -> 'accl-000-05';
7 -> 'accl-000-01'
end,
{V4@Int2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute confidenceSet(5) with type ConfidenceSet
{Term5,Bytes6} = case Opt band 1 of
1 ->
dec_ConfidenceSet(Bytes5);
0 ->
{asn1_NOVALUE,Bytes5}
end,
Res1 = #{},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{accel4way=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{vertAccelThres=>Term2}
end,
Res4 = case Term3 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{yawRateCon=>Term3}
end,
Res5 = case Term4 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{hozAccelCon=>Term4}
end,
Res6 = case Term5 of
  asn1_NOVALUE -> Res5;
  _ -> Res5#{confidenceSet=>Term5}
end,
{Res6,Bytes6}.


dec_VehicleStatus_object(Bytes) ->

%% attribute obDist(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:15,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute obDirect(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:15,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute dateTime(3) with type DDateTime
{Term3,Bytes3} = dec_DDateTime(Bytes2),
Res1 = #{obDist=>Term1,obDirect=>Term2,dateTime=>Term3},
{Res1,Bytes3}.


dec_VehicleStatus_vehicleData(Bytes) ->

%% attribute height(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:7,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute bumpers(2) with type BumperHeights
{Term2,Bytes2} = dec_BumperHeights(Bytes1),

%% attribute mass(3) with type INTEGER
{Term3,Bytes3} = begin
<<V2@V0:8,V2@Buf1/bitstring>> = Bytes2,
{V2@V0,V2@Buf1}
end,

%% attribute trailerWeight(4) with type INTEGER
{Term4,Bytes4} = begin
<<V3@V0:16,V3@Buf1/bitstring>> = Bytes3,
{V3@V0,V3@Buf1}
end,

%% attribute type(5) with type ENUMERATED
{Term5,Bytes5} = begin
{V4@V0,V4@Buf1} = case Bytes4 of
<<0:1,V4@V3:4,V4@Buf4/bitstring>> ->
V4@Int5 = case V4@V3 of
0 -> none;
1 -> unknown;
2 -> special;
3 -> moto;
4 -> car;
5 -> carOther;
6 -> bus;
7 -> axleCnt2;
8 -> axleCnt3;
9 -> axleCnt4;
10 -> axleCnt4Trailer;
11 -> axleCnt5Trailer;
12 -> axleCnt6Trailer;
13 -> axleCnt5MultiTrailer;
14 -> axleCnt6MultiTrailer;
15 -> axleCnt7MultiTrailer
end,
{V4@Int5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:6,V4@Buf7/bitstring>> ->
{V4@V6,V4@Buf7};
<<1:1,V4@Buf5/bitstring>> ->
{V4@V6,V4@Buf7} = case V4@Buf5 of
<<0:1,V4@V9:7,V4@Buf10/bitstring>> when V4@V9 =/= 0 ->
{V4@V9,V4@Buf10};
<<1:1,0:1,V4@V10:14,V4@Buf11/bitstring>> when V4@V10 =/= 0 ->
{V4@V10,V4@Buf11}
end,
<<V4@V12:V4@V6/unit:8,V4@Buf13/bitstring>> = V4@Buf7,
{V4@V12,V4@Buf13}
end,
V4@Int14 = case V4@V3 of
_ -> {asn1_enum,V4@V3}
end,
{V4@Int14,V4@Buf4}
end,
{V4@V0,V4@Buf1}
end,
Res1 = #{height=>Term1,bumpers=>Term2,mass=>Term3,trailerWeight=>Term4,type=>Term5},
{Res1,Bytes5}.


dec_VehicleStatus_weatherReport(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute isRaining(1) with type ENUMERATED
{Term1,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
V2@Int2 = case V2@V0 of
0 -> precip;
1 -> noPrecip;
2 -> error;
_ -> exit({error,{asn1,{decode_enumerated,V2@V0}}})
end,
{V2@Int2,V2@Buf1}
end,

%% attribute rainRate(2) with type INTEGER
{Term2,Bytes3} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V3@V0:16,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute precipSituation(3) with type ENUMERATED
{Term3,Bytes4} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V4@V0:4,V4@Buf1/bitstring>> = Bytes3,
V4@Int2 = case V4@V0 of
0 -> other;
1 -> unknown;
2 -> noPrecipitation;
3 -> unidentifiedSlight;
4 -> unidentifiedModerate;
5 -> unidentifiedHeavy;
6 -> snowSlight;
7 -> snowModerate;
8 -> snowHeavy;
9 -> rainSlight;
10 -> rainModerate;
11 -> rainHeavy;
12 -> frozenPrecipitationSlight;
13 -> frozenPrecipitationModerate;
14 -> frozenPrecipitationHeavy;
_ -> exit({error,{asn1,{decode_enumerated,V4@V0}}})
end,
{V4@Int2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute solarRadiation(4) with type INTEGER
{Term4,Bytes5} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V5@V0:16,V5@Buf1/bitstring>> = Bytes4,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute friction(5) with type INTEGER
{Term5,Bytes6} = case Opt band 1 of
1 ->
begin
<<V6@V0:7,V6@Buf1/bitstring>> = Bytes5,
{V6@V0,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,
Res1 = #{isRaining=>Term1},
Res2 = case Term2 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{rainRate=>Term2}
end,
Res3 = case Term3 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{precipSituation=>Term3}
end,
Res4 = case Term4 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{solarRadiation=>Term4}
end,
Res5 = case Term5 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{friction=>Term5}
end,
{Res5,Bytes6}.

enc_VerticalOffset(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= offset1 ->
begin
ChoiceVal@sub = ChoiceVal - -64,
if ChoiceVal@sub bsr 7 =:= 0 ->
<<0:3,ChoiceVal@sub:7>>;
true ->
exit({error,{asn1,{illegal_integer,ChoiceVal}}})
end
end;
ChoiceTag =:= offset2 ->
begin
ChoiceVal@sub = ChoiceVal - -128,
if ChoiceVal@sub bsr 8 =:= 0 ->
[<<1:3,ChoiceVal@sub:8>>];
true ->
exit({error,{asn1,{illegal_integer,ChoiceVal}}})
end
end;
ChoiceTag =:= offset3 ->
begin
ChoiceVal@sub = ChoiceVal - -256,
if ChoiceVal@sub bsr 9 =:= 0 ->
<<2:3,ChoiceVal@sub:9>>;
true ->
exit({error,{asn1,{illegal_integer,ChoiceVal}}})
end
end;
ChoiceTag =:= offset4 ->
begin
ChoiceVal@sub = ChoiceVal - -512,
if ChoiceVal@sub bsr 10 =:= 0 ->
<<3:3,ChoiceVal@sub:10>>;
true ->
exit({error,{asn1,{illegal_integer,ChoiceVal}}})
end
end;
ChoiceTag =:= offset5 ->
begin
ChoiceVal@sub = ChoiceVal - -1024,
if ChoiceVal@sub bsr 11 =:= 0 ->
<<4:3,ChoiceVal@sub:11>>;
true ->
exit({error,{asn1,{illegal_integer,ChoiceVal}}})
end
end;
ChoiceTag =:= offset6 ->
begin
ChoiceVal@sub = ChoiceVal - -2048,
if ChoiceVal@sub bsr 12 =:= 0 ->
<<5:3,ChoiceVal@sub:12>>;
true ->
exit({error,{asn1,{illegal_integer,ChoiceVal}}})
end
end;
ChoiceTag =:= elevation ->
begin
ChoiceVal@sub = ChoiceVal - -4096,
if ChoiceVal@sub bsr 16 =:= 0 ->
<<6:3,ChoiceVal@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,ChoiceVal}}})
end
end;
ChoiceTag =:= regional ->
[<<7:3>>|enc_VerticalOffset_regional(ChoiceVal)]
end.
enc_VerticalOffset_regional(Val) ->
#{regionId:=Input@1,regExtValue:=Input@2} = Val,
[begin
%% attribute regionId(1) with type INTEGER
if Input@1 bsr 8 =:= 0 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc2@output = enc_os_Type4(Input@2, Input@1),
Enc2@bin = complete(Enc2@output),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end].


dec_VerticalOffset(Bytes) ->
{Choice,Bytes1} = 
begin
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
begin
<<V2@V0:7,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + -64,
{V2@Add2,V2@Buf1}
end
end,
{{offset1,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
begin
<<V3@V0:8,V3@Buf1/bitstring>> = Bytes1,
V3@Add2 = V3@V0 + -128,
{V3@Add2,V3@Buf1}
end
end,
{{offset2,Val},NewBytes};
2 ->
{Val,NewBytes} = begin
begin
<<V4@V0:9,V4@Buf1/bitstring>> = Bytes1,
V4@Add2 = V4@V0 + -256,
{V4@Add2,V4@Buf1}
end
end,
{{offset3,Val},NewBytes};
3 ->
{Val,NewBytes} = begin
begin
<<V5@V0:10,V5@Buf1/bitstring>> = Bytes1,
V5@Add2 = V5@V0 + -512,
{V5@Add2,V5@Buf1}
end
end,
{{offset4,Val},NewBytes};
4 ->
{Val,NewBytes} = begin
begin
<<V6@V0:11,V6@Buf1/bitstring>> = Bytes1,
V6@Add2 = V6@V0 + -1024,
{V6@Add2,V6@Buf1}
end
end,
{{offset5,Val},NewBytes};
5 ->
{Val,NewBytes} = begin
begin
<<V7@V0:12,V7@Buf1/bitstring>> = Bytes1,
V7@Add2 = V7@V0 + -2048,
{V7@Add2,V7@Buf1}
end
end,
{{offset6,Val},NewBytes};
6 ->
{Val,NewBytes} = begin
begin
<<V8@V0:16,V8@Buf1/bitstring>> = Bytes1,
V8@Add2 = V8@V0 + -4096,
{V8@Add2,V8@Buf1}
end
end,
{{elevation,Val},NewBytes};
7 ->
{Val,NewBytes} = begin
dec_VerticalOffset_regional(Bytes1)
end,
{{regional,Val},NewBytes}
end.

dec_VerticalOffset_regional(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = #{regionId=>Term1,regExtValue=>Term2},
{Res1,Bytes2}.

enc_WeatherProbe(Val) ->
Input@1 = case Val of
  #{airTemp:=Input@1_0} -> Input@1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@2 = case Val of
  #{airPressure:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{rainRates:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@1 =:= asn1__MISSING_IN_MAP ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@2 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1>>;
true ->
<<1:1>>
end,
begin
%% attribute airTemp(1) with type INTEGER
if Input@1 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@1, Input@1 < 192 ->
Input@1;
true ->
exit({error,{asn1,{illegal_integer,Input@1}}})
end
end,
begin
%% attribute airPressure(2) with type INTEGER
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
Input@2 bsr 8 =:= 0 ->
Input@2;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end|begin
%% attribute rainRates(3) with type WiperSet
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
true ->
enc_WiperSet(Input@3)
end
end].


dec_WeatherProbe(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:3,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute airTemp(1) with type INTEGER
{Term1,Bytes3} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V3@V0:8,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute airPressure(2) with type INTEGER
{Term2,Bytes4} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V4@V0:8,V4@Buf1/bitstring>> = Bytes3,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute rainRates(3) with type WiperSet
{Term3,Bytes5} = case Opt band 1 of
1 ->
dec_WiperSet(Bytes4);
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% Extensions
{Extensions,Bytes6} = case Ext of
0 -> {<<>>,Bytes5};
1 ->
{V5@V0,V5@Buf1} = case Bytes5 of
<<0:1,V5@V3:6,V5@Buf4/bitstring>> ->
V5@Add5 = V5@V3 + 1,
{V5@Add5,V5@Buf4};
<<1:1,V5@Buf2/bitstring>> ->
{V5@V3,V5@Buf4} = case V5@Buf2 of
<<0:1,V5@V6:7,V5@Buf7/bitstring>> when V5@V6 =/= 0 ->
{V5@V6,V5@Buf7};
<<1:1,0:1,V5@V7:14,V5@Buf8/bitstring>> when V5@V7 =/= 0 ->
{V5@V7,V5@Buf8}
end,
{V5@V3,V5@Buf4}
end,
<<V5@V9:V5@V0/bitstring-unit:1,V5@Buf10/bitstring>> = V5@Buf1,
{V5@V9,V5@Buf10}
end,
Bytes7= skipextensions(Bytes6, 1, Extensions),
Res1 = #{},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{airTemp=>Term1}
end,
Res3 = case Term2 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{airPressure=>Term2}
end,
Res4 = case Term3 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{rainRates=>Term3}
end,
{Res4,Bytes7}.

enc_WeatherReport(Val) ->
#{isRaining:=Input@1} = Val,
Input@2 = case Val of
  #{rainRate:=Input@2_0} -> Input@2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@3 = case Val of
  #{precipSituation:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{solarRadiation:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@5 = case Val of
  #{friction:=Input@5_0} -> Input@5_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@6 = case Val of
  #{roadFriction:=Input@6_0} -> Input@6_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@2 =:= asn1__MISSING_IN_MAP ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Input@3 =:= asn1__MISSING_IN_MAP ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end,
if Input@4 =:= asn1__MISSING_IN_MAP ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@5 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
begin
%% attribute isRaining(1) with type ENUMERATED
if Input@6 =:= asn1__MISSING_IN_MAP ->
if Input@1 =:= precip ->
<<0:1,0:2>>;
Input@1 =:= noPrecip ->
<<0:1,1:2>>;
Input@1 =:= error ->
<<0:1,2:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@1}}})
end;
true ->
if Input@1 =:= precip ->
<<1:1,0:2>>;
Input@1 =:= noPrecip ->
<<1:1,1:2>>;
Input@1 =:= error ->
<<1:1,2:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@1}}})
end
end
end,
begin
%% attribute rainRate(2) with type INTEGER
if Input@2 =:= asn1__MISSING_IN_MAP ->
[];
Input@2 bsr 16 =:= 0 ->
<<Input@2:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end,
begin
%% attribute precipSituation(3) with type ENUMERATED
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
Input@3 =:= other ->
<<0:4>>;
Input@3 =:= unknown ->
<<1:4>>;
Input@3 =:= noPrecipitation ->
<<2:4>>;
Input@3 =:= unidentifiedSlight ->
<<3:4>>;
Input@3 =:= unidentifiedModerate ->
<<4:4>>;
Input@3 =:= unidentifiedHeavy ->
<<5:4>>;
Input@3 =:= snowSlight ->
<<6:4>>;
Input@3 =:= snowModerate ->
<<7:4>>;
Input@3 =:= snowHeavy ->
<<8:4>>;
Input@3 =:= rainSlight ->
<<9:4>>;
Input@3 =:= rainModerate ->
<<10:4>>;
Input@3 =:= rainHeavy ->
<<11:4>>;
Input@3 =:= frozenPrecipitationSlight ->
<<12:4>>;
Input@3 =:= frozenPrecipitationModerate ->
<<13:4>>;
Input@3 =:= frozenPrecipitationHeavy ->
<<14:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@3}}})
end
end,
begin
%% attribute solarRadiation(4) with type INTEGER
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
Input@4 bsr 16 =:= 0 ->
<<Input@4:16>>;
true ->
exit({error,{asn1,{illegal_integer,Input@4}}})
end
end,
begin
%% attribute friction(5) with type INTEGER
if Input@5 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@5, Input@5 < 102 ->
<<Input@5:7>>;
true ->
exit({error,{asn1,{illegal_integer,Input@5}}})
end
end|begin
%% attribute roadFriction(6) with type INTEGER
if Input@6 =:= asn1__MISSING_IN_MAP ->
[];
0 =< Input@6, Input@6 < 51 ->
<<Input@6:6>>;
true ->
exit({error,{asn1,{illegal_integer,Input@6}}})
end
end].


dec_WeatherReport(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:5,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute isRaining(1) with type ENUMERATED
{Term1,Bytes3} = begin
<<V3@V0:2,V3@Buf1/bitstring>> = Bytes2,
V3@Int2 = case V3@V0 of
0 -> precip;
1 -> noPrecip;
2 -> error;
_ -> exit({error,{asn1,{decode_enumerated,V3@V0}}})
end,
{V3@Int2,V3@Buf1}
end,

%% attribute rainRate(2) with type INTEGER
{Term2,Bytes4} = case (Opt bsr 4) band 1 of
1 ->
begin
<<V4@V0:16,V4@Buf1/bitstring>> = Bytes3,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute precipSituation(3) with type ENUMERATED
{Term3,Bytes5} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V5@V0:4,V5@Buf1/bitstring>> = Bytes4,
V5@Int2 = case V5@V0 of
0 -> other;
1 -> unknown;
2 -> noPrecipitation;
3 -> unidentifiedSlight;
4 -> unidentifiedModerate;
5 -> unidentifiedHeavy;
6 -> snowSlight;
7 -> snowModerate;
8 -> snowHeavy;
9 -> rainSlight;
10 -> rainModerate;
11 -> rainHeavy;
12 -> frozenPrecipitationSlight;
13 -> frozenPrecipitationModerate;
14 -> frozenPrecipitationHeavy;
_ -> exit({error,{asn1,{decode_enumerated,V5@V0}}})
end,
{V5@Int2,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute solarRadiation(4) with type INTEGER
{Term4,Bytes6} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V6@V0:16,V6@Buf1/bitstring>> = Bytes5,
{V6@V0,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute friction(5) with type INTEGER
{Term5,Bytes7} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V7@V0:7,V7@Buf1/bitstring>> = Bytes6,
{V7@V0,V7@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute roadFriction(6) with type INTEGER
{Term6,Bytes8} = case Opt band 1 of
1 ->
begin
<<V8@V0:6,V8@Buf1/bitstring>> = Bytes7,
{V8@V0,V8@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% Extensions
{Extensions,Bytes9} = case Ext of
0 -> {<<>>,Bytes8};
1 ->
{V9@V0,V9@Buf1} = case Bytes8 of
<<0:1,V9@V3:6,V9@Buf4/bitstring>> ->
V9@Add5 = V9@V3 + 1,
{V9@Add5,V9@Buf4};
<<1:1,V9@Buf2/bitstring>> ->
{V9@V3,V9@Buf4} = case V9@Buf2 of
<<0:1,V9@V6:7,V9@Buf7/bitstring>> when V9@V6 =/= 0 ->
{V9@V6,V9@Buf7};
<<1:1,0:1,V9@V7:14,V9@Buf8/bitstring>> when V9@V7 =/= 0 ->
{V9@V7,V9@Buf8}
end,
{V9@V3,V9@Buf4}
end,
<<V9@V9:V9@V0/bitstring-unit:1,V9@Buf10/bitstring>> = V9@Buf1,
{V9@V9,V9@Buf10}
end,
Bytes10= skipextensions(Bytes9, 1, Extensions),
Res1 = #{isRaining=>Term1},
Res2 = case Term2 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{rainRate=>Term2}
end,
Res3 = case Term3 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{precipSituation=>Term3}
end,
Res4 = case Term4 of
  asn1_NOVALUE -> Res3;
  _ -> Res3#{solarRadiation=>Term4}
end,
Res5 = case Term5 of
  asn1_NOVALUE -> Res4;
  _ -> Res4#{friction=>Term5}
end,
Res6 = case Term6 of
  asn1_NOVALUE -> Res5;
  _ -> Res5#{roadFriction=>Term6}
end,
{Res6,Bytes10}.

enc_WiperSet(Val) ->
#{statusFront:=Input@1,rateFront:=Input@2} = Val,
Input@3 = case Val of
  #{statusRear:=Input@3_0} -> Input@3_0;
  _ -> asn1__MISSING_IN_MAP
end,
Input@4 = case Val of
  #{rateRear:=Input@4_0} -> Input@4_0;
  _ -> asn1__MISSING_IN_MAP
end,
[if Input@3 =:= asn1__MISSING_IN_MAP ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Input@4 =:= asn1__MISSING_IN_MAP ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end,
begin
%% attribute statusFront(1) with type ENUMERATED
if Input@1 =:= unavailable ->
<<0:1,0:3>>;
Input@1 =:= off ->
<<0:1,1:3>>;
Input@1 =:= intermittent ->
<<0:1,2:3>>;
Input@1 =:= low ->
<<0:1,3:3>>;
Input@1 =:= high ->
<<0:1,4:3>>;
Input@1 =:= washerInUse ->
<<0:1,5:3>>;
Input@1 =:= automaticPresent ->
<<0:1,6:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@1}}})
end
end,
begin
%% attribute rateFront(2) with type INTEGER
if Input@2 bsr 7 =:= 0 ->
<<Input@2:7>>;
true ->
exit({error,{asn1,{illegal_integer,Input@2}}})
end
end,
begin
%% attribute statusRear(3) with type ENUMERATED
if Input@3 =:= asn1__MISSING_IN_MAP ->
[];
Input@3 =:= unavailable ->
<<0:1,0:3>>;
Input@3 =:= off ->
<<0:1,1:3>>;
Input@3 =:= intermittent ->
<<0:1,2:3>>;
Input@3 =:= low ->
<<0:1,3:3>>;
Input@3 =:= high ->
<<0:1,4:3>>;
Input@3 =:= washerInUse ->
<<0:1,5:3>>;
Input@3 =:= automaticPresent ->
<<0:1,6:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Input@3}}})
end
end|begin
%% attribute rateRear(4) with type INTEGER
if Input@4 =:= asn1__MISSING_IN_MAP ->
[];
Input@4 bsr 7 =:= 0 ->
<<Input@4:7>>;
true ->
exit({error,{asn1,{illegal_integer,Input@4}}})
end
end].


dec_WiperSet(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute statusFront(1) with type ENUMERATED
{Term1,Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:3,V2@Buf4/bitstring>> ->
V2@Int5 = case V2@V3 of
0 -> unavailable;
1 -> off;
2 -> intermittent;
3 -> low;
4 -> high;
5 -> washerInUse;
6 -> automaticPresent;
_ -> exit({error,{asn1,{decode_enumerated,V2@V3}}})
end,
{V2@Int5,V2@Buf4};
<<1:1,V2@Buf2/bitstring>> ->
{V2@V3,V2@Buf4} = case V2@Buf2 of
<<0:1,V2@V6:6,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7} = case V2@Buf5 of
<<0:1,V2@V9:7,V2@Buf10/bitstring>> when V2@V9 =/= 0 ->
{V2@V9,V2@Buf10};
<<1:1,0:1,V2@V10:14,V2@Buf11/bitstring>> when V2@V10 =/= 0 ->
{V2@V10,V2@Buf11}
end,
<<V2@V12:V2@V6/unit:8,V2@Buf13/bitstring>> = V2@Buf7,
{V2@V12,V2@Buf13}
end,
V2@Int14 = case V2@V3 of
_ -> {asn1_enum,V2@V3}
end,
{V2@Int14,V2@Buf4}
end,
{V2@V0,V2@Buf1}
end,

%% attribute rateFront(2) with type INTEGER
{Term2,Bytes3} = begin
<<V3@V0:7,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute statusRear(3) with type ENUMERATED
{Term3,Bytes4} = case (Opt bsr 1) band 1 of
1 ->
begin
{V4@V0,V4@Buf1} = case Bytes3 of
<<0:1,V4@V3:3,V4@Buf4/bitstring>> ->
V4@Int5 = case V4@V3 of
0 -> unavailable;
1 -> off;
2 -> intermittent;
3 -> low;
4 -> high;
5 -> washerInUse;
6 -> automaticPresent;
_ -> exit({error,{asn1,{decode_enumerated,V4@V3}}})
end,
{V4@Int5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:6,V4@Buf7/bitstring>> ->
{V4@V6,V4@Buf7};
<<1:1,V4@Buf5/bitstring>> ->
{V4@V6,V4@Buf7} = case V4@Buf5 of
<<0:1,V4@V9:7,V4@Buf10/bitstring>> when V4@V9 =/= 0 ->
{V4@V9,V4@Buf10};
<<1:1,0:1,V4@V10:14,V4@Buf11/bitstring>> when V4@V10 =/= 0 ->
{V4@V10,V4@Buf11}
end,
<<V4@V12:V4@V6/unit:8,V4@Buf13/bitstring>> = V4@Buf7,
{V4@V12,V4@Buf13}
end,
V4@Int14 = case V4@V3 of
_ -> {asn1_enum,V4@V3}
end,
{V4@Int14,V4@Buf4}
end,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute rateRear(4) with type INTEGER
{Term4,Bytes5} = case Opt band 1 of
1 ->
begin
<<V5@V0:7,V5@Buf1/bitstring>> = Bytes4,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,
Res1 = #{statusFront=>Term1,rateFront=>Term2},
Res2 = case Term3 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{statusRear=>Term3}
end,
Res3 = case Term4 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{rateRear=>Term4}
end,
{Res3,Bytes5}.

enc_Acceleration(Val) ->
Val@sub = Val - -2000,
if 0 =< Val@sub, Val@sub < 4002 ->
<<Val@sub:12>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_Acceleration(Bytes) ->
begin
<<V1@V0:12,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -2000,
{V1@Add2,V1@Buf1}
end.

enc_AccelerationConfidence(Val) ->
if Val =:= unavailable ->
<<0:3>>;
Val =:= 'accl-100-00' ->
<<1:3>>;
Val =:= 'accl-010-00' ->
<<2:3>>;
Val =:= 'accl-005-00' ->
<<3:3>>;
Val =:= 'accl-001-00' ->
<<4:3>>;
Val =:= 'accl-000-10' ->
<<5:3>>;
Val =:= 'accl-000-05' ->
<<6:3>>;
Val =:= 'accl-000-01' ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_AccelerationConfidence(Bytes) ->
begin
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> unavailable;
1 -> 'accl-100-00';
2 -> 'accl-010-00';
3 -> 'accl-005-00';
4 -> 'accl-001-00';
5 -> 'accl-000-10';
6 -> 'accl-000-05';
7 -> 'accl-000-01'
end,
{V1@Int2,V1@Buf1}
end.

enc_AdvisorySpeedType(Val) ->
if Val =:= none ->
<<0:1,0:2>>;
Val =:= greenwave ->
<<0:1,1:2>>;
Val =:= ecoDrive ->
<<0:1,2:2>>;
Val =:= transit ->
<<0:1,3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_AdvisorySpeedType(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:2,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> none;
1 -> greenwave;
2 -> ecoDrive;
3 -> transit
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11}
end,
<<V1@V12:V1@V6/unit:8,V1@Buf13/bitstring>> = V1@Buf7,
{V1@V12,V1@Buf13}
end,
V1@Int14 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int14,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_AllowedManeuvers(Val) ->
Enc1@bs = try bit_string_name2pos_38(Val) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 12)
catch throw:invalid ->
adjust_trailing_zeroes(Val, 12)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 12 ->
Enc1@bs
end.


dec_AllowedManeuvers(Bytes) ->
begin
<<V1@V0:12/binary-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V2,V1@Buf3}  = {decode_named_bit_string(V1@V0, [{maneuverStraightAllowed,0},{maneuverLeftAllowed,1},{maneuverRightAllowed,2},{maneuverUTurnAllowed,3},{maneuverLeftTurnOnRedAllowed,4},{maneuverRightTurnOnRedAllowed,5},{maneuverLaneChangeAllowed,6},{maneuverNoStoppingAllowed,7},{yieldAllwaysRequired,8},{goWithHalt,9},{caution,10},{reserved1,11}]),V1@Buf1},
{V1@V2,V1@Buf3}
end.

enc_AmbientAirPressure(Val) ->
if Val bsr 8 =:= 0 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_AmbientAirPressure(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_AmbientAirTemperature(Val) ->
if 0 =< Val, Val < 192 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_AmbientAirTemperature(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_Angle(Val) ->
if 0 =< Val, Val < 28801 ->
<<Val:15>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_Angle(Bytes) ->
begin
<<V1@V0:15,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_AnimalPropelledType(Val) ->
if Val =:= unavailable ->
<<0:1,0:2>>;
Val =:= otherTypes ->
<<0:1,1:2>>;
Val =:= animalMounted ->
<<0:1,2:2>>;
Val =:= animalDrawnCarriage ->
<<0:1,3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_AnimalPropelledType(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:2,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> unavailable;
1 -> otherTypes;
2 -> animalMounted;
3 -> animalDrawnCarriage
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11}
end,
<<V1@V12:V1@V6/unit:8,V1@Buf13/bitstring>> = V1@Buf7,
{V1@V12,V1@Buf13}
end,
V1@Int14 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int14,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_AnimalType(Val) ->
if Val =:= unavailable ->
<<0:1,0:2>>;
Val =:= serviceUse ->
<<0:1,1:2>>;
Val =:= pet ->
<<0:1,2:2>>;
Val =:= farm ->
<<0:1,3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_AnimalType(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:2,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> unavailable;
1 -> serviceUse;
2 -> pet;
3 -> farm
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11}
end,
<<V1@V12:V1@V6/unit:8,V1@Buf13/bitstring>> = V1@Buf7,
{V1@V12,V1@Buf13}
end,
V1@Int14 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int14,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_AntiLockBrakeStatus(Val) ->
if Val =:= unavailable ->
<<0:2>>;
Val =:= off ->
<<1:2>>;
Val =:= on ->
<<2:2>>;
Val =:= engaged ->
<<3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_AntiLockBrakeStatus(Bytes) ->
begin
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> unavailable;
1 -> off;
2 -> on;
3 -> engaged
end,
{V1@Int2,V1@Buf1}
end.

enc_ApproachID(Val) ->
if Val bsr 4 =:= 0 ->
<<Val:4>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_ApproachID(Bytes) ->
begin
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_Attachment(Val) ->
if Val =:= unavailable ->
<<0:1,0:3>>;
Val =:= stroller ->
<<0:1,1:3>>;
Val =:= bicycleTrailer ->
<<0:1,2:3>>;
Val =:= cart ->
<<0:1,3:3>>;
Val =:= wheelchair ->
<<0:1,4:3>>;
Val =:= otherWalkAssistAttachments ->
<<0:1,5:3>>;
Val =:= pet ->
<<0:1,6:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_Attachment(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:3,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> unavailable;
1 -> stroller;
2 -> bicycleTrailer;
3 -> cart;
4 -> wheelchair;
5 -> otherWalkAssistAttachments;
6 -> pet;
_ -> exit({error,{asn1,{decode_enumerated,V1@V3}}})
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11}
end,
<<V1@V12:V1@V6/unit:8,V1@Buf13/bitstring>> = V1@Buf7,
{V1@V12,V1@Buf13}
end,
V1@Int14 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int14,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_AttachmentRadius(Val) ->
if 0 =< Val, Val < 201 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_AttachmentRadius(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_AuxiliaryBrakeStatus(Val) ->
if Val =:= unavailable ->
<<0:2>>;
Val =:= off ->
<<1:2>>;
Val =:= on ->
<<2:2>>;
Val =:= reserved ->
<<3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_AuxiliaryBrakeStatus(Bytes) ->
begin
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> unavailable;
1 -> off;
2 -> on;
3 -> reserved
end,
{V1@Int2,V1@Buf1}
end.

enc_BasicVehicleClass(Val) ->
if Val bsr 8 =:= 0 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_BasicVehicleClass(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_BasicVehicleRole(Val) ->
if Val =:= basicVehicle ->
<<0:1,0:5>>;
Val =:= publicTransport ->
<<0:1,1:5>>;
Val =:= specialTransport ->
<<0:1,2:5>>;
Val =:= dangerousGoods ->
<<0:1,3:5>>;
Val =:= roadWork ->
<<0:1,4:5>>;
Val =:= roadRescue ->
<<0:1,5:5>>;
Val =:= emergency ->
<<0:1,6:5>>;
Val =:= safetyCar ->
<<0:1,7:5>>;
Val =:= 'none-unknown' ->
<<0:1,8:5>>;
Val =:= truck ->
<<0:1,9:5>>;
Val =:= motorcycle ->
<<0:1,10:5>>;
Val =:= roadSideSource ->
<<0:1,11:5>>;
Val =:= police ->
<<0:1,12:5>>;
Val =:= fire ->
<<0:1,13:5>>;
Val =:= ambulance ->
<<0:1,14:5>>;
Val =:= dot ->
<<0:1,15:5>>;
Val =:= transit ->
<<0:1,16:5>>;
Val =:= slowMoving ->
<<0:1,17:5>>;
Val =:= stopNgo ->
<<0:1,18:5>>;
Val =:= cyclist ->
<<0:1,19:5>>;
Val =:= pedestrian ->
<<0:1,20:5>>;
Val =:= nonMotorized ->
<<0:1,21:5>>;
Val =:= military ->
<<0:1,22:5>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_BasicVehicleRole(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:5,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> basicVehicle;
1 -> publicTransport;
2 -> specialTransport;
3 -> dangerousGoods;
4 -> roadWork;
5 -> roadRescue;
6 -> emergency;
7 -> safetyCar;
8 -> 'none-unknown';
9 -> truck;
10 -> motorcycle;
11 -> roadSideSource;
12 -> police;
13 -> fire;
14 -> ambulance;
15 -> dot;
16 -> transit;
17 -> slowMoving;
18 -> stopNgo;
19 -> cyclist;
20 -> pedestrian;
21 -> nonMotorized;
22 -> military;
_ -> exit({error,{asn1,{decode_enumerated,V1@V3}}})
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11}
end,
<<V1@V12:V1@V6/unit:8,V1@Buf13/bitstring>> = V1@Buf7,
{V1@V12,V1@Buf13}
end,
V1@Int14 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int14,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_BrakeAppliedPressure(Val) ->
if Val =:= unavailable ->
<<0:4>>;
Val =:= minPressure ->
<<1:4>>;
Val =:= 'bkLvl-2' ->
<<2:4>>;
Val =:= 'bkLvl-3' ->
<<3:4>>;
Val =:= 'bkLvl-4' ->
<<4:4>>;
Val =:= 'bkLvl-5' ->
<<5:4>>;
Val =:= 'bkLvl-6' ->
<<6:4>>;
Val =:= 'bkLvl-7' ->
<<7:4>>;
Val =:= 'bkLvl-8' ->
<<8:4>>;
Val =:= 'bkLvl-9' ->
<<9:4>>;
Val =:= 'bkLvl-10' ->
<<10:4>>;
Val =:= 'bkLvl-11' ->
<<11:4>>;
Val =:= 'bkLvl-12' ->
<<12:4>>;
Val =:= 'bkLvl-13' ->
<<13:4>>;
Val =:= 'bkLvl-14' ->
<<14:4>>;
Val =:= maxPressure ->
<<15:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_BrakeAppliedPressure(Bytes) ->
begin
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> unavailable;
1 -> minPressure;
2 -> 'bkLvl-2';
3 -> 'bkLvl-3';
4 -> 'bkLvl-4';
5 -> 'bkLvl-5';
6 -> 'bkLvl-6';
7 -> 'bkLvl-7';
8 -> 'bkLvl-8';
9 -> 'bkLvl-9';
10 -> 'bkLvl-10';
11 -> 'bkLvl-11';
12 -> 'bkLvl-12';
13 -> 'bkLvl-13';
14 -> 'bkLvl-14';
15 -> maxPressure
end,
{V1@Int2,V1@Buf1}
end.

enc_BrakeAppliedStatus(Val) ->
Enc1@bs = try bit_string_name2pos_36(Val) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 5)
catch throw:invalid ->
adjust_trailing_zeroes(Val, 5)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 5 ->
Enc1@bs
end.


dec_BrakeAppliedStatus(Bytes) ->
begin
<<V1@V0:5/binary-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V2,V1@Buf3}  = {decode_named_bit_string(V1@V0, [{unavailable,0},{leftFront,1},{leftRear,2},{rightFront,3},{rightRear,4}]),V1@Buf1},
{V1@V2,V1@Buf3}
end.

enc_BrakeBoostApplied(Val) ->
if Val =:= unavailable ->
<<0:2>>;
Val =:= off ->
<<1:2>>;
Val =:= on ->
<<2:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_BrakeBoostApplied(Bytes) ->
begin
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> unavailable;
1 -> off;
2 -> on;
_ -> exit({error,{asn1,{decode_enumerated,V1@V0}}})
end,
{V1@Int2,V1@Buf1}
end.

enc_BumperHeight(Val) ->
if Val bsr 7 =:= 0 ->
<<Val:7>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_BumperHeight(Bytes) ->
begin
<<V1@V0:7,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_CoarseHeading(Val) ->
if 0 =< Val, Val < 241 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_CoarseHeading(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_CodeWord(Val) ->
Enc1@len = byte_size(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 4 =:= 0 ->
[<<Enc1@len@sub:4>>|Val]
end.


dec_CodeWord(Bytes) ->
begin
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
<<V1@V3:V1@Add2/binary-unit:8,V1@Buf4/bitstring>> = V1@Buf1,
V1@Conv5 = binary:copy(V1@V3),
{V1@Conv5,V1@Buf4}
end.

enc_CoefficientOfFriction(Val) ->
if 0 =< Val, Val < 51 ->
<<Val:6>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_CoefficientOfFriction(Bytes) ->
begin
<<V1@V0:6,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_Confidence(Val) ->
if 0 =< Val, Val < 201 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_Confidence(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_Count(Val) ->
if 0 =< Val, Val < 33 ->
<<Val:6>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_Count(Bytes) ->
begin
<<V1@V0:6,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_DDay(Val) ->
if Val bsr 5 =:= 0 ->
<<Val:5>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_DDay(Bytes) ->
begin
<<V1@V0:5,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_DeltaAngle(Val) ->
Val@sub = Val - -150,
if 0 =< Val@sub, Val@sub < 301 ->
<<Val@sub:9>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_DeltaAngle(Bytes) ->
begin
<<V1@V0:9,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -150,
{V1@Add2,V1@Buf1}
end.

enc_DeltaTime(Val) ->
Val@sub = Val - -122,
if 0 =< Val@sub, Val@sub < 244 ->
[Val@sub];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_DeltaTime(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -122,
{V1@Add2,V1@Buf1}
end.

enc_DescriptiveName(Val) ->
Enc1@len = length(Val),
Enc1@bin = encode_chars(Val, 7),
Enc1@len@sub = Enc1@len - 1,
if 0 =< Enc1@len@sub, Enc1@len@sub < 63 ->
[<<Enc1@len@sub:6>>|Enc1@bin]
end.


dec_DescriptiveName(Bytes) ->
begin
<<V1@V0:6,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
<<V1@V3:V1@Add2/binary-unit:7,V1@Buf4/bitstring>> = V1@Buf1,
{V1@V5,V1@Buf6}  = {decode_chars(V1@V3, 7),V1@Buf4},
{V1@V5,V1@Buf6}
end.

enc_DHour(Val) ->
if Val bsr 5 =:= 0 ->
<<Val:5>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_DHour(Bytes) ->
begin
<<V1@V0:5,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_DirectionOfUse(Val) ->
if Val =:= unavailable ->
<<0:2>>;
Val =:= forward ->
<<1:2>>;
Val =:= reverse ->
<<2:2>>;
Val =:= both ->
<<3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_DirectionOfUse(Bytes) ->
begin
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> unavailable;
1 -> forward;
2 -> reverse;
3 -> both
end,
{V1@Int2,V1@Buf1}
end.

enc_DistanceUnits(Val) ->
if Val =:= centimeter ->
<<0:3>>;
Val =:= 'cm2-5' ->
<<1:3>>;
Val =:= decimeter ->
<<2:3>>;
Val =:= meter ->
<<3:3>>;
Val =:= kilometer ->
<<4:3>>;
Val =:= foot ->
<<5:3>>;
Val =:= yard ->
<<6:3>>;
Val =:= mile ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_DistanceUnits(Bytes) ->
begin
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> centimeter;
1 -> 'cm2-5';
2 -> decimeter;
3 -> meter;
4 -> kilometer;
5 -> foot;
6 -> yard;
7 -> mile
end,
{V1@Int2,V1@Buf1}
end.

enc_DMinute(Val) ->
if 0 =< Val, Val < 61 ->
<<Val:6>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_DMinute(Bytes) ->
begin
<<V1@V0:6,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_DMonth(Val) ->
if 0 =< Val, Val < 13 ->
<<Val:4>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_DMonth(Bytes) ->
begin
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_DOffset(Val) ->
Val@sub = Val - -840,
if 0 =< Val@sub, Val@sub < 1681 ->
<<Val@sub:11>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_DOffset(Bytes) ->
begin
<<V1@V0:11,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -840,
{V1@Add2,V1@Buf1}
end.

enc_DrivenLineOffsetLg(Val) ->
Val@sub = Val - -32767,
if 0 =< Val@sub, Val@sub < 65535 ->
<<Val@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_DrivenLineOffsetLg(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -32767,
{V1@Add2,V1@Buf1}
end.

enc_DrivenLineOffsetSm(Val) ->
Val@sub = Val - -2047,
if 0 =< Val@sub, Val@sub < 4095 ->
<<Val@sub:12>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_DrivenLineOffsetSm(Bytes) ->
begin
<<V1@V0:12,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -2047,
{V1@Add2,V1@Buf1}
end.

enc_DrivingWheelAngle(Val) ->
Val@sub = Val - -128,
if Val@sub bsr 8 =:= 0 ->
[Val@sub];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_DrivingWheelAngle(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -128,
{V1@Add2,V1@Buf1}
end.

enc_DSecond(Val) ->
if Val bsr 16 =:= 0 ->
<<Val:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_DSecond(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_DSRCmsgID(Val) ->
if Val bsr 15 =:= 0 ->
<<Val:15>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_DSRCmsgID(Bytes) ->
begin
<<V1@V0:15,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_Duration(Val) ->
if 0 =< Val, Val < 3601 ->
<<Val:12>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_Duration(Bytes) ->
begin
<<V1@V0:12,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_DYear(Val) ->
if Val bsr 12 =:= 0 ->
<<Val:12>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_DYear(Bytes) ->
begin
<<V1@V0:12,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_ElevationConfidence(Val) ->
if Val =:= unavailable ->
<<0:4>>;
Val =:= 'elev-500-00' ->
<<1:4>>;
Val =:= 'elev-200-00' ->
<<2:4>>;
Val =:= 'elev-100-00' ->
<<3:4>>;
Val =:= 'elev-050-00' ->
<<4:4>>;
Val =:= 'elev-020-00' ->
<<5:4>>;
Val =:= 'elev-010-00' ->
<<6:4>>;
Val =:= 'elev-005-00' ->
<<7:4>>;
Val =:= 'elev-002-00' ->
<<8:4>>;
Val =:= 'elev-001-00' ->
<<9:4>>;
Val =:= 'elev-000-50' ->
<<10:4>>;
Val =:= 'elev-000-20' ->
<<11:4>>;
Val =:= 'elev-000-10' ->
<<12:4>>;
Val =:= 'elev-000-05' ->
<<13:4>>;
Val =:= 'elev-000-02' ->
<<14:4>>;
Val =:= 'elev-000-01' ->
<<15:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_ElevationConfidence(Bytes) ->
begin
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> unavailable;
1 -> 'elev-500-00';
2 -> 'elev-200-00';
3 -> 'elev-100-00';
4 -> 'elev-050-00';
5 -> 'elev-020-00';
6 -> 'elev-010-00';
7 -> 'elev-005-00';
8 -> 'elev-002-00';
9 -> 'elev-001-00';
10 -> 'elev-000-50';
11 -> 'elev-000-20';
12 -> 'elev-000-10';
13 -> 'elev-000-05';
14 -> 'elev-000-02';
15 -> 'elev-000-01'
end,
{V1@Int2,V1@Buf1}
end.

enc_Elevation(Val) ->
Val@sub = Val - -4096,
if Val@sub bsr 16 =:= 0 ->
<<Val@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_Elevation(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -4096,
{V1@Add2,V1@Buf1}
end.

enc_Extent(Val) ->
if Val =:= useInstantlyOnly ->
<<0:4>>;
Val =:= useFor3meters ->
<<1:4>>;
Val =:= useFor10meters ->
<<2:4>>;
Val =:= useFor50meters ->
<<3:4>>;
Val =:= useFor100meters ->
<<4:4>>;
Val =:= useFor500meters ->
<<5:4>>;
Val =:= useFor1000meters ->
<<6:4>>;
Val =:= useFor5000meters ->
<<7:4>>;
Val =:= useFor10000meters ->
<<8:4>>;
Val =:= useFor50000meters ->
<<9:4>>;
Val =:= useFor100000meters ->
<<10:4>>;
Val =:= useFor500000meters ->
<<11:4>>;
Val =:= useFor1000000meters ->
<<12:4>>;
Val =:= useFor5000000meters ->
<<13:4>>;
Val =:= useFor10000000meters ->
<<14:4>>;
Val =:= forever ->
<<15:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_Extent(Bytes) ->
begin
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> useInstantlyOnly;
1 -> useFor3meters;
2 -> useFor10meters;
3 -> useFor50meters;
4 -> useFor100meters;
5 -> useFor500meters;
6 -> useFor1000meters;
7 -> useFor5000meters;
8 -> useFor10000meters;
9 -> useFor50000meters;
10 -> useFor100000meters;
11 -> useFor500000meters;
12 -> useFor1000000meters;
13 -> useFor5000000meters;
14 -> useFor10000000meters;
15 -> forever
end,
{V1@Int2,V1@Buf1}
end.

enc_ExteriorLights(Val) ->
Enc1@bs = try bit_string_name2pos_131(Val) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 9)
catch throw:invalid ->
adjust_trailing_zeroes(Val, 9)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 9 ->
[<<0:1>>|Enc1@bs];
Enc1@bits < 128 ->
[<<1:1,Enc1@bits:8>>|Enc1@bs];
Enc1@bits < 16384 ->
[<<1:1,2:2,Enc1@bits:14>>|Enc1@bs];
true ->
[<<1:1>>|encode_fragmented(Enc1@bs, 1)]
end.


dec_ExteriorLights(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:9/binary-unit:1,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@V8:V1@V6/binary-unit:1,V1@Buf9/bitstring>> ->
{V1@V8,V1@Buf9};
<<1:1,0:1,V1@V7:14,V1@V9:V1@V7/binary-unit:1,V1@Buf10/bitstring>> ->
{V1@V9,V1@Buf10};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> ->
{V1@V9,V1@Buf10}  = decode_fragmented(V1@V7, V1@Buf8, 1),
{V1@V9,V1@Buf10}
end,
{V1@V3,V1@Buf4}
end,
{V1@V11,V1@Buf12}  = {decode_named_bit_string(V1@V0, [{lowBeamHeadlightsOn,0},{highBeamHeadlightsOn,1},{leftTurnSignalOn,2},{rightTurnSignalOn,3},{hazardSignalOn,4},{automaticLightControlOn,5},{daytimeRunningLightsOn,6},{fogLightOn,7},{parkingLightsOn,8}]),V1@Buf1},
{V1@V11,V1@Buf12}
end.

enc_FuelType(Val) ->
if Val bsr 4 =:= 0 ->
<<Val:4>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_FuelType(Bytes) ->
begin
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_FurtherInfoID(Val) ->
Enc1@len = byte_size(Val),
if Enc1@len =:= 2 ->
Val
end.


dec_FurtherInfoID(Bytes) ->
begin
<<V1@V0:2/binary-unit:8,V1@Buf1/bitstring>> = Bytes,
V1@Conv2 = binary:copy(V1@V0),
{V1@Conv2,V1@Buf1}
end.

enc_GNSSstatus(Val) ->
Enc1@bs = try bit_string_name2pos_94(Val) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 8)
catch throw:invalid ->
adjust_trailing_zeroes(Val, 8)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 8 ->
Enc1@bs
end.


dec_GNSSstatus(Bytes) ->
begin
<<V1@V0:8/binary-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V2,V1@Buf3}  = {decode_named_bit_string(V1@V0, [{unavailable,0},{isHealthy,1},{isMonitored,2},{baseStationType,3},{aPDOPofUnder5,4},{inViewOfUnder5,5},{localCorrectionsPresent,6},{networkCorrectionsPresent,7}]),V1@Buf1},
{V1@V2,V1@Buf3}
end.

enc_GrossDistance(Val) ->
if Val bsr 10 =:= 0 ->
<<Val:10>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_GrossDistance(Bytes) ->
begin
<<V1@V0:10,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_GrossSpeed(Val) ->
if Val bsr 5 =:= 0 ->
<<Val:5>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_GrossSpeed(Bytes) ->
begin
<<V1@V0:5,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_HeadingConfidence(Val) ->
if Val =:= unavailable ->
<<0:3>>;
Val =:= prec10deg ->
<<1:3>>;
Val =:= prec05deg ->
<<2:3>>;
Val =:= prec01deg ->
<<3:3>>;
Val =:= 'prec0-1deg' ->
<<4:3>>;
Val =:= 'prec0-05deg' ->
<<5:3>>;
Val =:= 'prec0-01deg' ->
<<6:3>>;
Val =:= 'prec0-0125deg' ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_HeadingConfidence(Bytes) ->
begin
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> unavailable;
1 -> prec10deg;
2 -> prec05deg;
3 -> prec01deg;
4 -> 'prec0-1deg';
5 -> 'prec0-05deg';
6 -> 'prec0-01deg';
7 -> 'prec0-0125deg'
end,
{V1@Int2,V1@Buf1}
end.

enc_Heading(Val) ->
if 0 =< Val, Val < 28801 ->
<<Val:15>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_Heading(Bytes) ->
begin
<<V1@V0:15,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_HeadingSlice(Val) ->
Enc1@bs = try bit_string_name2pos_23(Val) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(Val, 16)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 16 ->
Enc1@bs
end.


dec_HeadingSlice(Bytes) ->
begin
<<V1@V0:16/binary-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V2,V1@Buf3}  = {decode_named_bit_string(V1@V0, [{'from000-0to022-5degrees',0},{'from022-5to045-0degrees',1},{'from045-0to067-5degrees',2},{'from067-5to090-0degrees',3},{'from090-0to112-5degrees',4},{'from112-5to135-0degrees',5},{'from135-0to157-5degrees',6},{'from157-5to180-0degrees',7},{'from180-0to202-5degrees',8},{'from202-5to225-0degrees',9},{'from225-0to247-5degrees',10},{'from247-5to270-0degrees',11},{'from270-0to292-5degrees',12},{'from292-5to315-0degrees',13},{'from315-0to337-5degrees',14},{'from337-5to360-0degrees',15}]),V1@Buf1},
{V1@V2,V1@Buf3}
end.

enc_IntersectionID(Val) ->
if Val bsr 16 =:= 0 ->
<<Val:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_IntersectionID(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_IntersectionStatusObject(Val) ->
Enc1@bs = try bit_string_name2pos_51(Val) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(Val, 16)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 16 ->
Enc1@bs
end.


dec_IntersectionStatusObject(Bytes) ->
begin
<<V1@V0:16/binary-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V2,V1@Buf3}  = {decode_named_bit_string(V1@V0, [{manualControlIsEnabled,0},{stopTimeIsActivated,1},{failureFlash,2},{preemptIsActive,3},{signalPriorityIsActive,4},{fixedTimeOperation,5},{trafficDependentOperation,6},{standbyOperation,7},{failureMode,8},{off,9},{recentMAPmessageUpdate,10},{recentChangeInMAPassignedLanesIDsUsed,11},{noValidMAPisAvailableAtThisTime,12},{noValidSPATisAvailableAtThisTime,13}]),V1@Buf1},
{V1@V2,V1@Buf3}
end.

enc_IsDolly(Val) ->
if Val =:= false ->
<<0:1>>;
Val =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Val}}})
end.


dec_IsDolly(Bytes) ->
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> false;
1 -> true
end,
{V1@Int2,V1@Buf1}
end.

enc_Iso3833VehicleType(Val) ->
if 0 =< Val, Val < 101 ->
<<Val:7>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_Iso3833VehicleType(Bytes) ->
begin
<<V1@V0:7,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_ITIStextPhrase(Val) ->
Enc1@len = length(Val),
Enc1@bin = encode_chars(Val, 7),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 4 =:= 0 ->
[<<Enc1@len@sub:4>>|Enc1@bin]
end.


dec_ITIStextPhrase(Bytes) ->
begin
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
<<V1@V3:V1@Add2/binary-unit:7,V1@Buf4/bitstring>> = V1@Buf1,
{V1@V5,V1@Buf6}  = {decode_chars(V1@V3, 7),V1@Buf4},
{V1@V5,V1@Buf6}
end.

enc_AxleLocation(Val) ->
if Val bsr 8 =:= 0 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_AxleLocation(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_AxleWeight(Val) ->
if 0 =< Val, Val < 64256 ->
<<Val:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_AxleWeight(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_CargoWeight(Val) ->
if 0 =< Val, Val < 64256 ->
<<Val:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_CargoWeight(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_DriveAxleLiftAirPressure(Val) ->
if 0 =< Val, Val < 1001 ->
<<Val:10>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_DriveAxleLiftAirPressure(Bytes) ->
begin
<<V1@V0:10,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_DriveAxleLocation(Val) ->
if Val bsr 8 =:= 0 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_DriveAxleLocation(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_DriveAxleLubePressure(Val) ->
if 0 =< Val, Val < 251 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_DriveAxleLubePressure(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_DriveAxleTemperature(Val) ->
Val@sub = Val - -40,
if 0 =< Val@sub, Val@sub < 251 ->
[Val@sub];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_DriveAxleTemperature(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -40,
{V1@Add2,V1@Buf1}
end.

enc_SteeringAxleLubePressure(Val) ->
if 0 =< Val, Val < 251 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_SteeringAxleLubePressure(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_SteeringAxleTemperature(Val) ->
Val@sub = Val - -40,
if 0 =< Val@sub, Val@sub < 251 ->
[Val@sub];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_SteeringAxleTemperature(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -40,
{V1@Add2,V1@Buf1}
end.

enc_TireLeakageRate(Val) ->
if 0 =< Val, Val < 64256 ->
<<Val:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_TireLeakageRate(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_TireLocation(Val) ->
if Val bsr 8 =:= 0 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_TireLocation(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_TirePressureThresholdDetection(Val) ->
if Val =:= noData ->
<<0:3>>;
Val =:= overPressure ->
<<1:3>>;
Val =:= noWarningPressure ->
<<2:3>>;
Val =:= underPressure ->
<<3:3>>;
Val =:= extremeUnderPressure ->
<<4:3>>;
Val =:= undefined ->
<<5:3>>;
Val =:= errorIndicator ->
<<6:3>>;
Val =:= notAvailable ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_TirePressureThresholdDetection(Bytes) ->
begin
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> noData;
1 -> overPressure;
2 -> noWarningPressure;
3 -> underPressure;
4 -> extremeUnderPressure;
5 -> undefined;
6 -> errorIndicator;
7 -> notAvailable
end,
{V1@Int2,V1@Buf1}
end.

enc_TirePressure(Val) ->
if 0 =< Val, Val < 251 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_TirePressure(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_TireTemp(Val) ->
Val@sub = Val - -8736,
if 0 =< Val@sub, Val@sub < 64256 ->
<<Val@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_TireTemp(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -8736,
{V1@Add2,V1@Buf1}
end.

enc_TrailerWeight(Val) ->
if 0 =< Val, Val < 64256 ->
<<Val:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_TrailerWeight(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_WheelEndElectFault(Val) ->
if Val =:= isOk ->
<<0:2>>;
Val =:= isNotDefined ->
<<1:2>>;
Val =:= isError ->
<<2:2>>;
Val =:= isNotSupported ->
<<3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_WheelEndElectFault(Bytes) ->
begin
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> isOk;
1 -> isNotDefined;
2 -> isError;
3 -> isNotSupported
end,
{V1@Int2,V1@Buf1}
end.

enc_WheelSensorStatus(Val) ->
if Val =:= off ->
<<0:2>>;
Val =:= on ->
<<1:2>>;
Val =:= notDefined ->
<<2:2>>;
Val =:= notSupported ->
<<3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_WheelSensorStatus(Bytes) ->
begin
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> off;
1 -> on;
2 -> notDefined;
3 -> notSupported
end,
{V1@Int2,V1@Buf1}
end.

'enc_LaneAttributes-Barrier'(Val) ->
Enc1@bs = try bit_string_name2pos_73(Val) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(Val, 16)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 16 ->
Enc1@bs
end.


'dec_LaneAttributes-Barrier'(Bytes) ->
begin
<<V1@V0:16/binary-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V2,V1@Buf3}  = {decode_named_bit_string(V1@V0, [{'median-RevocableLane',0},{median,1},{whiteLineHashing,2},{stripedLines,3},{doubleStripedLines,4},{trafficCones,5},{constructionBarrier,6},{trafficChannels,7},{lowCurbs,8},{highCurbs,9}]),V1@Buf1},
{V1@V2,V1@Buf3}
end.

'enc_LaneAttributes-Bike'(Val) ->
Enc1@bs = try bit_string_name2pos_71(Val) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(Val, 16)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 16 ->
Enc1@bs
end.


'dec_LaneAttributes-Bike'(Bytes) ->
begin
<<V1@V0:16/binary-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V2,V1@Buf3}  = {decode_named_bit_string(V1@V0, [{bikeRevocableLane,0},{pedestrianUseAllowed,1},{isBikeFlyOverLane,2},{fixedCycleTime,3},{biDirectionalCycleTimes,4},{isolatedByBarrier,5},{unsignalizedSegmentsPresent,6}]),V1@Buf1},
{V1@V2,V1@Buf3}
end.

'enc_LaneAttributes-Crosswalk'(Val) ->
Enc1@bs = try bit_string_name2pos_70(Val) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(Val, 16)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 16 ->
Enc1@bs
end.


'dec_LaneAttributes-Crosswalk'(Bytes) ->
begin
<<V1@V0:16/binary-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V2,V1@Buf3}  = {decode_named_bit_string(V1@V0, [{crosswalkRevocableLane,0},{bicyleUseAllowed,1},{isXwalkFlyOverLane,2},{fixedCycleTime,3},{biDirectionalCycleTimes,4},{hasPushToWalkButton,5},{audioSupport,6},{rfSignalRequestPresent,7},{unsignalizedSegmentsPresent,8}]),V1@Buf1},
{V1@V2,V1@Buf3}
end.

'enc_LaneAttributes-Parking'(Val) ->
Enc1@bs = try bit_string_name2pos_76(Val) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(Val, 16)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 16 ->
Enc1@bs
end.


'dec_LaneAttributes-Parking'(Bytes) ->
begin
<<V1@V0:16/binary-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V2,V1@Buf3}  = {decode_named_bit_string(V1@V0, [{parkingRevocableLane,0},{parallelParkingInUse,1},{headInParkingInUse,2},{doNotParkZone,3},{parkingForBusUse,4},{parkingForTaxiUse,5},{noPublicParkingUse,6}]),V1@Buf1},
{V1@V2,V1@Buf3}
end.

'enc_LaneAttributes-Sidewalk'(Val) ->
Enc1@bs = try bit_string_name2pos_72(Val) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(Val, 16)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 16 ->
Enc1@bs
end.


'dec_LaneAttributes-Sidewalk'(Bytes) ->
begin
<<V1@V0:16/binary-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V2,V1@Buf3}  = {decode_named_bit_string(V1@V0, [{'sidewalk-RevocableLane',0},{bicyleUseAllowed,1},{isSidewalkFlyOverLane,2},{walkBikes,3}]),V1@Buf1},
{V1@V2,V1@Buf3}
end.

'enc_LaneAttributes-Striping'(Val) ->
Enc1@bs = try bit_string_name2pos_74(Val) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(Val, 16)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 16 ->
Enc1@bs
end.


'dec_LaneAttributes-Striping'(Bytes) ->
begin
<<V1@V0:16/binary-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V2,V1@Buf3}  = {decode_named_bit_string(V1@V0, [{stripeToConnectingLanesRevocableLane,0},{stripeDrawOnLeft,1},{stripeDrawOnRight,2},{stripeToConnectingLanesLeft,3},{stripeToConnectingLanesRight,4},{stripeToConnectingLanesAhead,5}]),V1@Buf1},
{V1@V2,V1@Buf3}
end.

'enc_LaneAttributes-TrackedVehicle'(Val) ->
Enc1@bs = try bit_string_name2pos_75(Val) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(Val, 16)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 16 ->
Enc1@bs
end.


'dec_LaneAttributes-TrackedVehicle'(Bytes) ->
begin
<<V1@V0:16/binary-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V2,V1@Buf3}  = {decode_named_bit_string(V1@V0, [{'spec-RevocableLane',0},{'spec-commuterRailRoadTrack',1},{'spec-lightRailRoadTrack',2},{'spec-heavyRailRoadTrack',3},{'spec-otherRailType',4}]),V1@Buf1},
{V1@V2,V1@Buf3}
end.

'enc_LaneAttributes-Vehicle'(Val) ->
Enc1@bs = try bit_string_name2pos_69(Val) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 8)
catch throw:invalid ->
adjust_trailing_zeroes(Val, 8)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 8 ->
[<<0:1>>|Enc1@bs];
Enc1@bits < 128 ->
[<<1:1,Enc1@bits:8>>|Enc1@bs];
Enc1@bits < 16384 ->
[<<1:1,2:2,Enc1@bits:14>>|Enc1@bs];
true ->
[<<1:1>>|encode_fragmented(Enc1@bs, 1)]
end.


'dec_LaneAttributes-Vehicle'(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:8/binary-unit:1,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@V8:V1@V6/binary-unit:1,V1@Buf9/bitstring>> ->
{V1@V8,V1@Buf9};
<<1:1,0:1,V1@V7:14,V1@V9:V1@V7/binary-unit:1,V1@Buf10/bitstring>> ->
{V1@V9,V1@Buf10};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> ->
{V1@V9,V1@Buf10}  = decode_fragmented(V1@V7, V1@Buf8, 1),
{V1@V9,V1@Buf10}
end,
{V1@V3,V1@Buf4}
end,
{V1@V11,V1@Buf12}  = {decode_named_bit_string(V1@V0, [{isVehicleRevocableLane,0},{isVehicleFlyOverLane,1},{hovLaneUseOnly,2},{restrictedToBusUse,3},{restrictedToTaxiUse,4},{restrictedFromPublicUse,5},{hasIRbeaconCoverage,6},{permissionOnRequest,7}]),V1@Buf1},
{V1@V11,V1@Buf12}
end.

enc_LaneConnectionID(Val) ->
if Val bsr 8 =:= 0 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_LaneConnectionID(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_LaneDirection(Val) ->
Enc1@bs = try bit_string_name2pos_62(Val) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 2)
catch throw:invalid ->
adjust_trailing_zeroes(Val, 2)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 2 ->
Enc1@bs
end.


dec_LaneDirection(Bytes) ->
begin
<<V1@V0:2/binary-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V2,V1@Buf3}  = {decode_named_bit_string(V1@V0, [{ingressPath,0},{egressPath,1}]),V1@Buf1},
{V1@V2,V1@Buf3}
end.

enc_LaneID(Val) ->
if Val bsr 8 =:= 0 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_LaneID(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_LaneSharing(Val) ->
Enc1@bs = try bit_string_name2pos_63(Val) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 10)
catch throw:invalid ->
adjust_trailing_zeroes(Val, 10)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 10 ->
Enc1@bs
end.


dec_LaneSharing(Bytes) ->
begin
<<V1@V0:10/binary-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V2,V1@Buf3}  = {decode_named_bit_string(V1@V0, [{overlappingLaneDescriptionProvided,0},{multipleLanesTreatedAsOneLane,1},{otherNonMotorizedTrafficTypes,2},{individualMotorizedVehicleTraffic,3},{busVehicleTraffic,4},{taxiVehicleTraffic,5},{pedestriansTraffic,6},{cyclistVehicleTraffic,7},{trackedVehicleTraffic,8},{pedestrianTraffic,9}]),V1@Buf1},
{V1@V2,V1@Buf3}
end.

enc_LaneWidth(Val) ->
if Val bsr 15 =:= 0 ->
<<Val:15>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_LaneWidth(Bytes) ->
begin
<<V1@V0:15,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_Latitude(Val) ->
Val@sub = Val - -900000000,
if 0 =< Val@sub, Val@sub < 1800000002 ->
<<Val@sub:31>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_Latitude(Bytes) ->
begin
<<V1@V0:31,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -900000000,
{V1@Add2,V1@Buf1}
end.

enc_LayerID(Val) ->
if 0 =< Val, Val < 101 ->
<<Val:7>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_LayerID(Bytes) ->
begin
<<V1@V0:7,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_LayerType(Val) ->
if Val =:= none ->
<<0:1,0:3>>;
Val =:= mixedContent ->
<<0:1,1:3>>;
Val =:= generalMapData ->
<<0:1,2:3>>;
Val =:= intersectionData ->
<<0:1,3:3>>;
Val =:= curveData ->
<<0:1,4:3>>;
Val =:= roadwaySectionData ->
<<0:1,5:3>>;
Val =:= parkingAreaData ->
<<0:1,6:3>>;
Val =:= sharedLaneData ->
<<0:1,7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_LayerType(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:3,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> none;
1 -> mixedContent;
2 -> generalMapData;
3 -> intersectionData;
4 -> curveData;
5 -> roadwaySectionData;
6 -> parkingAreaData;
7 -> sharedLaneData
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11}
end,
<<V1@V12:V1@V6/unit:8,V1@Buf13/bitstring>> = V1@Buf7,
{V1@V12,V1@Buf13}
end,
V1@Int14 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int14,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_LightbarInUse(Val) ->
if Val =:= unavailable ->
<<0:3>>;
Val =:= notInUse ->
<<1:3>>;
Val =:= inUse ->
<<2:3>>;
Val =:= yellowCautionLights ->
<<3:3>>;
Val =:= schooldBusLights ->
<<4:3>>;
Val =:= arrowSignsActive ->
<<5:3>>;
Val =:= slowMovingVehicle ->
<<6:3>>;
Val =:= freqStops ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_LightbarInUse(Bytes) ->
begin
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> unavailable;
1 -> notInUse;
2 -> inUse;
3 -> yellowCautionLights;
4 -> schooldBusLights;
5 -> arrowSignsActive;
6 -> slowMovingVehicle;
7 -> freqStops
end,
{V1@Int2,V1@Buf1}
end.

enc_Longitude(Val) ->
Val@sub = Val - -1799999999,
if 0 =< Val@sub, Val@sub < 3600000001 ->
<<Val@sub:32>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_Longitude(Bytes) ->
begin
<<V1@V0:32,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -1799999999,
{V1@Add2,V1@Buf1}
end.

'enc_Location-quality'(Val) ->
if Val =:= 'loc-qual-bt1m' ->
<<0:3>>;
Val =:= 'loc-qual-bt5m' ->
<<1:3>>;
Val =:= 'loc-qual-bt12m' ->
<<2:3>>;
Val =:= 'loc-qual-bt50m' ->
<<3:3>>;
Val =:= 'loc-qual-bt125m' ->
<<4:3>>;
Val =:= 'loc-qual-bt500m' ->
<<5:3>>;
Val =:= 'loc-qual-bt1250m' ->
<<6:3>>;
Val =:= 'loc-qual-unknown' ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


'dec_Location-quality'(Bytes) ->
begin
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> 'loc-qual-bt1m';
1 -> 'loc-qual-bt5m';
2 -> 'loc-qual-bt12m';
3 -> 'loc-qual-bt50m';
4 -> 'loc-qual-bt125m';
5 -> 'loc-qual-bt500m';
6 -> 'loc-qual-bt1250m';
7 -> 'loc-qual-unknown'
end,
{V1@Int2,V1@Buf1}
end.

'enc_Location-tech'(Val) ->
if Val =:= 'loc-tech-unknown' ->
<<0:1,0:4>>;
Val =:= 'loc-tech-GNSS' ->
<<0:1,1:4>>;
Val =:= 'loc-tech-DGPS' ->
<<0:1,2:4>>;
Val =:= 'loc-tech-RTK' ->
<<0:1,3:4>>;
Val =:= 'loc-tech-PPP' ->
<<0:1,4:4>>;
Val =:= 'loc-tech-drGPS' ->
<<0:1,5:4>>;
Val =:= 'loc-tech-drDGPS' ->
<<0:1,6:4>>;
Val =:= 'loc-tech-dr' ->
<<0:1,7:4>>;
Val =:= 'loc-tech-nav' ->
<<0:1,8:4>>;
Val =:= 'loc-tech-fault' ->
<<0:1,9:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


'dec_Location-tech'(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:4,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> 'loc-tech-unknown';
1 -> 'loc-tech-GNSS';
2 -> 'loc-tech-DGPS';
3 -> 'loc-tech-RTK';
4 -> 'loc-tech-PPP';
5 -> 'loc-tech-drGPS';
6 -> 'loc-tech-drDGPS';
7 -> 'loc-tech-dr';
8 -> 'loc-tech-nav';
9 -> 'loc-tech-fault';
_ -> exit({error,{asn1,{decode_enumerated,V1@V3}}})
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11}
end,
<<V1@V12:V1@V6/unit:8,V1@Buf13/bitstring>> = V1@Buf7,
{V1@V12,V1@Buf13}
end,
V1@Int14 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int14,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_MergeDivergeNodeAngle(Val) ->
Val@sub = Val - -180,
if 0 =< Val@sub, Val@sub < 361 ->
<<Val@sub:9>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_MergeDivergeNodeAngle(Bytes) ->
begin
<<V1@V0:9,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -180,
{V1@Add2,V1@Buf1}
end.

enc_MessageBLOB(Val) ->
Enc1@len = byte_size(Val),
Enc1@len@sub = Enc1@len - 10,
if 0 =< Enc1@len@sub, Enc1@len@sub < 1991 ->
[<<Enc1@len@sub:11>>|Val]
end.


dec_MessageBLOB(Bytes) ->
begin
<<V1@V0:11,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 10,
<<V1@V3:V1@Add2/binary-unit:8,V1@Buf4/bitstring>> = V1@Buf1,
V1@Conv5 = binary:copy(V1@V3),
{V1@Conv5,V1@Buf4}
end.

enc_MinuteOfTheYear(Val) ->
if 0 =< Val, Val < 527041 ->
<<Val:20>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_MinuteOfTheYear(Bytes) ->
begin
<<V1@V0:20,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_MinutesDuration(Val) ->
if 0 =< Val, Val < 32001 ->
<<Val:15>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_MinutesDuration(Bytes) ->
begin
<<V1@V0:15,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_MotorizedPropelledType(Val) ->
if Val =:= unavailable ->
<<0:1,0:3>>;
Val =:= otherTypes ->
<<0:1,1:3>>;
Val =:= wheelChair ->
<<0:1,2:3>>;
Val =:= bicycle ->
<<0:1,3:3>>;
Val =:= scooter ->
<<0:1,4:3>>;
Val =:= selfBalancingDevice ->
<<0:1,5:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_MotorizedPropelledType(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:3,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> unavailable;
1 -> otherTypes;
2 -> wheelChair;
3 -> bicycle;
4 -> scooter;
5 -> selfBalancingDevice;
_ -> exit({error,{asn1,{decode_enumerated,V1@V3}}})
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11}
end,
<<V1@V12:V1@V6/unit:8,V1@Buf13/bitstring>> = V1@Buf7,
{V1@V12,V1@Buf13}
end,
V1@Int14 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int14,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_MovementPhaseState(Val) ->
if Val =:= unavailable ->
<<0:4>>;
Val =:= dark ->
<<1:4>>;
Val =:= 'stop-Then-Proceed' ->
<<2:4>>;
Val =:= 'stop-And-Remain' ->
<<3:4>>;
Val =:= 'pre-Movement' ->
<<4:4>>;
Val =:= 'permissive-Movement-Allowed' ->
<<5:4>>;
Val =:= 'protected-Movement-Allowed' ->
<<6:4>>;
Val =:= 'permissive-clearance' ->
<<7:4>>;
Val =:= 'protected-clearance' ->
<<8:4>>;
Val =:= 'caution-Conflicting-Traffic' ->
<<9:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_MovementPhaseState(Bytes) ->
begin
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> unavailable;
1 -> dark;
2 -> 'stop-Then-Proceed';
3 -> 'stop-And-Remain';
4 -> 'pre-Movement';
5 -> 'permissive-Movement-Allowed';
6 -> 'protected-Movement-Allowed';
7 -> 'permissive-clearance';
8 -> 'protected-clearance';
9 -> 'caution-Conflicting-Traffic';
_ -> exit({error,{asn1,{decode_enumerated,V1@V0}}})
end,
{V1@Int2,V1@Buf1}
end.

enc_MsgCount(Val) ->
if Val bsr 7 =:= 0 ->
<<Val:7>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_MsgCount(Bytes) ->
begin
<<V1@V0:7,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_MsgCRC(Val) ->
Enc1@len = byte_size(Val),
if Enc1@len =:= 2 ->
Val
end.


dec_MsgCRC(Bytes) ->
begin
<<V1@V0:2/binary-unit:8,V1@Buf1/bitstring>> = Bytes,
V1@Conv2 = binary:copy(V1@V0),
{V1@Conv2,V1@Buf1}
end.

enc_MultiVehicleResponse(Val) ->
if Val =:= unavailable ->
<<0:2>>;
Val =:= singleVehicle ->
<<1:2>>;
Val =:= multiVehicle ->
<<2:2>>;
Val =:= reserved ->
<<3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_MultiVehicleResponse(Bytes) ->
begin
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> unavailable;
1 -> singleVehicle;
2 -> multiVehicle;
3 -> reserved
end,
{V1@Int2,V1@Buf1}
end.

enc_MUTCDCode(Val) ->
if Val =:= none ->
<<0:1,0:3>>;
Val =:= regulatory ->
<<0:1,1:3>>;
Val =:= warning ->
<<0:1,2:3>>;
Val =:= maintenance ->
<<0:1,3:3>>;
Val =:= motoristService ->
<<0:1,4:3>>;
Val =:= guide ->
<<0:1,5:3>>;
Val =:= rec ->
<<0:1,6:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_MUTCDCode(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:3,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> none;
1 -> regulatory;
2 -> warning;
3 -> maintenance;
4 -> motoristService;
5 -> guide;
6 -> rec;
_ -> exit({error,{asn1,{decode_enumerated,V1@V3}}})
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11}
end,
<<V1@V12:V1@V6/unit:8,V1@Buf13/bitstring>> = V1@Buf7,
{V1@V12,V1@Buf13}
end,
V1@Int14 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int14,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

'enc_NMEA-MsgType'(Val) ->
if Val bsr 15 =:= 0 ->
<<Val:15>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


'dec_NMEA-MsgType'(Bytes) ->
begin
<<V1@V0:15,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

'enc_NMEA-Payload'(Val) ->
Enc1@len = byte_size(Val),
Enc1@len@sub = Enc1@len - 1,
if 0 =< Enc1@len@sub, Enc1@len@sub < 1023 ->
[<<Enc1@len@sub:10>>|Val]
end.


'dec_NMEA-Payload'(Bytes) ->
begin
<<V1@V0:10,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
<<V1@V3:V1@Add2/binary-unit:8,V1@Buf4/bitstring>> = V1@Buf1,
V1@Conv5 = binary:copy(V1@V3),
{V1@Conv5,V1@Buf4}
end.

'enc_NMEA-Revision'(Val) ->
if Val =:= unknown ->
<<0:1,0:3>>;
Val =:= reserved ->
<<0:1,1:3>>;
Val =:= rev1 ->
<<0:1,2:3>>;
Val =:= rev2 ->
<<0:1,3:3>>;
Val =:= rev3 ->
<<0:1,4:3>>;
Val =:= rev4 ->
<<0:1,5:3>>;
Val =:= rev5 ->
<<0:1,6:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


'dec_NMEA-Revision'(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:3,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> unknown;
1 -> reserved;
2 -> rev1;
3 -> rev2;
4 -> rev3;
5 -> rev4;
6 -> rev5;
_ -> exit({error,{asn1,{decode_enumerated,V1@V3}}})
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11}
end,
<<V1@V12:V1@V6/unit:8,V1@Buf13/bitstring>> = V1@Buf7,
{V1@V12,V1@Buf13}
end,
V1@Int14 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int14,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_NodeAttributeLL(Val) ->
if Val =:= reserved ->
<<0:1,0:4>>;
Val =:= stopLine ->
<<0:1,1:4>>;
Val =:= roundedCapStyleA ->
<<0:1,2:4>>;
Val =:= roundedCapStyleB ->
<<0:1,3:4>>;
Val =:= mergePoint ->
<<0:1,4:4>>;
Val =:= divergePoint ->
<<0:1,5:4>>;
Val =:= downstreamStopLine ->
<<0:1,6:4>>;
Val =:= downstreamStartNode ->
<<0:1,7:4>>;
Val =:= closedToTraffic ->
<<0:1,8:4>>;
Val =:= safeIsland ->
<<0:1,9:4>>;
Val =:= curbPresentAtStepOff ->
<<0:1,10:4>>;
Val =:= hydrantPresent ->
<<0:1,11:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_NodeAttributeLL(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:4,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> reserved;
1 -> stopLine;
2 -> roundedCapStyleA;
3 -> roundedCapStyleB;
4 -> mergePoint;
5 -> divergePoint;
6 -> downstreamStopLine;
7 -> downstreamStartNode;
8 -> closedToTraffic;
9 -> safeIsland;
10 -> curbPresentAtStepOff;
11 -> hydrantPresent;
_ -> exit({error,{asn1,{decode_enumerated,V1@V3}}})
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11}
end,
<<V1@V12:V1@V6/unit:8,V1@Buf13/bitstring>> = V1@Buf7,
{V1@V12,V1@Buf13}
end,
V1@Int14 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int14,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_NodeAttributeXY(Val) ->
if Val =:= reserved ->
<<0:1,0:4>>;
Val =:= stopLine ->
<<0:1,1:4>>;
Val =:= roundedCapStyleA ->
<<0:1,2:4>>;
Val =:= roundedCapStyleB ->
<<0:1,3:4>>;
Val =:= mergePoint ->
<<0:1,4:4>>;
Val =:= divergePoint ->
<<0:1,5:4>>;
Val =:= downstreamStopLine ->
<<0:1,6:4>>;
Val =:= downstreamStartNode ->
<<0:1,7:4>>;
Val =:= closedToTraffic ->
<<0:1,8:4>>;
Val =:= safeIsland ->
<<0:1,9:4>>;
Val =:= curbPresentAtStepOff ->
<<0:1,10:4>>;
Val =:= hydrantPresent ->
<<0:1,11:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_NodeAttributeXY(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:4,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> reserved;
1 -> stopLine;
2 -> roundedCapStyleA;
3 -> roundedCapStyleB;
4 -> mergePoint;
5 -> divergePoint;
6 -> downstreamStopLine;
7 -> downstreamStartNode;
8 -> closedToTraffic;
9 -> safeIsland;
10 -> curbPresentAtStepOff;
11 -> hydrantPresent;
_ -> exit({error,{asn1,{decode_enumerated,V1@V3}}})
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11}
end,
<<V1@V12:V1@V6/unit:8,V1@Buf13/bitstring>> = V1@Buf7,
{V1@V12,V1@Buf13}
end,
V1@Int14 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int14,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_NumberOfParticipantsInCluster(Val) ->
if Val =:= unavailable ->
<<0:1,0:2>>;
Val =:= small ->
<<0:1,1:2>>;
Val =:= medium ->
<<0:1,2:2>>;
Val =:= large ->
<<0:1,3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_NumberOfParticipantsInCluster(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:2,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> unavailable;
1 -> small;
2 -> medium;
3 -> large
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11}
end,
<<V1@V12:V1@V6/unit:8,V1@Buf13/bitstring>> = V1@Buf7,
{V1@V12,V1@Buf13}
end,
V1@Int14 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int14,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_ObjectCount(Val) ->
if Val bsr 10 =:= 0 ->
<<Val:10>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_ObjectCount(Bytes) ->
begin
<<V1@V0:10,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_ObstacleDirection(Val) ->
if 0 =< Val, Val < 28801 ->
<<Val:15>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_ObstacleDirection(Bytes) ->
begin
<<V1@V0:15,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_ObstacleDistance(Val) ->
if Val bsr 15 =:= 0 ->
<<Val:15>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_ObstacleDistance(Bytes) ->
begin
<<V1@V0:15,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

'enc_Offset-B09'(Val) ->
Val@sub = Val - -256,
if Val@sub bsr 9 =:= 0 ->
<<Val@sub:9>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


'dec_Offset-B09'(Bytes) ->
begin
<<V1@V0:9,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -256,
{V1@Add2,V1@Buf1}
end.

'enc_Offset-B10'(Val) ->
Val@sub = Val - -512,
if Val@sub bsr 10 =:= 0 ->
<<Val@sub:10>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


'dec_Offset-B10'(Bytes) ->
begin
<<V1@V0:10,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -512,
{V1@Add2,V1@Buf1}
end.

'enc_Offset-B11'(Val) ->
Val@sub = Val - -1024,
if Val@sub bsr 11 =:= 0 ->
<<Val@sub:11>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


'dec_Offset-B11'(Bytes) ->
begin
<<V1@V0:11,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -1024,
{V1@Add2,V1@Buf1}
end.

'enc_Offset-B12'(Val) ->
Val@sub = Val - -2048,
if Val@sub bsr 12 =:= 0 ->
<<Val@sub:12>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


'dec_Offset-B12'(Bytes) ->
begin
<<V1@V0:12,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -2048,
{V1@Add2,V1@Buf1}
end.

'enc_Offset-B13'(Val) ->
Val@sub = Val - -4096,
if Val@sub bsr 13 =:= 0 ->
<<Val@sub:13>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


'dec_Offset-B13'(Bytes) ->
begin
<<V1@V0:13,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -4096,
{V1@Add2,V1@Buf1}
end.

'enc_Offset-B14'(Val) ->
Val@sub = Val - -8192,
if Val@sub bsr 14 =:= 0 ->
<<Val@sub:14>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


'dec_Offset-B14'(Bytes) ->
begin
<<V1@V0:14,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -8192,
{V1@Add2,V1@Buf1}
end.

'enc_Offset-B16'(Val) ->
Val@sub = Val - -32768,
if Val@sub bsr 16 =:= 0 ->
<<Val@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


'dec_Offset-B16'(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -32768,
{V1@Add2,V1@Buf1}
end.

'enc_OffsetLL-B12'(Val) ->
Val@sub = Val - -2048,
if Val@sub bsr 12 =:= 0 ->
<<Val@sub:12>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


'dec_OffsetLL-B12'(Bytes) ->
begin
<<V1@V0:12,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -2048,
{V1@Add2,V1@Buf1}
end.

'enc_OffsetLL-B14'(Val) ->
Val@sub = Val - -8192,
if Val@sub bsr 14 =:= 0 ->
<<Val@sub:14>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


'dec_OffsetLL-B14'(Bytes) ->
begin
<<V1@V0:14,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -8192,
{V1@Add2,V1@Buf1}
end.

'enc_OffsetLL-B16'(Val) ->
Val@sub = Val - -32768,
if Val@sub bsr 16 =:= 0 ->
<<Val@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


'dec_OffsetLL-B16'(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -32768,
{V1@Add2,V1@Buf1}
end.

'enc_OffsetLL-B18'(Val) ->
Val@sub = Val - -131072,
if Val@sub bsr 18 =:= 0 ->
<<Val@sub:18>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


'dec_OffsetLL-B18'(Bytes) ->
begin
<<V1@V0:18,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -131072,
{V1@Add2,V1@Buf1}
end.

'enc_OffsetLL-B22'(Val) ->
Val@sub = Val - -2097152,
if Val@sub bsr 22 =:= 0 ->
<<Val@sub:22>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


'dec_OffsetLL-B22'(Bytes) ->
begin
<<V1@V0:22,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -2097152,
{V1@Add2,V1@Buf1}
end.

'enc_OffsetLL-B24'(Val) ->
Val@sub = Val - -8388608,
if Val@sub bsr 24 =:= 0 ->
<<Val@sub:24>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


'dec_OffsetLL-B24'(Bytes) ->
begin
<<V1@V0:24,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -8388608,
{V1@Add2,V1@Buf1}
end.

enc_PayloadData(Val) ->
Enc1@len = byte_size(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 11 =:= 0 ->
[<<Enc1@len@sub:11>>|Val]
end.


dec_PayloadData(Bytes) ->
begin
<<V1@V0:11,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
<<V1@V3:V1@Add2/binary-unit:8,V1@Buf4/bitstring>> = V1@Buf1,
V1@Conv5 = binary:copy(V1@V3),
{V1@Conv5,V1@Buf4}
end.

enc_PedestrianBicycleDetect(Val) ->
if Val =:= false ->
<<0:1>>;
Val =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Val}}})
end.


dec_PedestrianBicycleDetect(Bytes) ->
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> false;
1 -> true
end,
{V1@Int2,V1@Buf1}
end.

enc_HumanPropelledType(Val) ->
if Val =:= unavailable ->
<<0:1,0:3>>;
Val =:= otherTypes ->
<<0:1,1:3>>;
Val =:= onFoot ->
<<0:1,2:3>>;
Val =:= skateboard ->
<<0:1,3:3>>;
Val =:= pushOrKickScooter ->
<<0:1,4:3>>;
Val =:= wheelchair ->
<<0:1,5:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_HumanPropelledType(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:3,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> unavailable;
1 -> otherTypes;
2 -> onFoot;
3 -> skateboard;
4 -> pushOrKickScooter;
5 -> wheelchair;
_ -> exit({error,{asn1,{decode_enumerated,V1@V3}}})
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11}
end,
<<V1@V12:V1@V6/unit:8,V1@Buf13/bitstring>> = V1@Buf7,
{V1@V12,V1@Buf13}
end,
V1@Int14 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int14,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_PersonalAssistive(Val) ->
Enc1@bs = try bit_string_name2pos_20(Val) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 6)
catch throw:invalid ->
adjust_trailing_zeroes(Val, 6)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 6 ->
[<<0:1>>|Enc1@bs];
Enc1@bits < 128 ->
[<<1:1,Enc1@bits:8>>|Enc1@bs];
Enc1@bits < 16384 ->
[<<1:1,2:2,Enc1@bits:14>>|Enc1@bs];
true ->
[<<1:1>>|encode_fragmented(Enc1@bs, 1)]
end.


dec_PersonalAssistive(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:6/binary-unit:1,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@V8:V1@V6/binary-unit:1,V1@Buf9/bitstring>> ->
{V1@V8,V1@Buf9};
<<1:1,0:1,V1@V7:14,V1@V9:V1@V7/binary-unit:1,V1@Buf10/bitstring>> ->
{V1@V9,V1@Buf10};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> ->
{V1@V9,V1@Buf10}  = decode_fragmented(V1@V7, V1@Buf8, 1),
{V1@V9,V1@Buf10}
end,
{V1@V3,V1@Buf4}
end,
{V1@V11,V1@Buf12}  = {decode_named_bit_string(V1@V0, [{unavailable,0},{otherType,1},{vision,2},{hearing,3},{movement,4},{cognition,5}]),V1@Buf1},
{V1@V11,V1@Buf12}
end.

enc_PersonalClusterRadius(Val) ->
if 0 =< Val, Val < 101 ->
<<Val:7>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_PersonalClusterRadius(Bytes) ->
begin
<<V1@V0:7,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_PersonalCrossingInProgress(Val) ->
if Val =:= false ->
<<0:1>>;
Val =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Val}}})
end.


dec_PersonalCrossingInProgress(Bytes) ->
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> false;
1 -> true
end,
{V1@Int2,V1@Buf1}
end.

enc_PersonalCrossingRequest(Val) ->
if Val =:= false ->
<<0:1>>;
Val =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Val}}})
end.


dec_PersonalCrossingRequest(Bytes) ->
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> false;
1 -> true
end,
{V1@Int2,V1@Buf1}
end.

enc_PersonalDeviceUsageState(Val) ->
Enc1@bs = try bit_string_name2pos_17(Val) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 9)
catch throw:invalid ->
adjust_trailing_zeroes(Val, 9)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 9 ->
[<<0:1>>|Enc1@bs];
Enc1@bits < 128 ->
[<<1:1,Enc1@bits:8>>|Enc1@bs];
Enc1@bits < 16384 ->
[<<1:1,2:2,Enc1@bits:14>>|Enc1@bs];
true ->
[<<1:1>>|encode_fragmented(Enc1@bs, 1)]
end.


dec_PersonalDeviceUsageState(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:9/binary-unit:1,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@V8:V1@V6/binary-unit:1,V1@Buf9/bitstring>> ->
{V1@V8,V1@Buf9};
<<1:1,0:1,V1@V7:14,V1@V9:V1@V7/binary-unit:1,V1@Buf10/bitstring>> ->
{V1@V9,V1@Buf10};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> ->
{V1@V9,V1@Buf10}  = decode_fragmented(V1@V7, V1@Buf8, 1),
{V1@V9,V1@Buf10}
end,
{V1@V3,V1@Buf4}
end,
{V1@V11,V1@Buf12}  = {decode_named_bit_string(V1@V0, [{unavailable,0},{other,1},{idle,2},{listeningToAudio,3},{typing,4},{calling,5},{playingGames,6},{reading,7},{viewing,8}]),V1@Buf1},
{V1@V11,V1@Buf12}
end.

enc_PersonalDeviceUserType(Val) ->
if Val =:= unavailable ->
<<0:1,0:3>>;
Val =:= aPEDESTRIAN ->
<<0:1,1:3>>;
Val =:= aPEDALCYCLIST ->
<<0:1,2:3>>;
Val =:= aPUBLICSAFETYWORKER ->
<<0:1,3:3>>;
Val =:= anANIMAL ->
<<0:1,4:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_PersonalDeviceUserType(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:3,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> unavailable;
1 -> aPEDESTRIAN;
2 -> aPEDALCYCLIST;
3 -> aPUBLICSAFETYWORKER;
4 -> anANIMAL;
_ -> exit({error,{asn1,{decode_enumerated,V1@V3}}})
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11}
end,
<<V1@V12:V1@V6/unit:8,V1@Buf13/bitstring>> = V1@Buf7,
{V1@V12,V1@Buf13}
end,
V1@Int14 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int14,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_PivotingAllowed(Val) ->
if Val =:= false ->
<<0:1>>;
Val =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Val}}})
end.


dec_PivotingAllowed(Bytes) ->
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> false;
1 -> true
end,
{V1@Int2,V1@Buf1}
end.

enc_PositionConfidence(Val) ->
if Val =:= unavailable ->
<<0:4>>;
Val =:= a500m ->
<<1:4>>;
Val =:= a200m ->
<<2:4>>;
Val =:= a100m ->
<<3:4>>;
Val =:= a50m ->
<<4:4>>;
Val =:= a20m ->
<<5:4>>;
Val =:= a10m ->
<<6:4>>;
Val =:= a5m ->
<<7:4>>;
Val =:= a2m ->
<<8:4>>;
Val =:= a1m ->
<<9:4>>;
Val =:= a50cm ->
<<10:4>>;
Val =:= a20cm ->
<<11:4>>;
Val =:= a10cm ->
<<12:4>>;
Val =:= a5cm ->
<<13:4>>;
Val =:= a2cm ->
<<14:4>>;
Val =:= a1cm ->
<<15:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_PositionConfidence(Bytes) ->
begin
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> unavailable;
1 -> a500m;
2 -> a200m;
3 -> a100m;
4 -> a50m;
5 -> a20m;
6 -> a10m;
7 -> a5m;
8 -> a2m;
9 -> a1m;
10 -> a50cm;
11 -> a20cm;
12 -> a10cm;
13 -> a5cm;
14 -> a2cm;
15 -> a1cm
end,
{V1@Int2,V1@Buf1}
end.

enc_PrioritizationResponseStatus(Val) ->
if Val =:= unknown ->
<<0:1,0:3>>;
Val =:= requested ->
<<0:1,1:3>>;
Val =:= processing ->
<<0:1,2:3>>;
Val =:= watchOtherTraffic ->
<<0:1,3:3>>;
Val =:= granted ->
<<0:1,4:3>>;
Val =:= rejected ->
<<0:1,5:3>>;
Val =:= maxPresence ->
<<0:1,6:3>>;
Val =:= reserviceLocked ->
<<0:1,7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_PrioritizationResponseStatus(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:3,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> unknown;
1 -> requested;
2 -> processing;
3 -> watchOtherTraffic;
4 -> granted;
5 -> rejected;
6 -> maxPresence;
7 -> reserviceLocked
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11}
end,
<<V1@V12:V1@V6/unit:8,V1@Buf13/bitstring>> = V1@Buf7,
{V1@V12,V1@Buf13}
end,
V1@Int14 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int14,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_Priority(Val) ->
Enc1@len = byte_size(Val),
if Enc1@len =:= 1 ->
Val
end.


dec_Priority(Bytes) ->
begin
<<V1@V0:1/binary-unit:8,V1@Buf1/bitstring>> = Bytes,
V1@Conv2 = binary:copy(V1@V0),
{V1@Conv2,V1@Buf1}
end.

enc_PriorityRequestType(Val) ->
if Val =:= priorityRequestTypeReserved ->
<<0:1,0:2>>;
Val =:= priorityRequest ->
<<0:1,1:2>>;
Val =:= priorityRequestUpdate ->
<<0:1,2:2>>;
Val =:= priorityCancellation ->
<<0:1,3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_PriorityRequestType(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:2,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> priorityRequestTypeReserved;
1 -> priorityRequest;
2 -> priorityRequestUpdate;
3 -> priorityCancellation
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11}
end,
<<V1@V12:V1@V6/unit:8,V1@Buf13/bitstring>> = V1@Buf7,
{V1@V12,V1@Buf13}
end,
V1@Int14 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int14,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_PrivilegedEventFlags(Val) ->
Enc1@bs = try bit_string_name2pos_100(Val) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(Val, 16)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 16 ->
Enc1@bs
end.


dec_PrivilegedEventFlags(Bytes) ->
begin
<<V1@V0:16/binary-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V2,V1@Buf3}  = {decode_named_bit_string(V1@V0, [{peUnavailable,0},{peEmergencyResponse,1},{peEmergencyLightsActive,2},{peEmergencySoundActive,3},{peNonEmergencyLightsActive,4},{peNonEmergencySoundActive,5}]),V1@Buf1},
{V1@V2,V1@Buf3}
end.

enc_ProbeSegmentNumber(Val) ->
if Val bsr 15 =:= 0 ->
<<Val:15>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_ProbeSegmentNumber(Bytes) ->
begin
<<V1@V0:15,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_PublicSafetyAndRoadWorkerActivity(Val) ->
Enc1@bs = try bit_string_name2pos_18(Val) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 6)
catch throw:invalid ->
adjust_trailing_zeroes(Val, 6)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 6 ->
[<<0:1>>|Enc1@bs];
Enc1@bits < 128 ->
[<<1:1,Enc1@bits:8>>|Enc1@bs];
Enc1@bits < 16384 ->
[<<1:1,2:2,Enc1@bits:14>>|Enc1@bs];
true ->
[<<1:1>>|encode_fragmented(Enc1@bs, 1)]
end.


dec_PublicSafetyAndRoadWorkerActivity(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:6/binary-unit:1,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@V8:V1@V6/binary-unit:1,V1@Buf9/bitstring>> ->
{V1@V8,V1@Buf9};
<<1:1,0:1,V1@V7:14,V1@V9:V1@V7/binary-unit:1,V1@Buf10/bitstring>> ->
{V1@V9,V1@Buf10};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> ->
{V1@V9,V1@Buf10}  = decode_fragmented(V1@V7, V1@Buf8, 1),
{V1@V9,V1@Buf10}
end,
{V1@V3,V1@Buf4}
end,
{V1@V11,V1@Buf12}  = {decode_named_bit_string(V1@V0, [{unavailable,0},{workingOnRoad,1},{settingUpClosures,2},{respondingToEvents,3},{directingTraffic,4},{otherActivities,5}]),V1@Buf1},
{V1@V11,V1@Buf12}
end.

enc_PublicSafetyDirectingTrafficSubType(Val) ->
Enc1@bs = try bit_string_name2pos_19(Val) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 7)
catch throw:invalid ->
adjust_trailing_zeroes(Val, 7)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 7 ->
[<<0:1>>|Enc1@bs];
Enc1@bits < 128 ->
[<<1:1,Enc1@bits:8>>|Enc1@bs];
Enc1@bits < 16384 ->
[<<1:1,2:2,Enc1@bits:14>>|Enc1@bs];
true ->
[<<1:1>>|encode_fragmented(Enc1@bs, 1)]
end.


dec_PublicSafetyDirectingTrafficSubType(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:7/binary-unit:1,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@V8:V1@V6/binary-unit:1,V1@Buf9/bitstring>> ->
{V1@V8,V1@Buf9};
<<1:1,0:1,V1@V7:14,V1@V9:V1@V7/binary-unit:1,V1@Buf10/bitstring>> ->
{V1@V9,V1@Buf10};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> ->
{V1@V9,V1@Buf10}  = decode_fragmented(V1@V7, V1@Buf8, 1),
{V1@V9,V1@Buf10}
end,
{V1@V3,V1@Buf4}
end,
{V1@V11,V1@Buf12}  = {decode_named_bit_string(V1@V0, [{unavailable,0},{policeAndTrafficOfficers,1},{trafficControlPersons,2},{railroadCrossingGuards,3},{civilDefenseNationalGuardMilitaryPolice,4},{emergencyOrganizationPersonnel,5},{highwayServiceVehiclePersonnel,6}]),V1@Buf1},
{V1@V11,V1@Buf12}
end.

enc_PublicSafetyEventResponderWorkerType(Val) ->
if Val =:= unavailable ->
<<0:1,0:3>>;
Val =:= towOperater ->
<<0:1,1:3>>;
Val =:= fireAndEMSWorker ->
<<0:1,2:3>>;
Val =:= aDOTWorker ->
<<0:1,3:3>>;
Val =:= lawEnforcement ->
<<0:1,4:3>>;
Val =:= hazmatResponder ->
<<0:1,5:3>>;
Val =:= animalControlWorker ->
<<0:1,6:3>>;
Val =:= otherPersonnel ->
<<0:1,7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_PublicSafetyEventResponderWorkerType(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:3,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> unavailable;
1 -> towOperater;
2 -> fireAndEMSWorker;
3 -> aDOTWorker;
4 -> lawEnforcement;
5 -> hazmatResponder;
6 -> animalControlWorker;
7 -> otherPersonnel
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11}
end,
<<V1@V12:V1@V6/unit:8,V1@Buf13/bitstring>> = V1@Buf7,
{V1@V12,V1@Buf13}
end,
V1@Int14 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int14,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_RadiusOfCurvature(Val) ->
Val@sub = Val - -32767,
if 0 =< Val@sub, Val@sub < 65535 ->
<<Val@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_RadiusOfCurvature(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -32767,
{V1@Add2,V1@Buf1}
end.

'enc_Radius-B12'(Val) ->
if Val bsr 12 =:= 0 ->
<<Val:12>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


'dec_Radius-B12'(Bytes) ->
begin
<<V1@V0:12,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_RainSensor(Val) ->
if Val =:= none ->
<<0:3>>;
Val =:= lightMist ->
<<1:3>>;
Val =:= heavyMist ->
<<2:3>>;
Val =:= lightRainOrDrizzle ->
<<3:3>>;
Val =:= rain ->
<<4:3>>;
Val =:= moderateRain ->
<<5:3>>;
Val =:= heavyRain ->
<<6:3>>;
Val =:= heavyDownpour ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_RainSensor(Bytes) ->
begin
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> none;
1 -> lightMist;
2 -> heavyMist;
3 -> lightRainOrDrizzle;
4 -> rain;
5 -> moderateRain;
6 -> heavyRain;
7 -> heavyDownpour
end,
{V1@Int2,V1@Buf1}
end.

enc_RegionId(Val) ->
if Val bsr 8 =:= 0 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_RegionId(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_RequestedItem(Val) ->
if Val =:= reserved ->
<<0:1,0:5>>;
Val =:= itemA ->
<<0:1,1:5>>;
Val =:= itemB ->
<<0:1,2:5>>;
Val =:= itemC ->
<<0:1,3:5>>;
Val =:= itemD ->
<<0:1,4:5>>;
Val =:= itemE ->
<<0:1,5:5>>;
Val =:= itemF ->
<<0:1,6:5>>;
Val =:= itemG ->
<<0:1,7:5>>;
Val =:= itemI ->
<<0:1,8:5>>;
Val =:= itemJ ->
<<0:1,9:5>>;
Val =:= itemK ->
<<0:1,10:5>>;
Val =:= itemL ->
<<0:1,11:5>>;
Val =:= itemM ->
<<0:1,12:5>>;
Val =:= itemN ->
<<0:1,13:5>>;
Val =:= itemO ->
<<0:1,14:5>>;
Val =:= itemP ->
<<0:1,15:5>>;
Val =:= itemQ ->
<<0:1,16:5>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_RequestedItem(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:5,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> reserved;
1 -> itemA;
2 -> itemB;
3 -> itemC;
4 -> itemD;
5 -> itemE;
6 -> itemF;
7 -> itemG;
8 -> itemI;
9 -> itemJ;
10 -> itemK;
11 -> itemL;
12 -> itemM;
13 -> itemN;
14 -> itemO;
15 -> itemP;
16 -> itemQ;
_ -> exit({error,{asn1,{decode_enumerated,V1@V3}}})
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11}
end,
<<V1@V12:V1@V6/unit:8,V1@Buf13/bitstring>> = V1@Buf7,
{V1@V12,V1@Buf13}
end,
V1@Int14 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int14,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_RequestID(Val) ->
if Val bsr 8 =:= 0 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_RequestID(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_RequestImportanceLevel(Val) ->
if Val =:= requestImportanceLevelUnKnown ->
<<0:4>>;
Val =:= requestImportanceLevel1 ->
<<1:4>>;
Val =:= requestImportanceLevel2 ->
<<2:4>>;
Val =:= requestImportanceLevel3 ->
<<3:4>>;
Val =:= requestImportanceLevel4 ->
<<4:4>>;
Val =:= requestImportanceLevel5 ->
<<5:4>>;
Val =:= requestImportanceLevel6 ->
<<6:4>>;
Val =:= requestImportanceLevel7 ->
<<7:4>>;
Val =:= requestImportanceLevel8 ->
<<8:4>>;
Val =:= requestImportanceLevel9 ->
<<9:4>>;
Val =:= requestImportanceLevel10 ->
<<10:4>>;
Val =:= requestImportanceLevel11 ->
<<11:4>>;
Val =:= requestImportanceLevel12 ->
<<12:4>>;
Val =:= requestImportanceLevel13 ->
<<13:4>>;
Val =:= requestImportanceLevel14 ->
<<14:4>>;
Val =:= requestImportanceReserved ->
<<15:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_RequestImportanceLevel(Bytes) ->
begin
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> requestImportanceLevelUnKnown;
1 -> requestImportanceLevel1;
2 -> requestImportanceLevel2;
3 -> requestImportanceLevel3;
4 -> requestImportanceLevel4;
5 -> requestImportanceLevel5;
6 -> requestImportanceLevel6;
7 -> requestImportanceLevel7;
8 -> requestImportanceLevel8;
9 -> requestImportanceLevel9;
10 -> requestImportanceLevel10;
11 -> requestImportanceLevel11;
12 -> requestImportanceLevel12;
13 -> requestImportanceLevel13;
14 -> requestImportanceLevel14;
15 -> requestImportanceReserved
end,
{V1@Int2,V1@Buf1}
end.

enc_RequestSubRole(Val) ->
if Val =:= requestSubRoleUnKnown ->
<<0:4>>;
Val =:= requestSubRole1 ->
<<1:4>>;
Val =:= requestSubRole2 ->
<<2:4>>;
Val =:= requestSubRole3 ->
<<3:4>>;
Val =:= requestSubRole4 ->
<<4:4>>;
Val =:= requestSubRole5 ->
<<5:4>>;
Val =:= requestSubRole6 ->
<<6:4>>;
Val =:= requestSubRole7 ->
<<7:4>>;
Val =:= requestSubRole8 ->
<<8:4>>;
Val =:= requestSubRole9 ->
<<9:4>>;
Val =:= requestSubRole10 ->
<<10:4>>;
Val =:= requestSubRole11 ->
<<11:4>>;
Val =:= requestSubRole12 ->
<<12:4>>;
Val =:= requestSubRole13 ->
<<13:4>>;
Val =:= requestSubRole14 ->
<<14:4>>;
Val =:= requestSubRoleReserved ->
<<15:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_RequestSubRole(Bytes) ->
begin
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> requestSubRoleUnKnown;
1 -> requestSubRole1;
2 -> requestSubRole2;
3 -> requestSubRole3;
4 -> requestSubRole4;
5 -> requestSubRole5;
6 -> requestSubRole6;
7 -> requestSubRole7;
8 -> requestSubRole8;
9 -> requestSubRole9;
10 -> requestSubRole10;
11 -> requestSubRole11;
12 -> requestSubRole12;
13 -> requestSubRole13;
14 -> requestSubRole14;
15 -> requestSubRoleReserved
end,
{V1@Int2,V1@Buf1}
end.

enc_ResponseType(Val) ->
if Val =:= notInUseOrNotEquipped ->
<<0:1,0:3>>;
Val =:= emergency ->
<<0:1,1:3>>;
Val =:= nonEmergency ->
<<0:1,2:3>>;
Val =:= pursuit ->
<<0:1,3:3>>;
Val =:= stationary ->
<<0:1,4:3>>;
Val =:= slowMoving ->
<<0:1,5:3>>;
Val =:= stopAndGoMovement ->
<<0:1,6:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_ResponseType(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:3,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> notInUseOrNotEquipped;
1 -> emergency;
2 -> nonEmergency;
3 -> pursuit;
4 -> stationary;
5 -> slowMoving;
6 -> stopAndGoMovement;
_ -> exit({error,{asn1,{decode_enumerated,V1@V3}}})
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11}
end,
<<V1@V12:V1@V6/unit:8,V1@Buf13/bitstring>> = V1@Buf7,
{V1@V12,V1@Buf13}
end,
V1@Int14 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int14,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_RestrictionAppliesTo(Val) ->
if Val =:= none ->
<<0:1,0:4>>;
Val =:= equippedTransit ->
<<0:1,1:4>>;
Val =:= equippedTaxis ->
<<0:1,2:4>>;
Val =:= equippedOther ->
<<0:1,3:4>>;
Val =:= emissionCompliant ->
<<0:1,4:4>>;
Val =:= equippedBicycle ->
<<0:1,5:4>>;
Val =:= weightCompliant ->
<<0:1,6:4>>;
Val =:= heightCompliant ->
<<0:1,7:4>>;
Val =:= pedestrians ->
<<0:1,8:4>>;
Val =:= slowMovingPersons ->
<<0:1,9:4>>;
Val =:= wheelchairUsers ->
<<0:1,10:4>>;
Val =:= visualDisabilities ->
<<0:1,11:4>>;
Val =:= audioDisabilities ->
<<0:1,12:4>>;
Val =:= otherUnknownDisabilities ->
<<0:1,13:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_RestrictionAppliesTo(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:4,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> none;
1 -> equippedTransit;
2 -> equippedTaxis;
3 -> equippedOther;
4 -> emissionCompliant;
5 -> equippedBicycle;
6 -> weightCompliant;
7 -> heightCompliant;
8 -> pedestrians;
9 -> slowMovingPersons;
10 -> wheelchairUsers;
11 -> visualDisabilities;
12 -> audioDisabilities;
13 -> otherUnknownDisabilities;
_ -> exit({error,{asn1,{decode_enumerated,V1@V3}}})
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11}
end,
<<V1@V12:V1@V6/unit:8,V1@Buf13/bitstring>> = V1@Buf7,
{V1@V12,V1@Buf13}
end,
V1@Int14 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int14,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_RestrictionClassID(Val) ->
if Val bsr 8 =:= 0 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_RestrictionClassID(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_RoadRegulatorID(Val) ->
if Val bsr 16 =:= 0 ->
<<Val:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_RoadRegulatorID(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_RoadSegmentID(Val) ->
if Val bsr 16 =:= 0 ->
<<Val:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_RoadSegmentID(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_RoadwayCrownAngle(Val) ->
Val@sub = Val - -128,
if Val@sub bsr 8 =:= 0 ->
[Val@sub];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_RoadwayCrownAngle(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -128,
{V1@Add2,V1@Buf1}
end.

'enc_RTCM-Revision'(Val) ->
if Val =:= unknown ->
<<0:1,0:2>>;
Val =:= rtcmRev2 ->
<<0:1,1:2>>;
Val =:= rtcmRev3 ->
<<0:1,2:2>>;
Val =:= reserved ->
<<0:1,3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


'dec_RTCM-Revision'(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:2,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> unknown;
1 -> rtcmRev2;
2 -> rtcmRev3;
3 -> reserved
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11}
end,
<<V1@V12:V1@V6/unit:8,V1@Buf13/bitstring>> = V1@Buf7,
{V1@V12,V1@Buf13}
end,
V1@Int14 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int14,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_RTCMmessage(Val) ->
Enc1@len = byte_size(Val),
Enc1@len@sub = Enc1@len - 1,
if 0 =< Enc1@len@sub, Enc1@len@sub < 1023 ->
[<<Enc1@len@sub:10>>|Val]
end.


dec_RTCMmessage(Bytes) ->
begin
<<V1@V0:10,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
<<V1@V3:V1@Add2/binary-unit:8,V1@Buf4/bitstring>> = V1@Buf1,
V1@Conv5 = binary:copy(V1@V3),
{V1@Conv5,V1@Buf4}
end.

'enc_Scale-B12'(Val) ->
Val@sub = Val - -2048,
if Val@sub bsr 12 =:= 0 ->
<<Val@sub:12>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


'dec_Scale-B12'(Bytes) ->
begin
<<V1@V0:12,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -2048,
{V1@Add2,V1@Buf1}
end.

enc_SecondOfTime(Val) ->
if 0 =< Val, Val < 62 ->
<<Val:6>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_SecondOfTime(Bytes) ->
begin
<<V1@V0:6,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_SegmentAttributeLL(Val) ->
if Val =:= reserved ->
<<0:1,0:6>>;
Val =:= doNotBlock ->
<<0:1,1:6>>;
Val =:= whiteLine ->
<<0:1,2:6>>;
Val =:= mergingLaneLeft ->
<<0:1,3:6>>;
Val =:= mergingLaneRight ->
<<0:1,4:6>>;
Val =:= curbOnLeft ->
<<0:1,5:6>>;
Val =:= curbOnRight ->
<<0:1,6:6>>;
Val =:= loadingzoneOnLeft ->
<<0:1,7:6>>;
Val =:= loadingzoneOnRight ->
<<0:1,8:6>>;
Val =:= turnOutPointOnLeft ->
<<0:1,9:6>>;
Val =:= turnOutPointOnRight ->
<<0:1,10:6>>;
Val =:= adjacentParkingOnLeft ->
<<0:1,11:6>>;
Val =:= adjacentParkingOnRight ->
<<0:1,12:6>>;
Val =:= adjacentBikeLaneOnLeft ->
<<0:1,13:6>>;
Val =:= adjacentBikeLaneOnRight ->
<<0:1,14:6>>;
Val =:= sharedBikeLane ->
<<0:1,15:6>>;
Val =:= bikeBoxInFront ->
<<0:1,16:6>>;
Val =:= transitStopOnLeft ->
<<0:1,17:6>>;
Val =:= transitStopOnRight ->
<<0:1,18:6>>;
Val =:= transitStopInLane ->
<<0:1,19:6>>;
Val =:= sharedWithTrackedVehicle ->
<<0:1,20:6>>;
Val =:= safeIsland ->
<<0:1,21:6>>;
Val =:= lowCurbsPresent ->
<<0:1,22:6>>;
Val =:= rumbleStripPresent ->
<<0:1,23:6>>;
Val =:= audibleSignalingPresent ->
<<0:1,24:6>>;
Val =:= adaptiveTimingPresent ->
<<0:1,25:6>>;
Val =:= rfSignalRequestPresent ->
<<0:1,26:6>>;
Val =:= partialCurbIntrusion ->
<<0:1,27:6>>;
Val =:= taperToLeft ->
<<0:1,28:6>>;
Val =:= taperToRight ->
<<0:1,29:6>>;
Val =:= taperToCenterLine ->
<<0:1,30:6>>;
Val =:= parallelParking ->
<<0:1,31:6>>;
Val =:= headInParking ->
<<0:1,32:6>>;
Val =:= freeParking ->
<<0:1,33:6>>;
Val =:= timeRestrictionsOnParking ->
<<0:1,34:6>>;
Val =:= costToPark ->
<<0:1,35:6>>;
Val =:= midBlockCurbPresent ->
<<0:1,36:6>>;
Val =:= unEvenPavementPresent ->
<<0:1,37:6>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_SegmentAttributeLL(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> reserved;
1 -> doNotBlock;
2 -> whiteLine;
3 -> mergingLaneLeft;
4 -> mergingLaneRight;
5 -> curbOnLeft;
6 -> curbOnRight;
7 -> loadingzoneOnLeft;
8 -> loadingzoneOnRight;
9 -> turnOutPointOnLeft;
10 -> turnOutPointOnRight;
11 -> adjacentParkingOnLeft;
12 -> adjacentParkingOnRight;
13 -> adjacentBikeLaneOnLeft;
14 -> adjacentBikeLaneOnRight;
15 -> sharedBikeLane;
16 -> bikeBoxInFront;
17 -> transitStopOnLeft;
18 -> transitStopOnRight;
19 -> transitStopInLane;
20 -> sharedWithTrackedVehicle;
21 -> safeIsland;
22 -> lowCurbsPresent;
23 -> rumbleStripPresent;
24 -> audibleSignalingPresent;
25 -> adaptiveTimingPresent;
26 -> rfSignalRequestPresent;
27 -> partialCurbIntrusion;
28 -> taperToLeft;
29 -> taperToRight;
30 -> taperToCenterLine;
31 -> parallelParking;
32 -> headInParking;
33 -> freeParking;
34 -> timeRestrictionsOnParking;
35 -> costToPark;
36 -> midBlockCurbPresent;
37 -> unEvenPavementPresent;
_ -> exit({error,{asn1,{decode_enumerated,V1@V3}}})
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11}
end,
<<V1@V12:V1@V6/unit:8,V1@Buf13/bitstring>> = V1@Buf7,
{V1@V12,V1@Buf13}
end,
V1@Int14 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int14,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_SegmentAttributeXY(Val) ->
if Val =:= reserved ->
<<0:1,0:6>>;
Val =:= doNotBlock ->
<<0:1,1:6>>;
Val =:= whiteLine ->
<<0:1,2:6>>;
Val =:= mergingLaneLeft ->
<<0:1,3:6>>;
Val =:= mergingLaneRight ->
<<0:1,4:6>>;
Val =:= curbOnLeft ->
<<0:1,5:6>>;
Val =:= curbOnRight ->
<<0:1,6:6>>;
Val =:= loadingzoneOnLeft ->
<<0:1,7:6>>;
Val =:= loadingzoneOnRight ->
<<0:1,8:6>>;
Val =:= turnOutPointOnLeft ->
<<0:1,9:6>>;
Val =:= turnOutPointOnRight ->
<<0:1,10:6>>;
Val =:= adjacentParkingOnLeft ->
<<0:1,11:6>>;
Val =:= adjacentParkingOnRight ->
<<0:1,12:6>>;
Val =:= adjacentBikeLaneOnLeft ->
<<0:1,13:6>>;
Val =:= adjacentBikeLaneOnRight ->
<<0:1,14:6>>;
Val =:= sharedBikeLane ->
<<0:1,15:6>>;
Val =:= bikeBoxInFront ->
<<0:1,16:6>>;
Val =:= transitStopOnLeft ->
<<0:1,17:6>>;
Val =:= transitStopOnRight ->
<<0:1,18:6>>;
Val =:= transitStopInLane ->
<<0:1,19:6>>;
Val =:= sharedWithTrackedVehicle ->
<<0:1,20:6>>;
Val =:= safeIsland ->
<<0:1,21:6>>;
Val =:= lowCurbsPresent ->
<<0:1,22:6>>;
Val =:= rumbleStripPresent ->
<<0:1,23:6>>;
Val =:= audibleSignalingPresent ->
<<0:1,24:6>>;
Val =:= adaptiveTimingPresent ->
<<0:1,25:6>>;
Val =:= rfSignalRequestPresent ->
<<0:1,26:6>>;
Val =:= partialCurbIntrusion ->
<<0:1,27:6>>;
Val =:= taperToLeft ->
<<0:1,28:6>>;
Val =:= taperToRight ->
<<0:1,29:6>>;
Val =:= taperToCenterLine ->
<<0:1,30:6>>;
Val =:= parallelParking ->
<<0:1,31:6>>;
Val =:= headInParking ->
<<0:1,32:6>>;
Val =:= freeParking ->
<<0:1,33:6>>;
Val =:= timeRestrictionsOnParking ->
<<0:1,34:6>>;
Val =:= costToPark ->
<<0:1,35:6>>;
Val =:= midBlockCurbPresent ->
<<0:1,36:6>>;
Val =:= unEvenPavementPresent ->
<<0:1,37:6>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_SegmentAttributeXY(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> reserved;
1 -> doNotBlock;
2 -> whiteLine;
3 -> mergingLaneLeft;
4 -> mergingLaneRight;
5 -> curbOnLeft;
6 -> curbOnRight;
7 -> loadingzoneOnLeft;
8 -> loadingzoneOnRight;
9 -> turnOutPointOnLeft;
10 -> turnOutPointOnRight;
11 -> adjacentParkingOnLeft;
12 -> adjacentParkingOnRight;
13 -> adjacentBikeLaneOnLeft;
14 -> adjacentBikeLaneOnRight;
15 -> sharedBikeLane;
16 -> bikeBoxInFront;
17 -> transitStopOnLeft;
18 -> transitStopOnRight;
19 -> transitStopInLane;
20 -> sharedWithTrackedVehicle;
21 -> safeIsland;
22 -> lowCurbsPresent;
23 -> rumbleStripPresent;
24 -> audibleSignalingPresent;
25 -> adaptiveTimingPresent;
26 -> rfSignalRequestPresent;
27 -> partialCurbIntrusion;
28 -> taperToLeft;
29 -> taperToRight;
30 -> taperToCenterLine;
31 -> parallelParking;
32 -> headInParking;
33 -> freeParking;
34 -> timeRestrictionsOnParking;
35 -> costToPark;
36 -> midBlockCurbPresent;
37 -> unEvenPavementPresent;
_ -> exit({error,{asn1,{decode_enumerated,V1@V3}}})
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11}
end,
<<V1@V12:V1@V6/unit:8,V1@Buf13/bitstring>> = V1@Buf7,
{V1@V12,V1@Buf13}
end,
V1@Int14 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int14,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_SemiMajorAxisAccuracy(Val) ->
if Val bsr 8 =:= 0 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_SemiMajorAxisAccuracy(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_SemiMajorAxisOrientation(Val) ->
if Val bsr 16 =:= 0 ->
<<Val:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_SemiMajorAxisOrientation(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_SemiMinorAxisAccuracy(Val) ->
if Val bsr 8 =:= 0 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_SemiMinorAxisAccuracy(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_SignalGroupID(Val) ->
if Val bsr 8 =:= 0 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_SignalGroupID(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_SignalReqScheme(Val) ->
Enc1@len = byte_size(Val),
if Enc1@len =:= 1 ->
Val
end.


dec_SignalReqScheme(Bytes) ->
begin
<<V1@V0:1/binary-unit:8,V1@Buf1/bitstring>> = Bytes,
V1@Conv2 = binary:copy(V1@V0),
{V1@Conv2,V1@Buf1}
end.

enc_SignPrority(Val) ->
if Val bsr 3 =:= 0 ->
<<Val:3>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_SignPrority(Bytes) ->
begin
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_SirenInUse(Val) ->
if Val =:= unavailable ->
<<0:2>>;
Val =:= notInUse ->
<<1:2>>;
Val =:= inUse ->
<<2:2>>;
Val =:= reserved ->
<<3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_SirenInUse(Bytes) ->
begin
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> unavailable;
1 -> notInUse;
2 -> inUse;
3 -> reserved
end,
{V1@Int2,V1@Buf1}
end.

enc_SpeedAdvice(Val) ->
if 0 =< Val, Val < 501 ->
<<Val:9>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_SpeedAdvice(Bytes) ->
begin
<<V1@V0:9,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_SpeedConfidence(Val) ->
if Val =:= unavailable ->
<<0:3>>;
Val =:= prec100ms ->
<<1:3>>;
Val =:= prec10ms ->
<<2:3>>;
Val =:= prec5ms ->
<<3:3>>;
Val =:= prec1ms ->
<<4:3>>;
Val =:= 'prec0-1ms' ->
<<5:3>>;
Val =:= 'prec0-05ms' ->
<<6:3>>;
Val =:= 'prec0-01ms' ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_SpeedConfidence(Bytes) ->
begin
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> unavailable;
1 -> prec100ms;
2 -> prec10ms;
3 -> prec5ms;
4 -> prec1ms;
5 -> 'prec0-1ms';
6 -> 'prec0-05ms';
7 -> 'prec0-01ms'
end,
{V1@Int2,V1@Buf1}
end.

enc_SpeedLimitType(Val) ->
if Val =:= unknown ->
<<0:1,0:4>>;
Val =:= maxSpeedInSchoolZone ->
<<0:1,1:4>>;
Val =:= maxSpeedInSchoolZoneWhenChildrenArePresent ->
<<0:1,2:4>>;
Val =:= maxSpeedInConstructionZone ->
<<0:1,3:4>>;
Val =:= vehicleMinSpeed ->
<<0:1,4:4>>;
Val =:= vehicleMaxSpeed ->
<<0:1,5:4>>;
Val =:= vehicleNightMaxSpeed ->
<<0:1,6:4>>;
Val =:= truckMinSpeed ->
<<0:1,7:4>>;
Val =:= truckMaxSpeed ->
<<0:1,8:4>>;
Val =:= truckNightMaxSpeed ->
<<0:1,9:4>>;
Val =:= vehiclesWithTrailersMinSpeed ->
<<0:1,10:4>>;
Val =:= vehiclesWithTrailersMaxSpeed ->
<<0:1,11:4>>;
Val =:= vehiclesWithTrailersNightMaxSpeed ->
<<0:1,12:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_SpeedLimitType(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:4,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> unknown;
1 -> maxSpeedInSchoolZone;
2 -> maxSpeedInSchoolZoneWhenChildrenArePresent;
3 -> maxSpeedInConstructionZone;
4 -> vehicleMinSpeed;
5 -> vehicleMaxSpeed;
6 -> vehicleNightMaxSpeed;
7 -> truckMinSpeed;
8 -> truckMaxSpeed;
9 -> truckNightMaxSpeed;
10 -> vehiclesWithTrailersMinSpeed;
11 -> vehiclesWithTrailersMaxSpeed;
12 -> vehiclesWithTrailersNightMaxSpeed;
_ -> exit({error,{asn1,{decode_enumerated,V1@V3}}})
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11}
end,
<<V1@V12:V1@V6/unit:8,V1@Buf13/bitstring>> = V1@Buf7,
{V1@V12,V1@Buf13}
end,
V1@Int14 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int14,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_SpeedProfileMeasurement(Val) ->
if Val bsr 5 =:= 0 ->
<<Val:5>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_SpeedProfileMeasurement(Bytes) ->
begin
<<V1@V0:5,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_Speed(Val) ->
if Val bsr 13 =:= 0 ->
<<Val:13>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_Speed(Bytes) ->
begin
<<V1@V0:13,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_SSPindex(Val) ->
if Val bsr 5 =:= 0 ->
<<Val:5>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_SSPindex(Bytes) ->
begin
<<V1@V0:5,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_StabilityControlStatus(Val) ->
if Val =:= unavailable ->
<<0:2>>;
Val =:= off ->
<<1:2>>;
Val =:= on ->
<<2:2>>;
Val =:= engaged ->
<<3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_StabilityControlStatus(Bytes) ->
begin
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> unavailable;
1 -> off;
2 -> on;
3 -> engaged
end,
{V1@Int2,V1@Buf1}
end.

enc_StationID(Val) ->
if Val bsr 32 =:= 0 ->
<<Val:32>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_StationID(Bytes) ->
begin
<<V1@V0:32,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_SteeringWheelAngleConfidence(Val) ->
if Val =:= unavailable ->
<<0:2>>;
Val =:= prec2deg ->
<<1:2>>;
Val =:= prec1deg ->
<<2:2>>;
Val =:= 'prec0-02deg' ->
<<3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_SteeringWheelAngleConfidence(Bytes) ->
begin
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> unavailable;
1 -> prec2deg;
2 -> prec1deg;
3 -> 'prec0-02deg'
end,
{V1@Int2,V1@Buf1}
end.

enc_SteeringWheelAngleRateOfChange(Val) ->
Val@sub = Val - -127,
if 0 =< Val@sub, Val@sub < 255 ->
[Val@sub];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_SteeringWheelAngleRateOfChange(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -127,
{V1@Add2,V1@Buf1}
end.

enc_SteeringWheelAngle(Val) ->
Val@sub = Val - -126,
if 0 =< Val@sub, Val@sub < 254 ->
[Val@sub];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_SteeringWheelAngle(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -126,
{V1@Add2,V1@Buf1}
end.

enc_SunSensor(Val) ->
if 0 =< Val, Val < 1001 ->
<<Val:10>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_SunSensor(Bytes) ->
begin
<<V1@V0:10,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_TemporaryID(Val) ->
Enc1@len = byte_size(Val),
if Enc1@len =:= 4 ->
Val
end.


dec_TemporaryID(Bytes) ->
begin
<<V1@V0:4/binary-unit:8,V1@Buf1/bitstring>> = Bytes,
V1@Conv2 = binary:copy(V1@V0),
{V1@Conv2,V1@Buf1}
end.

enc_TermDistance(Val) ->
Val@sub = Val - 1,
if 0 =< Val@sub, Val@sub < 30000 ->
<<Val@sub:15>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_TermDistance(Bytes) ->
begin
<<V1@V0:15,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
{V1@Add2,V1@Buf1}
end.

enc_TermTime(Val) ->
Val@sub = Val - 1,
if 0 =< Val@sub, Val@sub < 1800 ->
<<Val@sub:11>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_TermTime(Bytes) ->
begin
<<V1@V0:11,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
{V1@Add2,V1@Buf1}
end.

enc_ThrottleConfidence(Val) ->
if Val =:= unavailable ->
<<0:2>>;
Val =:= prec10percent ->
<<1:2>>;
Val =:= prec1percent ->
<<2:2>>;
Val =:= 'prec0-5percent' ->
<<3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_ThrottleConfidence(Bytes) ->
begin
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> unavailable;
1 -> prec10percent;
2 -> prec1percent;
3 -> 'prec0-5percent'
end,
{V1@Int2,V1@Buf1}
end.

enc_ThrottlePosition(Val) ->
if 0 =< Val, Val < 201 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_ThrottlePosition(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_TimeConfidence(Val) ->
if Val =:= unavailable ->
<<0:6>>;
Val =:= 'time-100-000' ->
<<1:6>>;
Val =:= 'time-050-000' ->
<<2:6>>;
Val =:= 'time-020-000' ->
<<3:6>>;
Val =:= 'time-010-000' ->
<<4:6>>;
Val =:= 'time-002-000' ->
<<5:6>>;
Val =:= 'time-001-000' ->
<<6:6>>;
Val =:= 'time-000-500' ->
<<7:6>>;
Val =:= 'time-000-200' ->
<<8:6>>;
Val =:= 'time-000-100' ->
<<9:6>>;
Val =:= 'time-000-050' ->
<<10:6>>;
Val =:= 'time-000-020' ->
<<11:6>>;
Val =:= 'time-000-010' ->
<<12:6>>;
Val =:= 'time-000-005' ->
<<13:6>>;
Val =:= 'time-000-002' ->
<<14:6>>;
Val =:= 'time-000-001' ->
<<15:6>>;
Val =:= 'time-000-000-5' ->
<<16:6>>;
Val =:= 'time-000-000-2' ->
<<17:6>>;
Val =:= 'time-000-000-1' ->
<<18:6>>;
Val =:= 'time-000-000-05' ->
<<19:6>>;
Val =:= 'time-000-000-02' ->
<<20:6>>;
Val =:= 'time-000-000-01' ->
<<21:6>>;
Val =:= 'time-000-000-005' ->
<<22:6>>;
Val =:= 'time-000-000-002' ->
<<23:6>>;
Val =:= 'time-000-000-001' ->
<<24:6>>;
Val =:= 'time-000-000-000-5' ->
<<25:6>>;
Val =:= 'time-000-000-000-2' ->
<<26:6>>;
Val =:= 'time-000-000-000-1' ->
<<27:6>>;
Val =:= 'time-000-000-000-05' ->
<<28:6>>;
Val =:= 'time-000-000-000-02' ->
<<29:6>>;
Val =:= 'time-000-000-000-01' ->
<<30:6>>;
Val =:= 'time-000-000-000-005' ->
<<31:6>>;
Val =:= 'time-000-000-000-002' ->
<<32:6>>;
Val =:= 'time-000-000-000-001' ->
<<33:6>>;
Val =:= 'time-000-000-000-000-5' ->
<<34:6>>;
Val =:= 'time-000-000-000-000-2' ->
<<35:6>>;
Val =:= 'time-000-000-000-000-1' ->
<<36:6>>;
Val =:= 'time-000-000-000-000-05' ->
<<37:6>>;
Val =:= 'time-000-000-000-000-02' ->
<<38:6>>;
Val =:= 'time-000-000-000-000-01' ->
<<39:6>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_TimeConfidence(Bytes) ->
begin
<<V1@V0:6,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> unavailable;
1 -> 'time-100-000';
2 -> 'time-050-000';
3 -> 'time-020-000';
4 -> 'time-010-000';
5 -> 'time-002-000';
6 -> 'time-001-000';
7 -> 'time-000-500';
8 -> 'time-000-200';
9 -> 'time-000-100';
10 -> 'time-000-050';
11 -> 'time-000-020';
12 -> 'time-000-010';
13 -> 'time-000-005';
14 -> 'time-000-002';
15 -> 'time-000-001';
16 -> 'time-000-000-5';
17 -> 'time-000-000-2';
18 -> 'time-000-000-1';
19 -> 'time-000-000-05';
20 -> 'time-000-000-02';
21 -> 'time-000-000-01';
22 -> 'time-000-000-005';
23 -> 'time-000-000-002';
24 -> 'time-000-000-001';
25 -> 'time-000-000-000-5';
26 -> 'time-000-000-000-2';
27 -> 'time-000-000-000-1';
28 -> 'time-000-000-000-05';
29 -> 'time-000-000-000-02';
30 -> 'time-000-000-000-01';
31 -> 'time-000-000-000-005';
32 -> 'time-000-000-000-002';
33 -> 'time-000-000-000-001';
34 -> 'time-000-000-000-000-5';
35 -> 'time-000-000-000-000-2';
36 -> 'time-000-000-000-000-1';
37 -> 'time-000-000-000-000-05';
38 -> 'time-000-000-000-000-02';
39 -> 'time-000-000-000-000-01';
_ -> exit({error,{asn1,{decode_enumerated,V1@V0}}})
end,
{V1@Int2,V1@Buf1}
end.

enc_TimeIntervalConfidence(Val) ->
if Val bsr 4 =:= 0 ->
<<Val:4>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_TimeIntervalConfidence(Bytes) ->
begin
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_TimeMark(Val) ->
if 0 =< Val, Val < 36002 ->
<<Val:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_TimeMark(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_TimeOffset(Val) ->
Val@sub = Val - 1,
if 0 =< Val@sub, Val@sub < 65535 ->
<<Val@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_TimeOffset(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
{V1@Add2,V1@Buf1}
end.

enc_TractionControlStatus(Val) ->
if Val =:= unavailable ->
<<0:2>>;
Val =:= off ->
<<1:2>>;
Val =:= on ->
<<2:2>>;
Val =:= engaged ->
<<3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_TractionControlStatus(Bytes) ->
begin
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> unavailable;
1 -> off;
2 -> on;
3 -> engaged
end,
{V1@Int2,V1@Buf1}
end.

enc_TrailerMass(Val) ->
if Val bsr 8 =:= 0 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_TrailerMass(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_TransitStatus(Val) ->
Enc1@bs = try bit_string_name2pos_133(Val) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 6)
catch throw:invalid ->
adjust_trailing_zeroes(Val, 6)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 6 ->
Enc1@bs
end.


dec_TransitStatus(Bytes) ->
begin
<<V1@V0:6/binary-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V2,V1@Buf3}  = {decode_named_bit_string(V1@V0, [{none,0},{anADAuse,1},{aBikeLoad,2},{doorOpen,3},{occM,4},{occL,5}]),V1@Buf1},
{V1@V2,V1@Buf3}
end.

enc_TransitVehicleOccupancy(Val) ->
if Val =:= occupancyUnknown ->
<<0:3>>;
Val =:= occupancyEmpty ->
<<1:3>>;
Val =:= occupancyVeryLow ->
<<2:3>>;
Val =:= occupancyLow ->
<<3:3>>;
Val =:= occupancyMed ->
<<4:3>>;
Val =:= occupancyHigh ->
<<5:3>>;
Val =:= occupancyNearlyFull ->
<<6:3>>;
Val =:= occupancyFull ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_TransitVehicleOccupancy(Bytes) ->
begin
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> occupancyUnknown;
1 -> occupancyEmpty;
2 -> occupancyVeryLow;
3 -> occupancyLow;
4 -> occupancyMed;
5 -> occupancyHigh;
6 -> occupancyNearlyFull;
7 -> occupancyFull
end,
{V1@Int2,V1@Buf1}
end.

enc_TransitVehicleStatus(Val) ->
Enc1@bs = try bit_string_name2pos_103(Val) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 8)
catch throw:invalid ->
adjust_trailing_zeroes(Val, 8)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 8 ->
Enc1@bs
end.


dec_TransitVehicleStatus(Bytes) ->
begin
<<V1@V0:8/binary-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V2,V1@Buf3}  = {decode_named_bit_string(V1@V0, [{loading,0},{anADAuse,1},{aBikeLoad,2},{doorOpen,3},{charging,4},{atStopLine,5}]),V1@Buf1},
{V1@V2,V1@Buf3}
end.

enc_TransmissionState(Val) ->
if Val =:= neutral ->
<<0:3>>;
Val =:= park ->
<<1:3>>;
Val =:= forwardGears ->
<<2:3>>;
Val =:= reverseGears ->
<<3:3>>;
Val =:= reserved1 ->
<<4:3>>;
Val =:= reserved2 ->
<<5:3>>;
Val =:= reserved3 ->
<<6:3>>;
Val =:= unavailable ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_TransmissionState(Bytes) ->
begin
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> neutral;
1 -> park;
2 -> forwardGears;
3 -> reverseGears;
4 -> reserved1;
5 -> reserved2;
6 -> reserved3;
7 -> unavailable
end,
{V1@Int2,V1@Buf1}
end.

enc_TravelerInfoType(Val) ->
if Val =:= unknown ->
<<0:1,0:2>>;
Val =:= advisory ->
<<0:1,1:2>>;
Val =:= roadSignage ->
<<0:1,2:2>>;
Val =:= commercialSignage ->
<<0:1,3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_TravelerInfoType(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:2,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> unknown;
1 -> advisory;
2 -> roadSignage;
3 -> commercialSignage
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11}
end,
<<V1@V12:V1@V6/unit:8,V1@Buf13/bitstring>> = V1@Buf7,
{V1@V12,V1@Buf13}
end,
V1@Int14 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int14,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_UniqueMSGID(Val) ->
Enc1@len = byte_size(Val),
if Enc1@len =:= 9 ->
Val
end.


dec_UniqueMSGID(Bytes) ->
begin
<<V1@V0:9/binary-unit:8,V1@Buf1/bitstring>> = Bytes,
V1@Conv2 = binary:copy(V1@V0),
{V1@Conv2,V1@Buf1}
end.

'enc_URL-Base'(Val) ->
Enc1@len = length(Val),
Enc1@bin = encode_chars(Val, 7),
Enc1@len@sub = Enc1@len - 1,
if 0 =< Enc1@len@sub, Enc1@len@sub < 45 ->
[<<Enc1@len@sub:6>>|Enc1@bin]
end.


'dec_URL-Base'(Bytes) ->
begin
<<V1@V0:6,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
<<V1@V3:V1@Add2/binary-unit:7,V1@Buf4/bitstring>> = V1@Buf1,
{V1@V5,V1@Buf6}  = {decode_chars(V1@V3, 7),V1@Buf4},
{V1@V5,V1@Buf6}
end.

'enc_URL-Link'(Val) ->
Enc1@len = length(Val),
Enc1@bin = encode_chars(Val, 7),
Enc1@len@sub = Enc1@len - 1,
if 0 =< Enc1@len@sub, Enc1@len@sub < 255 ->
[Enc1@len@sub|Enc1@bin]
end.


'dec_URL-Link'(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
<<V1@V3:V1@Add2/binary-unit:7,V1@Buf4/bitstring>> = V1@Buf1,
{V1@V5,V1@Buf6}  = {decode_chars(V1@V3, 7),V1@Buf4},
{V1@V5,V1@Buf6}
end.

'enc_URL-Short'(Val) ->
Enc1@len = length(Val),
Enc1@bin = encode_chars(Val, 7),
Enc1@len@sub = Enc1@len - 1,
if 0 =< Enc1@len@sub, Enc1@len@sub < 15 ->
[<<Enc1@len@sub:4>>|Enc1@bin]
end.


'dec_URL-Short'(Bytes) ->
begin
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
<<V1@V3:V1@Add2/binary-unit:7,V1@Buf4/bitstring>> = V1@Buf1,
{V1@V5,V1@Buf6}  = {decode_chars(V1@V3, 7),V1@Buf4},
{V1@V5,V1@Buf6}
end.

enc_UserSizeAndBehaviour(Val) ->
Enc1@bs = try bit_string_name2pos_21(Val) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 5)
catch throw:invalid ->
adjust_trailing_zeroes(Val, 5)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 5 ->
[<<0:1>>|Enc1@bs];
Enc1@bits < 128 ->
[<<1:1,Enc1@bits:8>>|Enc1@bs];
Enc1@bits < 16384 ->
[<<1:1,2:2,Enc1@bits:14>>|Enc1@bs];
true ->
[<<1:1>>|encode_fragmented(Enc1@bs, 1)]
end.


dec_UserSizeAndBehaviour(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:5/binary-unit:1,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@V8:V1@V6/binary-unit:1,V1@Buf9/bitstring>> ->
{V1@V8,V1@Buf9};
<<1:1,0:1,V1@V7:14,V1@V9:V1@V7/binary-unit:1,V1@Buf10/bitstring>> ->
{V1@V9,V1@Buf10};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> ->
{V1@V9,V1@Buf10}  = decode_fragmented(V1@V7, V1@Buf8, 1),
{V1@V9,V1@Buf10}
end,
{V1@V3,V1@Buf4}
end,
{V1@V11,V1@Buf12}  = {decode_named_bit_string(V1@V0, [{unavailable,0},{smallStature,1},{largeStature,2},{erraticMoving,3},{slowMoving,4}]),V1@Buf1},
{V1@V11,V1@Buf12}
end.

enc_VehicleEventFlags(Val) ->
Enc1@bs = try bit_string_name2pos_11(Val) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 13)
catch throw:invalid ->
adjust_trailing_zeroes(Val, 13)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 13 ->
[<<0:1>>|Enc1@bs];
Enc1@bits < 128 ->
[<<1:1,Enc1@bits:8>>|Enc1@bs];
Enc1@bits < 16384 ->
[<<1:1,2:2,Enc1@bits:14>>|Enc1@bs];
true ->
[<<1:1>>|encode_fragmented(Enc1@bs, 1)]
end.


dec_VehicleEventFlags(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:13/binary-unit:1,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@V8:V1@V6/binary-unit:1,V1@Buf9/bitstring>> ->
{V1@V8,V1@Buf9};
<<1:1,0:1,V1@V7:14,V1@V9:V1@V7/binary-unit:1,V1@Buf10/bitstring>> ->
{V1@V9,V1@Buf10};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> ->
{V1@V9,V1@Buf10}  = decode_fragmented(V1@V7, V1@Buf8, 1),
{V1@V9,V1@Buf10}
end,
{V1@V3,V1@Buf4}
end,
{V1@V11,V1@Buf12}  = {decode_named_bit_string(V1@V0, [{eventHazardLights,0},{eventStopLineViolation,1},{eventABSactivated,2},{eventTractionControlLoss,3},{eventStabilityControlactivated,4},{eventHazardousMaterials,5},{eventReserved1,6},{eventHardBraking,7},{eventLightsChanged,8},{eventWipersChanged,9},{eventFlatTire,10},{eventDisabledVehicle,11},{eventAirBagDeployment,12}]),V1@Buf1},
{V1@V11,V1@Buf12}
end.

enc_VehicleHeight(Val) ->
if Val bsr 7 =:= 0 ->
<<Val:7>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_VehicleHeight(Bytes) ->
begin
<<V1@V0:7,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_VehicleLength(Val) ->
if Val bsr 12 =:= 0 ->
<<Val:12>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_VehicleLength(Bytes) ->
begin
<<V1@V0:12,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_VehicleMass(Val) ->
if Val bsr 8 =:= 0 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_VehicleMass(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_VehicleStatusDeviceTypeTag(Val) ->
if Val =:= unknown ->
<<0:1,0:5>>;
Val =:= lights ->
<<0:1,1:5>>;
Val =:= wipers ->
<<0:1,2:5>>;
Val =:= brakes ->
<<0:1,3:5>>;
Val =:= stab ->
<<0:1,4:5>>;
Val =:= trac ->
<<0:1,5:5>>;
Val =:= abs ->
<<0:1,6:5>>;
Val =:= sunS ->
<<0:1,7:5>>;
Val =:= rainS ->
<<0:1,8:5>>;
Val =:= airTemp ->
<<0:1,9:5>>;
Val =:= steering ->
<<0:1,10:5>>;
Val =:= vertAccelThres ->
<<0:1,11:5>>;
Val =:= vertAccel ->
<<0:1,12:5>>;
Val =:= hozAccelLong ->
<<0:1,13:5>>;
Val =:= hozAccelLat ->
<<0:1,14:5>>;
Val =:= hozAccelCon ->
<<0:1,15:5>>;
Val =:= accel4way ->
<<0:1,16:5>>;
Val =:= confidenceSet ->
<<0:1,17:5>>;
Val =:= obDist ->
<<0:1,18:5>>;
Val =:= obDirect ->
<<0:1,19:5>>;
Val =:= yaw ->
<<0:1,20:5>>;
Val =:= yawRateCon ->
<<0:1,21:5>>;
Val =:= dateTime ->
<<0:1,22:5>>;
Val =:= fullPos ->
<<0:1,23:5>>;
Val =:= position2D ->
<<0:1,24:5>>;
Val =:= position3D ->
<<0:1,25:5>>;
Val =:= vehicle ->
<<0:1,26:5>>;
Val =:= speedHeadC ->
<<0:1,27:5>>;
Val =:= speedC ->
<<0:1,28:5>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_VehicleStatusDeviceTypeTag(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:5,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> unknown;
1 -> lights;
2 -> wipers;
3 -> brakes;
4 -> stab;
5 -> trac;
6 -> abs;
7 -> sunS;
8 -> rainS;
9 -> airTemp;
10 -> steering;
11 -> vertAccelThres;
12 -> vertAccel;
13 -> hozAccelLong;
14 -> hozAccelLat;
15 -> hozAccelCon;
16 -> accel4way;
17 -> confidenceSet;
18 -> obDist;
19 -> obDirect;
20 -> yaw;
21 -> yawRateCon;
22 -> dateTime;
23 -> fullPos;
24 -> position2D;
25 -> position3D;
26 -> vehicle;
27 -> speedHeadC;
28 -> speedC;
_ -> exit({error,{asn1,{decode_enumerated,V1@V3}}})
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11}
end,
<<V1@V12:V1@V6/unit:8,V1@Buf13/bitstring>> = V1@Buf7,
{V1@V12,V1@Buf13}
end,
V1@Int14 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int14,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_VehicleType(Val) ->
if Val =:= none ->
<<0:1,0:4>>;
Val =:= unknown ->
<<0:1,1:4>>;
Val =:= special ->
<<0:1,2:4>>;
Val =:= moto ->
<<0:1,3:4>>;
Val =:= car ->
<<0:1,4:4>>;
Val =:= carOther ->
<<0:1,5:4>>;
Val =:= bus ->
<<0:1,6:4>>;
Val =:= axleCnt2 ->
<<0:1,7:4>>;
Val =:= axleCnt3 ->
<<0:1,8:4>>;
Val =:= axleCnt4 ->
<<0:1,9:4>>;
Val =:= axleCnt4Trailer ->
<<0:1,10:4>>;
Val =:= axleCnt5Trailer ->
<<0:1,11:4>>;
Val =:= axleCnt6Trailer ->
<<0:1,12:4>>;
Val =:= axleCnt5MultiTrailer ->
<<0:1,13:4>>;
Val =:= axleCnt6MultiTrailer ->
<<0:1,14:4>>;
Val =:= axleCnt7MultiTrailer ->
<<0:1,15:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_VehicleType(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:4,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> none;
1 -> unknown;
2 -> special;
3 -> moto;
4 -> car;
5 -> carOther;
6 -> bus;
7 -> axleCnt2;
8 -> axleCnt3;
9 -> axleCnt4;
10 -> axleCnt4Trailer;
11 -> axleCnt5Trailer;
12 -> axleCnt6Trailer;
13 -> axleCnt5MultiTrailer;
14 -> axleCnt6MultiTrailer;
15 -> axleCnt7MultiTrailer
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11}
end,
<<V1@V12:V1@V6/unit:8,V1@Buf13/bitstring>> = V1@Buf7,
{V1@V12,V1@Buf13}
end,
V1@Int14 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int14,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_VehicleWidth(Val) ->
if Val bsr 10 =:= 0 ->
<<Val:10>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_VehicleWidth(Bytes) ->
begin
<<V1@V0:10,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_Velocity(Val) ->
if Val bsr 13 =:= 0 ->
<<Val:13>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_Velocity(Bytes) ->
begin
<<V1@V0:13,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_VerticalAccelerationThreshold(Val) ->
Enc1@bs = try bit_string_name2pos_92(Val) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 5)
catch throw:invalid ->
adjust_trailing_zeroes(Val, 5)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 5 ->
Enc1@bs
end.


dec_VerticalAccelerationThreshold(Bytes) ->
begin
<<V1@V0:5/binary-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V2,V1@Buf3}  = {decode_named_bit_string(V1@V0, [{notEquipped,0},{leftFront,1},{leftRear,2},{rightFront,3},{rightRear,4}]),V1@Buf1},
{V1@V2,V1@Buf3}
end.

enc_VerticalAcceleration(Val) ->
Val@sub = Val - -127,
if 0 =< Val@sub, Val@sub < 255 ->
[Val@sub];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_VerticalAcceleration(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -127,
{V1@Add2,V1@Buf1}
end.

'enc_VertOffset-B07'(Val) ->
Val@sub = Val - -64,
if Val@sub bsr 7 =:= 0 ->
<<Val@sub:7>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


'dec_VertOffset-B07'(Bytes) ->
begin
<<V1@V0:7,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -64,
{V1@Add2,V1@Buf1}
end.

'enc_VertOffset-B08'(Val) ->
Val@sub = Val - -128,
if Val@sub bsr 8 =:= 0 ->
[Val@sub];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


'dec_VertOffset-B08'(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -128,
{V1@Add2,V1@Buf1}
end.

'enc_VertOffset-B09'(Val) ->
Val@sub = Val - -256,
if Val@sub bsr 9 =:= 0 ->
<<Val@sub:9>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


'dec_VertOffset-B09'(Bytes) ->
begin
<<V1@V0:9,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -256,
{V1@Add2,V1@Buf1}
end.

'enc_VertOffset-B10'(Val) ->
Val@sub = Val - -512,
if Val@sub bsr 10 =:= 0 ->
<<Val@sub:10>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


'dec_VertOffset-B10'(Bytes) ->
begin
<<V1@V0:10,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -512,
{V1@Add2,V1@Buf1}
end.

'enc_VertOffset-B11'(Val) ->
Val@sub = Val - -1024,
if Val@sub bsr 11 =:= 0 ->
<<Val@sub:11>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


'dec_VertOffset-B11'(Bytes) ->
begin
<<V1@V0:11,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -1024,
{V1@Add2,V1@Buf1}
end.

'enc_VertOffset-B12'(Val) ->
Val@sub = Val - -2048,
if Val@sub bsr 12 =:= 0 ->
<<Val@sub:12>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


'dec_VertOffset-B12'(Bytes) ->
begin
<<V1@V0:12,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -2048,
{V1@Add2,V1@Buf1}
end.

enc_VINstring(Val) ->
Enc1@len = byte_size(Val),
Enc1@len@sub = Enc1@len - 1,
if 0 =< Enc1@len@sub, Enc1@len@sub < 17 ->
[<<Enc1@len@sub:5>>|Val]
end.


dec_VINstring(Bytes) ->
begin
<<V1@V0:5,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
<<V1@V3:V1@Add2/binary-unit:8,V1@Buf4/bitstring>> = V1@Buf1,
V1@Conv5 = binary:copy(V1@V3),
{V1@Conv5,V1@Buf4}
end.

enc_WaitOnStopline(Val) ->
if Val =:= false ->
<<0:1>>;
Val =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Val}}})
end.


dec_WaitOnStopline(Bytes) ->
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> false;
1 -> true
end,
{V1@Int2,V1@Buf1}
end.

enc_WiperRate(Val) ->
if Val bsr 7 =:= 0 ->
<<Val:7>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_WiperRate(Bytes) ->
begin
<<V1@V0:7,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_WiperStatus(Val) ->
if Val =:= unavailable ->
<<0:1,0:3>>;
Val =:= off ->
<<0:1,1:3>>;
Val =:= intermittent ->
<<0:1,2:3>>;
Val =:= low ->
<<0:1,3:3>>;
Val =:= high ->
<<0:1,4:3>>;
Val =:= washerInUse ->
<<0:1,5:3>>;
Val =:= automaticPresent ->
<<0:1,6:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_WiperStatus(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:3,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> unavailable;
1 -> off;
2 -> intermittent;
3 -> low;
4 -> high;
5 -> washerInUse;
6 -> automaticPresent;
_ -> exit({error,{asn1,{decode_enumerated,V1@V3}}})
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11}
end,
<<V1@V12:V1@V6/unit:8,V1@Buf13/bitstring>> = V1@Buf7,
{V1@V12,V1@Buf13}
end,
V1@Int14 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int14,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_YawRateConfidence(Val) ->
if Val =:= unavailable ->
<<0:3>>;
Val =:= 'degSec-100-00' ->
<<1:3>>;
Val =:= 'degSec-010-00' ->
<<2:3>>;
Val =:= 'degSec-005-00' ->
<<3:3>>;
Val =:= 'degSec-001-00' ->
<<4:3>>;
Val =:= 'degSec-000-10' ->
<<5:3>>;
Val =:= 'degSec-000-05' ->
<<6:3>>;
Val =:= 'degSec-000-01' ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_YawRateConfidence(Bytes) ->
begin
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> unavailable;
1 -> 'degSec-100-00';
2 -> 'degSec-010-00';
3 -> 'degSec-005-00';
4 -> 'degSec-001-00';
5 -> 'degSec-000-10';
6 -> 'degSec-000-05';
7 -> 'degSec-000-01'
end,
{V1@Int2,V1@Buf1}
end.

enc_YawRate(Val) ->
Val@sub = Val - -32767,
if 0 =< Val@sub, Val@sub < 65535 ->
<<Val@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_YawRate(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -32767,
{V1@Add2,V1@Buf1}
end.

enc_ZoneLength(Val) ->
if 0 =< Val, Val < 10001 ->
<<Val:14>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_ZoneLength(Bytes) ->
begin
<<V1@V0:14,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_Zoom(Val) ->
if Val bsr 4 =:= 0 ->
<<Val:4>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_Zoom(Bytes) ->
begin
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

vehicleSafetyExt() ->
0.

specialVehicleExt() ->
1.

supplementalVehicleExt() ->
2.

unknownVehicleClass() ->
0.

specialVehicleClass() ->
1.

'passenger-Vehicle-TypeUnknown'() ->
10.

'passenger-Vehicle-TypeOther'() ->
11.

'lightTruck-Vehicle-TypeUnknown'() ->
20.

'lightTruck-Vehicle-TypeOther'() ->
21.

'truck-Vehicle-TypeUnknown'() ->
25.

'truck-Vehicle-TypeOther'() ->
26.

'truck-axleCnt2'() ->
27.

'truck-axleCnt3'() ->
28.

'truck-axleCnt4'() ->
29.

'truck-axleCnt4Trailer'() ->
30.

'truck-axleCnt5Trailer'() ->
31.

'truck-axleCnt6Trailer'() ->
32.

'truck-axleCnt5MultiTrailer'() ->
33.

'truck-axleCnt6MultiTrailer'() ->
34.

'truck-axleCnt7MultiTrailer'() ->
35.

'motorcycle-TypeUnknown'() ->
40.

'motorcycle-TypeOther'() ->
41.

'motorcycle-Cruiser-Standard'() ->
42.

'motorcycle-SportUnclad'() ->
43.

'motorcycle-SportTouring'() ->
44.

'motorcycle-SuperSport'() ->
45.

'motorcycle-Touring'() ->
46.

'motorcycle-Trike'() ->
47.

'motorcycle-wPassengers'() ->
48.

'transit-TypeUnknown'() ->
50.

'transit-TypeOther'() ->
51.

'transit-BRT'() ->
52.

'transit-ExpressBus'() ->
53.

'transit-LocalBus'() ->
54.

'transit-SchoolBus'() ->
55.

'transit-FixedGuideway'() ->
56.

'transit-Paratransit'() ->
57.

'transit-Paratransit-Ambulance'() ->
58.

'emergency-TypeUnknown'() ->
60.

'emergency-TypeOther'() ->
61.

'emergency-Fire-Light-Vehicle'() ->
62.

'emergency-Fire-Heavy-Vehicle'() ->
63.

'emergency-Fire-Paramedic-Vehicle'() ->
64.

'emergency-Fire-Ambulance-Vehicle'() ->
65.

'emergency-Police-Light-Vehicle'() ->
66.

'emergency-Police-Heavy-Vehicle'() ->
67.

'emergency-Other-Responder'() ->
68.

'emergency-Other-Ambulance'() ->
69.

'otherTraveler-TypeUnknown'() ->
80.

'otherTraveler-TypeOther'() ->
81.

'otherTraveler-Pedestrian'() ->
82.

'otherTraveler-Visually-Disabled'() ->
83.

'otherTraveler-Physically-Disabled'() ->
84.

'otherTraveler-Bicycle'() ->
85.

'otherTraveler-Vulnerable-Roadworker'() ->
86.

'infrastructure-TypeUnknown'() ->
90.

'infrastructure-Fixed'() ->
91.

'infrastructure-Movable'() ->
92.

'equipped-CargoTrailer'() ->
93.

'reservedMessageId-D'() ->
0.

'alaCarteMessage-D'() ->
1.

'basicSafetyMessage-D'() ->
2.

'basicSafetyMessageVerbose-D'() ->
3.

'commonSafetyRequest-D'() ->
4.

'emergencyVehicleAlert-D'() ->
5.

'intersectionCollision-D'() ->
6.

'mapData-D'() ->
7.

'nmeaCorrections-D'() ->
8.

'probeDataManagement-D'() ->
9.

'probeVehicleData-D'() ->
10.

'roadSideAlert-D'() ->
11.

'rtcmCorrections-D'() ->
12.

'signalPhaseAndTimingMessage-D'() ->
13.

'signalRequestMessage-D'() ->
14.

'signalStatusMessage-D'() ->
15.

'travelerInformation-D'() ->
16.

'uperFrame-D'() ->
17.

mapData() ->
18.

signalPhaseAndTimingMessage() ->
19.

basicSafetyMessage() ->
20.

commonSafetyRequest() ->
21.

emergencyVehicleAlert() ->
22.

intersectionCollision() ->
23.

nmeaCorrections() ->
24.

probeDataManagement() ->
25.

probeVehicleData() ->
26.

roadSideAlert() ->
27.

rtcmCorrections() ->
28.

signalRequestMessage() ->
29.

signalStatusMessage() ->
30.

travelerInformation() ->
31.

personalSafetyMessage() ->
32.

testMessage00() ->
240.

testMessage01() ->
241.

testMessage02() ->
242.

testMessage03() ->
243.

testMessage04() ->
244.

testMessage05() ->
245.

testMessage06() ->
246.

testMessage07() ->
247.

testMessage08() ->
248.

testMessage09() ->
249.

testMessage10() ->
250.

testMessage11() ->
251.

testMessage12() ->
252.

testMessage13() ->
253.

testMessage14() ->
254.

testMessage15() ->
255.

unknownFuel() ->
0.

gasoline() ->
1.

ethanol() ->
2.

diesel() ->
3.

electric() ->
4.

hybrid() ->
5.

hydrogen() ->
6.

natGasLiquid() ->
7.

natGasComp() ->
8.

propane() ->
9.

noRegion() ->
0.

addGrpA() ->
1.

addGrpB() ->
2.

addGrpC() ->
3.


%%%
%%% Run-time functions.
%%%

'dialyzer-suppressions'(Arg) ->
    complete(element(1, Arg)),
    ok.

bit_string_name2pos_100([peUnavailable | T]) ->
    [0 | bit_string_name2pos_100(T)];
bit_string_name2pos_100([peEmergencyResponse | T]) ->
    [1 | bit_string_name2pos_100(T)];
bit_string_name2pos_100([peEmergencyLightsActive | T]) ->
    [2 | bit_string_name2pos_100(T)];
bit_string_name2pos_100([peEmergencySoundActive | T]) ->
    [3 | bit_string_name2pos_100(T)];
bit_string_name2pos_100([peNonEmergencyLightsActive | T]) ->
    [4 | bit_string_name2pos_100(T)];
bit_string_name2pos_100([peNonEmergencySoundActive | T]) ->
    [5 | bit_string_name2pos_100(T)];
bit_string_name2pos_100([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_100(T)];
bit_string_name2pos_100([]) ->
    [];
bit_string_name2pos_100(_) ->
    throw(invalid).

bit_string_name2pos_103([loading | T]) ->
    [0 | bit_string_name2pos_103(T)];
bit_string_name2pos_103([anADAuse | T]) ->
    [1 | bit_string_name2pos_103(T)];
bit_string_name2pos_103([aBikeLoad | T]) ->
    [2 | bit_string_name2pos_103(T)];
bit_string_name2pos_103([doorOpen | T]) ->
    [3 | bit_string_name2pos_103(T)];
bit_string_name2pos_103([charging | T]) ->
    [4 | bit_string_name2pos_103(T)];
bit_string_name2pos_103([atStopLine | T]) ->
    [5 | bit_string_name2pos_103(T)];
bit_string_name2pos_103([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_103(T)];
bit_string_name2pos_103([]) ->
    [];
bit_string_name2pos_103(_) ->
    throw(invalid).

bit_string_name2pos_11([eventHazardLights | T]) ->
    [0 | bit_string_name2pos_11(T)];
bit_string_name2pos_11([eventStopLineViolation | T]) ->
    [1 | bit_string_name2pos_11(T)];
bit_string_name2pos_11([eventABSactivated | T]) ->
    [2 | bit_string_name2pos_11(T)];
bit_string_name2pos_11([eventTractionControlLoss | T]) ->
    [3 | bit_string_name2pos_11(T)];
bit_string_name2pos_11([eventStabilityControlactivated | T]) ->
    [4 | bit_string_name2pos_11(T)];
bit_string_name2pos_11([eventHazardousMaterials | T]) ->
    [5 | bit_string_name2pos_11(T)];
bit_string_name2pos_11([eventReserved1 | T]) ->
    [6 | bit_string_name2pos_11(T)];
bit_string_name2pos_11([eventHardBraking | T]) ->
    [7 | bit_string_name2pos_11(T)];
bit_string_name2pos_11([eventLightsChanged | T]) ->
    [8 | bit_string_name2pos_11(T)];
bit_string_name2pos_11([eventWipersChanged | T]) ->
    [9 | bit_string_name2pos_11(T)];
bit_string_name2pos_11([eventFlatTire | T]) ->
    [10 | bit_string_name2pos_11(T)];
bit_string_name2pos_11([eventDisabledVehicle | T]) ->
    [11 | bit_string_name2pos_11(T)];
bit_string_name2pos_11([eventAirBagDeployment | T]) ->
    [12 | bit_string_name2pos_11(T)];
bit_string_name2pos_11([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_11(T)];
bit_string_name2pos_11([]) ->
    [];
bit_string_name2pos_11(_) ->
    throw(invalid).

bit_string_name2pos_131([lowBeamHeadlightsOn | T]) ->
    [0 | bit_string_name2pos_131(T)];
bit_string_name2pos_131([highBeamHeadlightsOn | T]) ->
    [1 | bit_string_name2pos_131(T)];
bit_string_name2pos_131([leftTurnSignalOn | T]) ->
    [2 | bit_string_name2pos_131(T)];
bit_string_name2pos_131([rightTurnSignalOn | T]) ->
    [3 | bit_string_name2pos_131(T)];
bit_string_name2pos_131([hazardSignalOn | T]) ->
    [4 | bit_string_name2pos_131(T)];
bit_string_name2pos_131([automaticLightControlOn | T]) ->
    [5 | bit_string_name2pos_131(T)];
bit_string_name2pos_131([daytimeRunningLightsOn | T]) ->
    [6 | bit_string_name2pos_131(T)];
bit_string_name2pos_131([fogLightOn | T]) ->
    [7 | bit_string_name2pos_131(T)];
bit_string_name2pos_131([parkingLightsOn | T]) ->
    [8 | bit_string_name2pos_131(T)];
bit_string_name2pos_131([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_131(T)];
bit_string_name2pos_131([]) ->
    [];
bit_string_name2pos_131(_) ->
    throw(invalid).

bit_string_name2pos_133([none | T]) ->
    [0 | bit_string_name2pos_133(T)];
bit_string_name2pos_133([anADAuse | T]) ->
    [1 | bit_string_name2pos_133(T)];
bit_string_name2pos_133([aBikeLoad | T]) ->
    [2 | bit_string_name2pos_133(T)];
bit_string_name2pos_133([doorOpen | T]) ->
    [3 | bit_string_name2pos_133(T)];
bit_string_name2pos_133([occM | T]) ->
    [4 | bit_string_name2pos_133(T)];
bit_string_name2pos_133([occL | T]) ->
    [5 | bit_string_name2pos_133(T)];
bit_string_name2pos_133([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_133(T)];
bit_string_name2pos_133([]) ->
    [];
bit_string_name2pos_133(_) ->
    throw(invalid).

bit_string_name2pos_17([unavailable | T]) ->
    [0 | bit_string_name2pos_17(T)];
bit_string_name2pos_17([other | T]) ->
    [1 | bit_string_name2pos_17(T)];
bit_string_name2pos_17([idle | T]) ->
    [2 | bit_string_name2pos_17(T)];
bit_string_name2pos_17([listeningToAudio | T]) ->
    [3 | bit_string_name2pos_17(T)];
bit_string_name2pos_17([typing | T]) ->
    [4 | bit_string_name2pos_17(T)];
bit_string_name2pos_17([calling | T]) ->
    [5 | bit_string_name2pos_17(T)];
bit_string_name2pos_17([playingGames | T]) ->
    [6 | bit_string_name2pos_17(T)];
bit_string_name2pos_17([reading | T]) ->
    [7 | bit_string_name2pos_17(T)];
bit_string_name2pos_17([viewing | T]) ->
    [8 | bit_string_name2pos_17(T)];
bit_string_name2pos_17([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_17(T)];
bit_string_name2pos_17([]) ->
    [];
bit_string_name2pos_17(_) ->
    throw(invalid).

bit_string_name2pos_18([unavailable | T]) ->
    [0 | bit_string_name2pos_18(T)];
bit_string_name2pos_18([workingOnRoad | T]) ->
    [1 | bit_string_name2pos_18(T)];
bit_string_name2pos_18([settingUpClosures | T]) ->
    [2 | bit_string_name2pos_18(T)];
bit_string_name2pos_18([respondingToEvents | T]) ->
    [3 | bit_string_name2pos_18(T)];
bit_string_name2pos_18([directingTraffic | T]) ->
    [4 | bit_string_name2pos_18(T)];
bit_string_name2pos_18([otherActivities | T]) ->
    [5 | bit_string_name2pos_18(T)];
bit_string_name2pos_18([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_18(T)];
bit_string_name2pos_18([]) ->
    [];
bit_string_name2pos_18(_) ->
    throw(invalid).

bit_string_name2pos_19([unavailable | T]) ->
    [0 | bit_string_name2pos_19(T)];
bit_string_name2pos_19([policeAndTrafficOfficers | T]) ->
    [1 | bit_string_name2pos_19(T)];
bit_string_name2pos_19([trafficControlPersons | T]) ->
    [2 | bit_string_name2pos_19(T)];
bit_string_name2pos_19([railroadCrossingGuards | T]) ->
    [3 | bit_string_name2pos_19(T)];
bit_string_name2pos_19([civilDefenseNationalGuardMilitaryPolice | T]) ->
    [4 | bit_string_name2pos_19(T)];
bit_string_name2pos_19([emergencyOrganizationPersonnel | T]) ->
    [5 | bit_string_name2pos_19(T)];
bit_string_name2pos_19([highwayServiceVehiclePersonnel | T]) ->
    [6 | bit_string_name2pos_19(T)];
bit_string_name2pos_19([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_19(T)];
bit_string_name2pos_19([]) ->
    [];
bit_string_name2pos_19(_) ->
    throw(invalid).

bit_string_name2pos_20([unavailable | T]) ->
    [0 | bit_string_name2pos_20(T)];
bit_string_name2pos_20([otherType | T]) ->
    [1 | bit_string_name2pos_20(T)];
bit_string_name2pos_20([vision | T]) ->
    [2 | bit_string_name2pos_20(T)];
bit_string_name2pos_20([hearing | T]) ->
    [3 | bit_string_name2pos_20(T)];
bit_string_name2pos_20([movement | T]) ->
    [4 | bit_string_name2pos_20(T)];
bit_string_name2pos_20([cognition | T]) ->
    [5 | bit_string_name2pos_20(T)];
bit_string_name2pos_20([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_20(T)];
bit_string_name2pos_20([]) ->
    [];
bit_string_name2pos_20(_) ->
    throw(invalid).

bit_string_name2pos_21([unavailable | T]) ->
    [0 | bit_string_name2pos_21(T)];
bit_string_name2pos_21([smallStature | T]) ->
    [1 | bit_string_name2pos_21(T)];
bit_string_name2pos_21([largeStature | T]) ->
    [2 | bit_string_name2pos_21(T)];
bit_string_name2pos_21([erraticMoving | T]) ->
    [3 | bit_string_name2pos_21(T)];
bit_string_name2pos_21([slowMoving | T]) ->
    [4 | bit_string_name2pos_21(T)];
bit_string_name2pos_21([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_21(T)];
bit_string_name2pos_21([]) ->
    [];
bit_string_name2pos_21(_) ->
    throw(invalid).

bit_string_name2pos_23(['from000-0to022-5degrees' | T]) ->
    [0 | bit_string_name2pos_23(T)];
bit_string_name2pos_23(['from022-5to045-0degrees' | T]) ->
    [1 | bit_string_name2pos_23(T)];
bit_string_name2pos_23(['from045-0to067-5degrees' | T]) ->
    [2 | bit_string_name2pos_23(T)];
bit_string_name2pos_23(['from067-5to090-0degrees' | T]) ->
    [3 | bit_string_name2pos_23(T)];
bit_string_name2pos_23(['from090-0to112-5degrees' | T]) ->
    [4 | bit_string_name2pos_23(T)];
bit_string_name2pos_23(['from112-5to135-0degrees' | T]) ->
    [5 | bit_string_name2pos_23(T)];
bit_string_name2pos_23(['from135-0to157-5degrees' | T]) ->
    [6 | bit_string_name2pos_23(T)];
bit_string_name2pos_23(['from157-5to180-0degrees' | T]) ->
    [7 | bit_string_name2pos_23(T)];
bit_string_name2pos_23(['from180-0to202-5degrees' | T]) ->
    [8 | bit_string_name2pos_23(T)];
bit_string_name2pos_23(['from202-5to225-0degrees' | T]) ->
    [9 | bit_string_name2pos_23(T)];
bit_string_name2pos_23(['from225-0to247-5degrees' | T]) ->
    [10 | bit_string_name2pos_23(T)];
bit_string_name2pos_23(['from247-5to270-0degrees' | T]) ->
    [11 | bit_string_name2pos_23(T)];
bit_string_name2pos_23(['from270-0to292-5degrees' | T]) ->
    [12 | bit_string_name2pos_23(T)];
bit_string_name2pos_23(['from292-5to315-0degrees' | T]) ->
    [13 | bit_string_name2pos_23(T)];
bit_string_name2pos_23(['from315-0to337-5degrees' | T]) ->
    [14 | bit_string_name2pos_23(T)];
bit_string_name2pos_23(['from337-5to360-0degrees' | T]) ->
    [15 | bit_string_name2pos_23(T)];
bit_string_name2pos_23([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_23(T)];
bit_string_name2pos_23([]) ->
    [];
bit_string_name2pos_23(_) ->
    throw(invalid).

bit_string_name2pos_36([unavailable | T]) ->
    [0 | bit_string_name2pos_36(T)];
bit_string_name2pos_36([leftFront | T]) ->
    [1 | bit_string_name2pos_36(T)];
bit_string_name2pos_36([leftRear | T]) ->
    [2 | bit_string_name2pos_36(T)];
bit_string_name2pos_36([rightFront | T]) ->
    [3 | bit_string_name2pos_36(T)];
bit_string_name2pos_36([rightRear | T]) ->
    [4 | bit_string_name2pos_36(T)];
bit_string_name2pos_36([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_36(T)];
bit_string_name2pos_36([]) ->
    [];
bit_string_name2pos_36(_) ->
    throw(invalid).

bit_string_name2pos_38([maneuverStraightAllowed | T]) ->
    [0 | bit_string_name2pos_38(T)];
bit_string_name2pos_38([maneuverLeftAllowed | T]) ->
    [1 | bit_string_name2pos_38(T)];
bit_string_name2pos_38([maneuverRightAllowed | T]) ->
    [2 | bit_string_name2pos_38(T)];
bit_string_name2pos_38([maneuverUTurnAllowed | T]) ->
    [3 | bit_string_name2pos_38(T)];
bit_string_name2pos_38([maneuverLeftTurnOnRedAllowed | T]) ->
    [4 | bit_string_name2pos_38(T)];
bit_string_name2pos_38([maneuverRightTurnOnRedAllowed | T]) ->
    [5 | bit_string_name2pos_38(T)];
bit_string_name2pos_38([maneuverLaneChangeAllowed | T]) ->
    [6 | bit_string_name2pos_38(T)];
bit_string_name2pos_38([maneuverNoStoppingAllowed | T]) ->
    [7 | bit_string_name2pos_38(T)];
bit_string_name2pos_38([yieldAllwaysRequired | T]) ->
    [8 | bit_string_name2pos_38(T)];
bit_string_name2pos_38([goWithHalt | T]) ->
    [9 | bit_string_name2pos_38(T)];
bit_string_name2pos_38([caution | T]) ->
    [10 | bit_string_name2pos_38(T)];
bit_string_name2pos_38([reserved1 | T]) ->
    [11 | bit_string_name2pos_38(T)];
bit_string_name2pos_38([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_38(T)];
bit_string_name2pos_38([]) ->
    [];
bit_string_name2pos_38(_) ->
    throw(invalid).

bit_string_name2pos_51([manualControlIsEnabled | T]) ->
    [0 | bit_string_name2pos_51(T)];
bit_string_name2pos_51([stopTimeIsActivated | T]) ->
    [1 | bit_string_name2pos_51(T)];
bit_string_name2pos_51([failureFlash | T]) ->
    [2 | bit_string_name2pos_51(T)];
bit_string_name2pos_51([preemptIsActive | T]) ->
    [3 | bit_string_name2pos_51(T)];
bit_string_name2pos_51([signalPriorityIsActive | T]) ->
    [4 | bit_string_name2pos_51(T)];
bit_string_name2pos_51([fixedTimeOperation | T]) ->
    [5 | bit_string_name2pos_51(T)];
bit_string_name2pos_51([trafficDependentOperation | T]) ->
    [6 | bit_string_name2pos_51(T)];
bit_string_name2pos_51([standbyOperation | T]) ->
    [7 | bit_string_name2pos_51(T)];
bit_string_name2pos_51([failureMode | T]) ->
    [8 | bit_string_name2pos_51(T)];
bit_string_name2pos_51([off | T]) ->
    [9 | bit_string_name2pos_51(T)];
bit_string_name2pos_51([recentMAPmessageUpdate | T]) ->
    [10 | bit_string_name2pos_51(T)];
bit_string_name2pos_51([recentChangeInMAPassignedLanesIDsUsed | T]) ->
    [11 | bit_string_name2pos_51(T)];
bit_string_name2pos_51([noValidMAPisAvailableAtThisTime | T]) ->
    [12 | bit_string_name2pos_51(T)];
bit_string_name2pos_51([noValidSPATisAvailableAtThisTime | T]) ->
    [13 | bit_string_name2pos_51(T)];
bit_string_name2pos_51([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_51(T)];
bit_string_name2pos_51([]) ->
    [];
bit_string_name2pos_51(_) ->
    throw(invalid).

bit_string_name2pos_62([ingressPath | T]) ->
    [0 | bit_string_name2pos_62(T)];
bit_string_name2pos_62([egressPath | T]) ->
    [1 | bit_string_name2pos_62(T)];
bit_string_name2pos_62([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_62(T)];
bit_string_name2pos_62([]) ->
    [];
bit_string_name2pos_62(_) ->
    throw(invalid).

bit_string_name2pos_63([overlappingLaneDescriptionProvided | T]) ->
    [0 | bit_string_name2pos_63(T)];
bit_string_name2pos_63([multipleLanesTreatedAsOneLane | T]) ->
    [1 | bit_string_name2pos_63(T)];
bit_string_name2pos_63([otherNonMotorizedTrafficTypes | T]) ->
    [2 | bit_string_name2pos_63(T)];
bit_string_name2pos_63([individualMotorizedVehicleTraffic | T]) ->
    [3 | bit_string_name2pos_63(T)];
bit_string_name2pos_63([busVehicleTraffic | T]) ->
    [4 | bit_string_name2pos_63(T)];
bit_string_name2pos_63([taxiVehicleTraffic | T]) ->
    [5 | bit_string_name2pos_63(T)];
bit_string_name2pos_63([pedestriansTraffic | T]) ->
    [6 | bit_string_name2pos_63(T)];
bit_string_name2pos_63([cyclistVehicleTraffic | T]) ->
    [7 | bit_string_name2pos_63(T)];
bit_string_name2pos_63([trackedVehicleTraffic | T]) ->
    [8 | bit_string_name2pos_63(T)];
bit_string_name2pos_63([pedestrianTraffic | T]) ->
    [9 | bit_string_name2pos_63(T)];
bit_string_name2pos_63([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_63(T)];
bit_string_name2pos_63([]) ->
    [];
bit_string_name2pos_63(_) ->
    throw(invalid).

bit_string_name2pos_69([isVehicleRevocableLane | T]) ->
    [0 | bit_string_name2pos_69(T)];
bit_string_name2pos_69([isVehicleFlyOverLane | T]) ->
    [1 | bit_string_name2pos_69(T)];
bit_string_name2pos_69([hovLaneUseOnly | T]) ->
    [2 | bit_string_name2pos_69(T)];
bit_string_name2pos_69([restrictedToBusUse | T]) ->
    [3 | bit_string_name2pos_69(T)];
bit_string_name2pos_69([restrictedToTaxiUse | T]) ->
    [4 | bit_string_name2pos_69(T)];
bit_string_name2pos_69([restrictedFromPublicUse | T]) ->
    [5 | bit_string_name2pos_69(T)];
bit_string_name2pos_69([hasIRbeaconCoverage | T]) ->
    [6 | bit_string_name2pos_69(T)];
bit_string_name2pos_69([permissionOnRequest | T]) ->
    [7 | bit_string_name2pos_69(T)];
bit_string_name2pos_69([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_69(T)];
bit_string_name2pos_69([]) ->
    [];
bit_string_name2pos_69(_) ->
    throw(invalid).

bit_string_name2pos_70([crosswalkRevocableLane | T]) ->
    [0 | bit_string_name2pos_70(T)];
bit_string_name2pos_70([bicyleUseAllowed | T]) ->
    [1 | bit_string_name2pos_70(T)];
bit_string_name2pos_70([isXwalkFlyOverLane | T]) ->
    [2 | bit_string_name2pos_70(T)];
bit_string_name2pos_70([fixedCycleTime | T]) ->
    [3 | bit_string_name2pos_70(T)];
bit_string_name2pos_70([biDirectionalCycleTimes | T]) ->
    [4 | bit_string_name2pos_70(T)];
bit_string_name2pos_70([hasPushToWalkButton | T]) ->
    [5 | bit_string_name2pos_70(T)];
bit_string_name2pos_70([audioSupport | T]) ->
    [6 | bit_string_name2pos_70(T)];
bit_string_name2pos_70([rfSignalRequestPresent | T]) ->
    [7 | bit_string_name2pos_70(T)];
bit_string_name2pos_70([unsignalizedSegmentsPresent | T]) ->
    [8 | bit_string_name2pos_70(T)];
bit_string_name2pos_70([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_70(T)];
bit_string_name2pos_70([]) ->
    [];
bit_string_name2pos_70(_) ->
    throw(invalid).

bit_string_name2pos_71([bikeRevocableLane | T]) ->
    [0 | bit_string_name2pos_71(T)];
bit_string_name2pos_71([pedestrianUseAllowed | T]) ->
    [1 | bit_string_name2pos_71(T)];
bit_string_name2pos_71([isBikeFlyOverLane | T]) ->
    [2 | bit_string_name2pos_71(T)];
bit_string_name2pos_71([fixedCycleTime | T]) ->
    [3 | bit_string_name2pos_71(T)];
bit_string_name2pos_71([biDirectionalCycleTimes | T]) ->
    [4 | bit_string_name2pos_71(T)];
bit_string_name2pos_71([isolatedByBarrier | T]) ->
    [5 | bit_string_name2pos_71(T)];
bit_string_name2pos_71([unsignalizedSegmentsPresent | T]) ->
    [6 | bit_string_name2pos_71(T)];
bit_string_name2pos_71([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_71(T)];
bit_string_name2pos_71([]) ->
    [];
bit_string_name2pos_71(_) ->
    throw(invalid).

bit_string_name2pos_72(['sidewalk-RevocableLane' | T]) ->
    [0 | bit_string_name2pos_72(T)];
bit_string_name2pos_72([bicyleUseAllowed | T]) ->
    [1 | bit_string_name2pos_72(T)];
bit_string_name2pos_72([isSidewalkFlyOverLane | T]) ->
    [2 | bit_string_name2pos_72(T)];
bit_string_name2pos_72([walkBikes | T]) ->
    [3 | bit_string_name2pos_72(T)];
bit_string_name2pos_72([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_72(T)];
bit_string_name2pos_72([]) ->
    [];
bit_string_name2pos_72(_) ->
    throw(invalid).

bit_string_name2pos_73(['median-RevocableLane' | T]) ->
    [0 | bit_string_name2pos_73(T)];
bit_string_name2pos_73([median | T]) ->
    [1 | bit_string_name2pos_73(T)];
bit_string_name2pos_73([whiteLineHashing | T]) ->
    [2 | bit_string_name2pos_73(T)];
bit_string_name2pos_73([stripedLines | T]) ->
    [3 | bit_string_name2pos_73(T)];
bit_string_name2pos_73([doubleStripedLines | T]) ->
    [4 | bit_string_name2pos_73(T)];
bit_string_name2pos_73([trafficCones | T]) ->
    [5 | bit_string_name2pos_73(T)];
bit_string_name2pos_73([constructionBarrier | T]) ->
    [6 | bit_string_name2pos_73(T)];
bit_string_name2pos_73([trafficChannels | T]) ->
    [7 | bit_string_name2pos_73(T)];
bit_string_name2pos_73([lowCurbs | T]) ->
    [8 | bit_string_name2pos_73(T)];
bit_string_name2pos_73([highCurbs | T]) ->
    [9 | bit_string_name2pos_73(T)];
bit_string_name2pos_73([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_73(T)];
bit_string_name2pos_73([]) ->
    [];
bit_string_name2pos_73(_) ->
    throw(invalid).

bit_string_name2pos_74([stripeToConnectingLanesRevocableLane | T]) ->
    [0 | bit_string_name2pos_74(T)];
bit_string_name2pos_74([stripeDrawOnLeft | T]) ->
    [1 | bit_string_name2pos_74(T)];
bit_string_name2pos_74([stripeDrawOnRight | T]) ->
    [2 | bit_string_name2pos_74(T)];
bit_string_name2pos_74([stripeToConnectingLanesLeft | T]) ->
    [3 | bit_string_name2pos_74(T)];
bit_string_name2pos_74([stripeToConnectingLanesRight | T]) ->
    [4 | bit_string_name2pos_74(T)];
bit_string_name2pos_74([stripeToConnectingLanesAhead | T]) ->
    [5 | bit_string_name2pos_74(T)];
bit_string_name2pos_74([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_74(T)];
bit_string_name2pos_74([]) ->
    [];
bit_string_name2pos_74(_) ->
    throw(invalid).

bit_string_name2pos_75(['spec-RevocableLane' | T]) ->
    [0 | bit_string_name2pos_75(T)];
bit_string_name2pos_75(['spec-commuterRailRoadTrack' | T]) ->
    [1 | bit_string_name2pos_75(T)];
bit_string_name2pos_75(['spec-lightRailRoadTrack' | T]) ->
    [2 | bit_string_name2pos_75(T)];
bit_string_name2pos_75(['spec-heavyRailRoadTrack' | T]) ->
    [3 | bit_string_name2pos_75(T)];
bit_string_name2pos_75(['spec-otherRailType' | T]) ->
    [4 | bit_string_name2pos_75(T)];
bit_string_name2pos_75([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_75(T)];
bit_string_name2pos_75([]) ->
    [];
bit_string_name2pos_75(_) ->
    throw(invalid).

bit_string_name2pos_76([parkingRevocableLane | T]) ->
    [0 | bit_string_name2pos_76(T)];
bit_string_name2pos_76([parallelParkingInUse | T]) ->
    [1 | bit_string_name2pos_76(T)];
bit_string_name2pos_76([headInParkingInUse | T]) ->
    [2 | bit_string_name2pos_76(T)];
bit_string_name2pos_76([doNotParkZone | T]) ->
    [3 | bit_string_name2pos_76(T)];
bit_string_name2pos_76([parkingForBusUse | T]) ->
    [4 | bit_string_name2pos_76(T)];
bit_string_name2pos_76([parkingForTaxiUse | T]) ->
    [5 | bit_string_name2pos_76(T)];
bit_string_name2pos_76([noPublicParkingUse | T]) ->
    [6 | bit_string_name2pos_76(T)];
bit_string_name2pos_76([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_76(T)];
bit_string_name2pos_76([]) ->
    [];
bit_string_name2pos_76(_) ->
    throw(invalid).

bit_string_name2pos_92([notEquipped | T]) ->
    [0 | bit_string_name2pos_92(T)];
bit_string_name2pos_92([leftFront | T]) ->
    [1 | bit_string_name2pos_92(T)];
bit_string_name2pos_92([leftRear | T]) ->
    [2 | bit_string_name2pos_92(T)];
bit_string_name2pos_92([rightFront | T]) ->
    [3 | bit_string_name2pos_92(T)];
bit_string_name2pos_92([rightRear | T]) ->
    [4 | bit_string_name2pos_92(T)];
bit_string_name2pos_92([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_92(T)];
bit_string_name2pos_92([]) ->
    [];
bit_string_name2pos_92(_) ->
    throw(invalid).

bit_string_name2pos_94([unavailable | T]) ->
    [0 | bit_string_name2pos_94(T)];
bit_string_name2pos_94([isHealthy | T]) ->
    [1 | bit_string_name2pos_94(T)];
bit_string_name2pos_94([isMonitored | T]) ->
    [2 | bit_string_name2pos_94(T)];
bit_string_name2pos_94([baseStationType | T]) ->
    [3 | bit_string_name2pos_94(T)];
bit_string_name2pos_94([aPDOPofUnder5 | T]) ->
    [4 | bit_string_name2pos_94(T)];
bit_string_name2pos_94([inViewOfUnder5 | T]) ->
    [5 | bit_string_name2pos_94(T)];
bit_string_name2pos_94([localCorrectionsPresent | T]) ->
    [6 | bit_string_name2pos_94(T)];
bit_string_name2pos_94([networkCorrectionsPresent | T]) ->
    [7 | bit_string_name2pos_94(T)];
bit_string_name2pos_94([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_94(T)];
bit_string_name2pos_94([]) ->
    [];
bit_string_name2pos_94(_) ->
    throw(invalid).

dec_components10(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components10(Num, Bytes, Acc) ->
{Term,Remain} = dec_EmergencyVehicleAlert_regional_RegionalExtension(Bytes),
dec_components10(Num-1, Remain, [Term|Acc]).

dec_components101(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components101(Num, Bytes, Acc) ->
{Term,Remain} = dec_RegionOffsets(Bytes),
dec_components101(Num-1, Remain, [Term|Acc]).

dec_components102(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components102(Num, Bytes, Acc) ->
{Term,Remain} = begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:5,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> reserved;
1 -> itemA;
2 -> itemB;
3 -> itemC;
4 -> itemD;
5 -> itemE;
6 -> itemF;
7 -> itemG;
8 -> itemI;
9 -> itemJ;
10 -> itemK;
11 -> itemL;
12 -> itemM;
13 -> itemN;
14 -> itemO;
15 -> itemP;
16 -> itemQ;
_ -> exit({error,{asn1,{decode_enumerated,V1@V3}}})
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11}
end,
<<V1@V12:V1@V6/unit:8,V1@Buf13/bitstring>> = V1@Buf7,
{V1@V12,V1@Buf13}
end,
V1@Int14 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int14,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end,
dec_components102(Num-1, Remain, [Term|Acc]).

dec_components104(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components104(Num, Bytes, Acc) ->
{Term,Remain} = dec_RequestorDescription_regional_RegionalExtension(Bytes),
dec_components104(Num-1, Remain, [Term|Acc]).

dec_components105(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components105(Num, Bytes, Acc) ->
{Term,Remain} = dec_RestrictionClassAssignment(Bytes),
dec_components105(Num-1, Remain, [Term|Acc]).

dec_components106(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components106(Num, Bytes, Acc) ->
{Term,Remain} = dec_RestrictionUserType(Bytes),
dec_components106(Num-1, Remain, [Term|Acc]).

dec_components108(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components108(Num, Bytes, Acc) ->
{Term,Remain} = dec_RestrictionUserType_regional_RegionalExtension(Bytes),
dec_components108(Num-1, Remain, [Term|Acc]).

dec_components110(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components110(Num, Bytes, Acc) ->
{Term,Remain} = dec_GenericLane(Bytes),
dec_components110(Num-1, Remain, [Term|Acc]).

dec_components111(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components111(Num, Bytes, Acc) ->
{Term,Remain} = dec_RoadSegment(Bytes),
dec_components111(Num-1, Remain, [Term|Acc]).

dec_components112(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components112(Num, Bytes, Acc) ->
{Term,Remain} = dec_RoadSegment_regional_RegionalExtension(Bytes),
dec_components112(Num-1, Remain, [Term|Acc]).

dec_components113(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components113(Num, Bytes, Acc) ->
{Term,Remain} = begin
<<V2@V0:10,V2@Buf1/bitstring>> = Bytes,
V2@Add2 = V2@V0 + 1,
<<V2@V3:V2@Add2/binary-unit:8,V2@Buf4/bitstring>> = V2@Buf1,
V2@Conv5 = binary:copy(V2@V3),
{V2@Conv5,V2@Buf4}
end,
dec_components113(Num-1, Remain, [dec_Binary_Id(Term)|Acc]).

dec_components114(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components114(Num, Bytes, Acc) ->
{Term,Remain} = begin
{V3@V0,V3@Buf1} = case Bytes of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Int5 = case V3@V3 of
0 -> reserved;
1 -> doNotBlock;
2 -> whiteLine;
3 -> mergingLaneLeft;
4 -> mergingLaneRight;
5 -> curbOnLeft;
6 -> curbOnRight;
7 -> loadingzoneOnLeft;
8 -> loadingzoneOnRight;
9 -> turnOutPointOnLeft;
10 -> turnOutPointOnRight;
11 -> adjacentParkingOnLeft;
12 -> adjacentParkingOnRight;
13 -> adjacentBikeLaneOnLeft;
14 -> adjacentBikeLaneOnRight;
15 -> sharedBikeLane;
16 -> bikeBoxInFront;
17 -> transitStopOnLeft;
18 -> transitStopOnRight;
19 -> transitStopInLane;
20 -> sharedWithTrackedVehicle;
21 -> safeIsland;
22 -> lowCurbsPresent;
23 -> rumbleStripPresent;
24 -> audibleSignalingPresent;
25 -> adaptiveTimingPresent;
26 -> rfSignalRequestPresent;
27 -> partialCurbIntrusion;
28 -> taperToLeft;
29 -> taperToRight;
30 -> taperToCenterLine;
31 -> parallelParking;
32 -> headInParking;
33 -> freeParking;
34 -> timeRestrictionsOnParking;
35 -> costToPark;
36 -> midBlockCurbPresent;
37 -> unEvenPavementPresent;
_ -> exit({error,{asn1,{decode_enumerated,V3@V3}}})
end,
{V3@Int5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:6,V3@Buf7/bitstring>> ->
{V3@V6,V3@Buf7};
<<1:1,V3@Buf5/bitstring>> ->
{V3@V6,V3@Buf7} = case V3@Buf5 of
<<0:1,V3@V9:7,V3@Buf10/bitstring>> when V3@V9 =/= 0 ->
{V3@V9,V3@Buf10};
<<1:1,0:1,V3@V10:14,V3@Buf11/bitstring>> when V3@V10 =/= 0 ->
{V3@V10,V3@Buf11}
end,
<<V3@V12:V3@V6/unit:8,V3@Buf13/bitstring>> = V3@Buf7,
{V3@V12,V3@Buf13}
end,
V3@Int14 = case V3@V3 of
_ -> {asn1_enum,V3@V3}
end,
{V3@Int14,V3@Buf4}
end,
{V3@V0,V3@Buf1}
end,
dec_components114(Num-1, Remain, [Term|Acc]).

dec_components115(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components115(Num, Bytes, Acc) ->
{Term,Remain} = begin
{V4@V0,V4@Buf1} = case Bytes of
<<0:1,V4@V3:6,V4@Buf4/bitstring>> ->
V4@Int5 = case V4@V3 of
0 -> reserved;
1 -> doNotBlock;
2 -> whiteLine;
3 -> mergingLaneLeft;
4 -> mergingLaneRight;
5 -> curbOnLeft;
6 -> curbOnRight;
7 -> loadingzoneOnLeft;
8 -> loadingzoneOnRight;
9 -> turnOutPointOnLeft;
10 -> turnOutPointOnRight;
11 -> adjacentParkingOnLeft;
12 -> adjacentParkingOnRight;
13 -> adjacentBikeLaneOnLeft;
14 -> adjacentBikeLaneOnRight;
15 -> sharedBikeLane;
16 -> bikeBoxInFront;
17 -> transitStopOnLeft;
18 -> transitStopOnRight;
19 -> transitStopInLane;
20 -> sharedWithTrackedVehicle;
21 -> safeIsland;
22 -> lowCurbsPresent;
23 -> rumbleStripPresent;
24 -> audibleSignalingPresent;
25 -> adaptiveTimingPresent;
26 -> rfSignalRequestPresent;
27 -> partialCurbIntrusion;
28 -> taperToLeft;
29 -> taperToRight;
30 -> taperToCenterLine;
31 -> parallelParking;
32 -> headInParking;
33 -> freeParking;
34 -> timeRestrictionsOnParking;
35 -> costToPark;
36 -> midBlockCurbPresent;
37 -> unEvenPavementPresent;
_ -> exit({error,{asn1,{decode_enumerated,V4@V3}}})
end,
{V4@Int5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:6,V4@Buf7/bitstring>> ->
{V4@V6,V4@Buf7};
<<1:1,V4@Buf5/bitstring>> ->
{V4@V6,V4@Buf7} = case V4@Buf5 of
<<0:1,V4@V9:7,V4@Buf10/bitstring>> when V4@V9 =/= 0 ->
{V4@V9,V4@Buf10};
<<1:1,0:1,V4@V10:14,V4@Buf11/bitstring>> when V4@V10 =/= 0 ->
{V4@V10,V4@Buf11}
end,
<<V4@V12:V4@V6/unit:8,V4@Buf13/bitstring>> = V4@Buf7,
{V4@V12,V4@Buf13}
end,
V4@Int14 = case V4@V3 of
_ -> {asn1_enum,V4@V3}
end,
{V4@Int14,V4@Buf4}
end,
{V4@V0,V4@Buf1}
end,
dec_components115(Num-1, Remain, [Term|Acc]).

dec_components116(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components116(Num, Bytes, Acc) ->
{Term,Remain} = dec_SignalRequestPackage(Bytes),
dec_components116(Num-1, Remain, [Term|Acc]).

dec_components117(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components117(Num, Bytes, Acc) ->
{Term,Remain} = dec_SignalRequestPackage_regional_RegionalExtension(Bytes),
dec_components117(Num-1, Remain, [Term|Acc]).

dec_components118(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components118(Num, Bytes, Acc) ->
{Term,Remain} = dec_SignalRequest_regional_RegionalExtension(Bytes),
dec_components118(Num-1, Remain, [Term|Acc]).

dec_components119(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components119(Num, Bytes, Acc) ->
{Term,Remain} = dec_SignalStatus(Bytes),
dec_components119(Num-1, Remain, [Term|Acc]).

dec_components12(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components12(Num, Bytes, Acc) ->
{Term,Remain} = dec_IntersectionCollision_regional_RegionalExtension(Bytes),
dec_components12(Num-1, Remain, [Term|Acc]).

dec_components120(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components120(Num, Bytes, Acc) ->
{Term,Remain} = dec_SignalStatusPackage(Bytes),
dec_components120(Num-1, Remain, [Term|Acc]).

dec_components121(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components121(Num, Bytes, Acc) ->
{Term,Remain} = dec_SignalStatusPackage_regional_RegionalExtension(Bytes),
dec_components121(Num-1, Remain, [Term|Acc]).

dec_components122(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components122(Num, Bytes, Acc) ->
{Term,Remain} = dec_SignalStatus_regional_RegionalExtension(Bytes),
dec_components122(Num-1, Remain, [Term|Acc]).

dec_components123(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components123(Num, Bytes, Acc) ->
{Term,Remain} = dec_RegulatorySpeedLimit(Bytes),
dec_components123(Num-1, Remain, [Term|Acc]).

dec_components124(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components124(Num, Bytes, Acc) ->
{Term,Remain} = begin
<<V5@V0:5,V5@Buf1/bitstring>> = Bytes,
{V5@V0,V5@Buf1}
end,
dec_components124(Num-1, Remain, [Term|Acc]).

dec_components125(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components125(Num, Bytes, Acc) ->
{Term,Remain} = dec_SupplementalVehicleExtensions_regional_RegionalExtension(Bytes),
dec_components125(Num-1, Remain, [Term|Acc]).

dec_components126(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components126(Num, Bytes, Acc) ->
{Term,Remain} = dec_TrailerHistoryPoint(Bytes),
dec_components126(Num-1, Remain, [Term|Acc]).

dec_components127(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components127(Num, Bytes, Acc) ->
{Term,Remain} = dec_TrailerUnitDescription(Bytes),
dec_components127(Num-1, Remain, [Term|Acc]).

dec_components128(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components128(Num, Bytes, Acc) ->
{Term,Remain} = dec_TravelerDataFrame(Bytes),
dec_components128(Num-1, Remain, [Term|Acc]).

dec_components129(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components129(Num, Bytes, Acc) ->
{Term,Remain} = dec_GeographicalPath(Bytes),
dec_components129(Num-1, Remain, [Term|Acc]).

dec_components130(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components130(Num, Bytes, Acc) ->
{Term,Remain} = dec_VehicleClassification_regional_RegionalExtension(Bytes),
dec_components130(Num-1, Remain, [Term|Acc]).

dec_components132(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components132(Num, Bytes, Acc) ->
{Term,Remain} = dec_VehicleStatusRequest(Bytes),
dec_components132(Num-1, Remain, [Term|Acc]).

dec_components14(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components14(Num, Bytes, Acc) ->
{Term,Remain} = dec_MapData_regional_RegionalExtension(Bytes),
dec_components14(Num-1, Remain, [Term|Acc]).

dec_components16(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components16(Num, Bytes, Acc) ->
{Term,Remain} = dec_NMEAcorrections_regional_RegionalExtension(Bytes),
dec_components16(Num-1, Remain, [Term|Acc]).

dec_components22(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components22(Num, Bytes, Acc) ->
{Term,Remain} = dec_PersonalSafetyMessage_regional_RegionalExtension(Bytes),
dec_components22(Num-1, Remain, [Term|Acc]).

dec_components24(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components24(Num, Bytes, Acc) ->
{Term,Remain} = dec_ProbeDataManagement_regional_RegionalExtension(Bytes),
dec_components24(Num-1, Remain, [Term|Acc]).

dec_components25(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components25(Num, Bytes, Acc) ->
{Term,Remain} = dec_Snapshot(Bytes),
dec_components25(Num-1, Remain, [Term|Acc]).

dec_components26(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components26(Num, Bytes, Acc) ->
{Term,Remain} = dec_ProbeVehicleData_regional_RegionalExtension(Bytes),
dec_components26(Num-1, Remain, [Term|Acc]).

dec_components27(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components27(Num, Bytes, Acc) ->
{Term,Remain} = begin
<<V6@V0:16,V6@Buf1/bitstring>> = Bytes,
{V6@V0,V6@Buf1}
end,
dec_components27(Num-1, Remain, [Term|Acc]).

dec_components28(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components28(Num, Bytes, Acc) ->
{Term,Remain} = dec_RoadSideAlert_regional_RegionalExtension(Bytes),
dec_components28(Num-1, Remain, [Term|Acc]).

dec_components29(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components29(Num, Bytes, Acc) ->
{Term,Remain} = dec_RTCMcorrections_regional_RegionalExtension(Bytes),
dec_components29(Num-1, Remain, [Term|Acc]).

dec_components30(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components30(Num, Bytes, Acc) ->
{Term,Remain} = dec_SPAT_regional_RegionalExtension(Bytes),
dec_components30(Num-1, Remain, [Term|Acc]).

dec_components31(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components31(Num, Bytes, Acc) ->
{Term,Remain} = dec_SignalRequestMessage_regional_RegionalExtension(Bytes),
dec_components31(Num-1, Remain, [Term|Acc]).

dec_components32(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components32(Num, Bytes, Acc) ->
{Term,Remain} = dec_SignalStatusMessage_regional_RegionalExtension(Bytes),
dec_components32(Num-1, Remain, [Term|Acc]).

dec_components33(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components33(Num, Bytes, Acc) ->
{Term,Remain} = dec_TravelerInformation_regional_RegionalExtension(Bytes),
dec_components33(Num-1, Remain, [Term|Acc]).

dec_components34(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components34(Num, Bytes, Acc) ->
{Term,Remain} = dec_AdvisorySpeed_regional_RegionalExtension(Bytes),
dec_components34(Num-1, Remain, [Term|Acc]).

dec_components35(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components35(Num, Bytes, Acc) ->
{Term,Remain} = dec_AdvisorySpeed(Bytes),
dec_components35(Num-1, Remain, [Term|Acc]).

dec_components37(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components37(Num, Bytes, Acc) ->
{Term,Remain} = dec_ComputedLane_regional_RegionalExtension(Bytes),
dec_components37(Num-1, Remain, [Term|Acc]).

dec_components40(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components40(Num, Bytes, Acc) ->
{Term,Remain} = dec_ConnectionManeuverAssist_regional_RegionalExtension(Bytes),
dec_components40(Num-1, Remain, [Term|Acc]).

dec_components42(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components42(Num, Bytes, Acc) ->
{Term,Remain} = dec_Connection(Bytes),
dec_components42(Num-1, Remain, [Term|Acc]).

dec_components43(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components43(Num, Bytes, Acc) ->
{Term,Remain} = begin
<<V7@V0:8,V7@Buf1/bitstring>> = Bytes,
{V7@V0,V7@Buf1}
end,
dec_components43(Num-1, Remain, [Term|Acc]).

dec_components44(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components44(Num, Bytes, Acc) ->
{Term,Remain} = begin
<<V8@V0:16,V8@Buf1/bitstring>> = Bytes,
{V8@V0,V8@Buf1}
end,
dec_components44(Num-1, Remain, [Term|Acc]).

dec_components45(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components45(Num, Bytes, Acc) ->
{Term,Remain} = dec_EventDescription_regional_RegionalExtension(Bytes),
dec_components45(Num-1, Remain, [Term|Acc]).

dec_components46(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components46(Num, Bytes, Acc) ->
{Term,Remain} = dec_GenericLane_regional_RegionalExtension(Bytes),
dec_components46(Num-1, Remain, [Term|Acc]).

dec_components47(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components47(Num, Bytes, Acc) ->
{Term,Remain} = dec_GeographicalPath_regional_RegionalExtension(Bytes),
dec_components47(Num-1, Remain, [Term|Acc]).

dec_components48(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components48(Num, Bytes, Acc) ->
{Term,Remain} = dec_GeometricProjection_regional_RegionalExtension(Bytes),
dec_components48(Num-1, Remain, [Term|Acc]).

dec_components49(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components49(Num, Bytes, Acc) ->
{Term,Remain} = dec_IntersectionGeometry_regional_RegionalExtension(Bytes),
dec_components49(Num-1, Remain, [Term|Acc]).

dec_components5(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components5(Num, Bytes, Acc) ->
{Term,Remain} = dec_BasicSafetyMessage_partII_PartIIcontent(Bytes),
dec_components5(Num-1, Remain, [Term|Acc]).

dec_components50(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components50(Num, Bytes, Acc) ->
{Term,Remain} = dec_IntersectionGeometry(Bytes),
dec_components50(Num-1, Remain, [Term|Acc]).

dec_components53(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components53(Num, Bytes, Acc) ->
{Term,Remain} = dec_IntersectionState_regional_RegionalExtension(Bytes),
dec_components53(Num-1, Remain, [Term|Acc]).

dec_components55(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components55(Num, Bytes, Acc) ->
{Term,Remain} = dec_IntersectionState(Bytes),
dec_components55(Num-1, Remain, [Term|Acc]).

dec_components56(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components56(Num, Bytes, Acc) ->
{Term,Remain} = dec_ExitService_SEQOF(Bytes),
dec_components56(Num-1, Remain, [Term|Acc]).

dec_components57(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components57(Num, Bytes, Acc) ->
{Term,Remain} = dec_GenericSignage_SEQOF(Bytes),
dec_components57(Num-1, Remain, [Term|Acc]).

dec_components58(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components58(Num, Bytes, Acc) ->
{Term,Remain} = dec_SpeedLimit_SEQOF(Bytes),
dec_components58(Num-1, Remain, [Term|Acc]).

dec_components59(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components59(Num, Bytes, Acc) ->
{Term,Remain} = dec_WorkZone_SEQOF(Bytes),
dec_components59(Num-1, Remain, [Term|Acc]).

dec_components60(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components60(Num, Bytes, Acc) ->
{Term,Remain} = dec_TireData(Bytes),
dec_components60(Num-1, Remain, [Term|Acc]).

dec_components61(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components61(Num, Bytes, Acc) ->
{Term,Remain} = dec_AxleWeightSet(Bytes),
dec_components61(Num-1, Remain, [Term|Acc]).

dec_components65(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components65(Num, Bytes, Acc) ->
{Term,Remain} = dec_LaneDataAttribute_regional_RegionalExtension(Bytes),
dec_components65(Num-1, Remain, [Term|Acc]).

dec_components67(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components67(Num, Bytes, Acc) ->
{Term,Remain} = dec_LaneDataAttribute(Bytes),
dec_components67(Num-1, Remain, [Term|Acc]).

dec_components68(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components68(Num, Bytes, Acc) ->
{Term,Remain} = dec_GenericLane(Bytes),
dec_components68(Num-1, Remain, [Term|Acc]).

dec_components7(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components7(Num, Bytes, Acc) ->
{Term,Remain} = dec_BasicSafetyMessage_regional_RegionalExtension(Bytes),
dec_components7(Num-1, Remain, [Term|Acc]).

dec_components77(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components77(Num, Bytes, Acc) ->
{Term,Remain} = dec_ConnectionManeuverAssist(Bytes),
dec_components77(Num-1, Remain, [Term|Acc]).

dec_components78(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components78(Num, Bytes, Acc) ->
{Term,Remain} = dec_MovementEvent(Bytes),
dec_components78(Num-1, Remain, [Term|Acc]).

dec_components80(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components80(Num, Bytes, Acc) ->
{Term,Remain} = dec_MovementEvent_regional_RegionalExtension(Bytes),
dec_components80(Num-1, Remain, [Term|Acc]).

dec_components82(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components82(Num, Bytes, Acc) ->
{Term,Remain} = dec_MovementState(Bytes),
dec_components82(Num-1, Remain, [Term|Acc]).

dec_components83(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components83(Num, Bytes, Acc) ->
{Term,Remain} = dec_MovementState_regional_RegionalExtension(Bytes),
dec_components83(Num-1, Remain, [Term|Acc]).

dec_components84(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components84(Num, Bytes, Acc) ->
{Term,Remain} = begin
{V9@V0,V9@Buf1} = case Bytes of
<<0:1,V9@V3:4,V9@Buf4/bitstring>> ->
V9@Int5 = case V9@V3 of
0 -> reserved;
1 -> stopLine;
2 -> roundedCapStyleA;
3 -> roundedCapStyleB;
4 -> mergePoint;
5 -> divergePoint;
6 -> downstreamStopLine;
7 -> downstreamStartNode;
8 -> closedToTraffic;
9 -> safeIsland;
10 -> curbPresentAtStepOff;
11 -> hydrantPresent;
_ -> exit({error,{asn1,{decode_enumerated,V9@V3}}})
end,
{V9@Int5,V9@Buf4};
<<1:1,V9@Buf2/bitstring>> ->
{V9@V3,V9@Buf4} = case V9@Buf2 of
<<0:1,V9@V6:6,V9@Buf7/bitstring>> ->
{V9@V6,V9@Buf7};
<<1:1,V9@Buf5/bitstring>> ->
{V9@V6,V9@Buf7} = case V9@Buf5 of
<<0:1,V9@V9:7,V9@Buf10/bitstring>> when V9@V9 =/= 0 ->
{V9@V9,V9@Buf10};
<<1:1,0:1,V9@V10:14,V9@Buf11/bitstring>> when V9@V10 =/= 0 ->
{V9@V10,V9@Buf11}
end,
<<V9@V12:V9@V6/unit:8,V9@Buf13/bitstring>> = V9@Buf7,
{V9@V12,V9@Buf13}
end,
V9@Int14 = case V9@V3 of
_ -> {asn1_enum,V9@V3}
end,
{V9@Int14,V9@Buf4}
end,
{V9@V0,V9@Buf1}
end,
dec_components84(Num-1, Remain, [Term|Acc]).

dec_components85(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components85(Num, Bytes, Acc) ->
{Term,Remain} = dec_NodeAttributeSetLL_regional_RegionalExtension(Bytes),
dec_components85(Num-1, Remain, [Term|Acc]).

dec_components86(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components86(Num, Bytes, Acc) ->
{Term,Remain} = dec_NodeAttributeSetXY_regional_RegionalExtension(Bytes),
dec_components86(Num-1, Remain, [Term|Acc]).

dec_components87(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components87(Num, Bytes, Acc) ->
{Term,Remain} = begin
{V10@V0,V10@Buf1} = case Bytes of
<<0:1,V10@V3:4,V10@Buf4/bitstring>> ->
V10@Int5 = case V10@V3 of
0 -> reserved;
1 -> stopLine;
2 -> roundedCapStyleA;
3 -> roundedCapStyleB;
4 -> mergePoint;
5 -> divergePoint;
6 -> downstreamStopLine;
7 -> downstreamStartNode;
8 -> closedToTraffic;
9 -> safeIsland;
10 -> curbPresentAtStepOff;
11 -> hydrantPresent;
_ -> exit({error,{asn1,{decode_enumerated,V10@V3}}})
end,
{V10@Int5,V10@Buf4};
<<1:1,V10@Buf2/bitstring>> ->
{V10@V3,V10@Buf4} = case V10@Buf2 of
<<0:1,V10@V6:6,V10@Buf7/bitstring>> ->
{V10@V6,V10@Buf7};
<<1:1,V10@Buf5/bitstring>> ->
{V10@V6,V10@Buf7} = case V10@Buf5 of
<<0:1,V10@V9:7,V10@Buf10/bitstring>> when V10@V9 =/= 0 ->
{V10@V9,V10@Buf10};
<<1:1,0:1,V10@V10:14,V10@Buf11/bitstring>> when V10@V10 =/= 0 ->
{V10@V10,V10@Buf11}
end,
<<V10@V12:V10@V6/unit:8,V10@Buf13/bitstring>> = V10@Buf7,
{V10@V12,V10@Buf13}
end,
V10@Int14 = case V10@V3 of
_ -> {asn1_enum,V10@V3}
end,
{V10@Int14,V10@Buf4}
end,
{V10@V0,V10@Buf1}
end,
dec_components87(Num-1, Remain, [Term|Acc]).

dec_components9(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components9(Num, Bytes, Acc) ->
{Term,Remain} = dec_CommonSafetyRequest_regional_RegionalExtension(Bytes),
dec_components9(Num-1, Remain, [Term|Acc]).

dec_components90(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components90(Num, Bytes, Acc) ->
{Term,Remain} = dec_NodeLL(Bytes),
dec_components90(Num-1, Remain, [Term|Acc]).

dec_components91(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components91(Num, Bytes, Acc) ->
{Term,Remain} = dec_NodeXY(Bytes),
dec_components91(Num-1, Remain, [Term|Acc]).

dec_components93(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components93(Num, Bytes, Acc) ->
{Term,Remain} = begin
<<V11@V0:8,V11@Buf1/bitstring>> = Bytes,
{V11@V0,V11@Buf1}
end,
dec_components93(Num-1, Remain, [Term|Acc]).

dec_components95(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components95(Num, Bytes, Acc) ->
{Term,Remain} = dec_PathHistoryPoint(Bytes),
dec_components95(Num-1, Remain, [Term|Acc]).

dec_components97(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components97(Num, Bytes, Acc) ->
{Term,Remain} = dec_Position3D_regional_RegionalExtension(Bytes),
dec_components97(Num-1, Remain, [Term|Acc]).

dec_components99(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components99(Num, Bytes, Acc) ->
{Term,Remain} = dec_SignalControlZone(Bytes),
dec_components99(Num-1, Remain, [Term|Acc]).

dec_os_Type109(Bytes, Id) when Id =:= 3 ->
{Term,_} = 'AddGrpC':'dec_RestrictionUserType-addGrpC'(Bytes),
Term;
dec_os_Type109(Bytes, Id) ->
{asn1_OPENTYPE,Bytes}.


dec_os_Type15(Bytes, Id) when Id =:= 3 ->
{Term,_} = 'AddGrpC':'dec_MapData-addGrpC'(Bytes),
Term;
dec_os_Type15(Bytes, Id) ->
{asn1_OPENTYPE,Bytes}.


dec_os_Type2(Bytes, Id) when Id =:= 18 ->
{Term,_} = dec_MapData(Bytes),
Term;
dec_os_Type2(Bytes, Id) when Id =:= 19 ->
{Term,_} = dec_SPAT(Bytes),
Term;
dec_os_Type2(Bytes, Id) when Id =:= 20 ->
{Term,_} = dec_BasicSafetyMessage(Bytes),
Term;
dec_os_Type2(Bytes, Id) when Id =:= 21 ->
{Term,_} = dec_CommonSafetyRequest(Bytes),
Term;
dec_os_Type2(Bytes, Id) when Id =:= 22 ->
{Term,_} = dec_EmergencyVehicleAlert(Bytes),
Term;
dec_os_Type2(Bytes, Id) when Id =:= 23 ->
{Term,_} = dec_IntersectionCollision(Bytes),
Term;
dec_os_Type2(Bytes, Id) when Id =:= 24 ->
{Term,_} = dec_NMEAcorrections(Bytes),
Term;
dec_os_Type2(Bytes, Id) when Id =:= 25 ->
{Term,_} = dec_ProbeDataManagement(Bytes),
Term;
dec_os_Type2(Bytes, Id) when Id =:= 26 ->
{Term,_} = dec_ProbeVehicleData(Bytes),
Term;
dec_os_Type2(Bytes, Id) when Id =:= 27 ->
{Term,_} = dec_RoadSideAlert(Bytes),
Term;
dec_os_Type2(Bytes, Id) when Id =:= 28 ->
{Term,_} = dec_RTCMcorrections(Bytes),
Term;
dec_os_Type2(Bytes, Id) when Id =:= 29 ->
{Term,_} = dec_SignalRequestMessage(Bytes),
Term;
dec_os_Type2(Bytes, Id) when Id =:= 30 ->
{Term,_} = dec_SignalStatusMessage(Bytes),
Term;
dec_os_Type2(Bytes, Id) when Id =:= 31 ->
{Term,_} = dec_TravelerInformation(Bytes),
Term;
dec_os_Type2(Bytes, Id) when Id =:= 32 ->
{Term,_} = dec_PersonalSafetyMessage(Bytes),
Term;
dec_os_Type2(Bytes, Id) when Id =:= 240 ->
{Term,_} = dec_TestMessage00(Bytes),
Term;
dec_os_Type2(Bytes, Id) when Id =:= 241 ->
{Term,_} = dec_TestMessage01(Bytes),
Term;
dec_os_Type2(Bytes, Id) when Id =:= 242 ->
{Term,_} = dec_TestMessage02(Bytes),
Term;
dec_os_Type2(Bytes, Id) when Id =:= 243 ->
{Term,_} = dec_TestMessage03(Bytes),
Term;
dec_os_Type2(Bytes, Id) when Id =:= 244 ->
{Term,_} = dec_TestMessage04(Bytes),
Term;
dec_os_Type2(Bytes, Id) when Id =:= 245 ->
{Term,_} = dec_TestMessage05(Bytes),
Term;
dec_os_Type2(Bytes, Id) when Id =:= 246 ->
{Term,_} = dec_TestMessage06(Bytes),
Term;
dec_os_Type2(Bytes, Id) when Id =:= 247 ->
{Term,_} = dec_TestMessage07(Bytes),
Term;
dec_os_Type2(Bytes, Id) when Id =:= 248 ->
{Term,_} = dec_TestMessage08(Bytes),
Term;
dec_os_Type2(Bytes, Id) when Id =:= 249 ->
{Term,_} = dec_TestMessage09(Bytes),
Term;
dec_os_Type2(Bytes, Id) when Id =:= 250 ->
{Term,_} = dec_TestMessage10(Bytes),
Term;
dec_os_Type2(Bytes, Id) when Id =:= 251 ->
{Term,_} = dec_TestMessage11(Bytes),
Term;
dec_os_Type2(Bytes, Id) when Id =:= 252 ->
{Term,_} = dec_TestMessage12(Bytes),
Term;
dec_os_Type2(Bytes, Id) when Id =:= 253 ->
{Term,_} = dec_TestMessage13(Bytes),
Term;
dec_os_Type2(Bytes, Id) when Id =:= 254 ->
{Term,_} = dec_TestMessage14(Bytes),
Term;
dec_os_Type2(Bytes, Id) when Id =:= 255 ->
{Term,_} = dec_TestMessage15(Bytes),
Term;
dec_os_Type2(Bytes, Id) ->
{asn1_OPENTYPE,Bytes}.


dec_os_Type41(Bytes, Id) when Id =:= 3 ->
{Term,_} = 'AddGrpC':'dec_ConnectionManeuverAssist-addGrpC'(Bytes),
Term;
dec_os_Type41(Bytes, Id) ->
{asn1_OPENTYPE,Bytes}.


dec_os_Type54(Bytes, Id) when Id =:= 3 ->
{Term,_} = 'AddGrpC':'dec_IntersectionState-addGrpC'(Bytes),
Term;
dec_os_Type54(Bytes, Id) ->
{asn1_OPENTYPE,Bytes}.


dec_os_Type6(Bytes, Id) when Id =:= 0 ->
{Term,_} = dec_VehicleSafetyExtensions(Bytes),
Term;
dec_os_Type6(Bytes, Id) when Id =:= 1 ->
{Term,_} = dec_SpecialVehicleExtensions(Bytes),
Term;
dec_os_Type6(Bytes, Id) when Id =:= 2 ->
{Term,_} = dec_SupplementalVehicleExtensions(Bytes),
Term;
dec_os_Type6(Bytes, Id) ->
{asn1_OPENTYPE,Bytes}.


dec_os_Type66(Bytes, Id) when Id =:= 2 ->
{Term,_} = 'AddGrpB':'dec_LaneDataAttribute-addGrpB'(Bytes),
Term;
dec_os_Type66(Bytes, Id) ->
{asn1_OPENTYPE,Bytes}.


dec_os_Type8(Bytes, Id) ->
{asn1_OPENTYPE,Bytes}.


dec_os_Type81(Bytes, Id) when Id =:= 2 ->
{Term,_} = 'AddGrpB':'dec_MovementEvent-addGrpB'(Bytes),
Term;
dec_os_Type81(Bytes, Id) ->
{asn1_OPENTYPE,Bytes}.


dec_os_Type89(Bytes, Id) when Id =:= 2 ->
{Term,_} = 'AddGrpB':'dec_NodeOffsetPointXY-addGrpB'(Bytes),
Term;
dec_os_Type89(Bytes, Id) ->
{asn1_OPENTYPE,Bytes}.


dec_os_Type98(Bytes, Id) when Id =:= 2 ->
{Term,_} = 'AddGrpB':'dec_Position3D-addGrpB'(Bytes),
Term;
dec_os_Type98(Bytes, Id) when Id =:= 3 ->
{Term,_} = 'AddGrpC':'dec_Position3D-addGrpC'(Bytes),
Term;
dec_os_Type98(Bytes, Id) ->
{asn1_OPENTYPE,Bytes}.


enc_os_Type1(Val, Id) ->
if Id =:= 18 ->
enc_MapData(Val);
Id =:= 19 ->
enc_SPAT(Val);
Id =:= 20 ->
enc_BasicSafetyMessage(Val);
Id =:= 21 ->
enc_CommonSafetyRequest(Val);
Id =:= 22 ->
enc_EmergencyVehicleAlert(Val);
Id =:= 23 ->
enc_IntersectionCollision(Val);
Id =:= 24 ->
enc_NMEAcorrections(Val);
Id =:= 25 ->
enc_ProbeDataManagement(Val);
Id =:= 26 ->
enc_ProbeVehicleData(Val);
Id =:= 27 ->
enc_RoadSideAlert(Val);
Id =:= 28 ->
enc_RTCMcorrections(Val);
Id =:= 29 ->
enc_SignalRequestMessage(Val);
Id =:= 30 ->
enc_SignalStatusMessage(Val);
Id =:= 31 ->
enc_TravelerInformation(Val);
Id =:= 32 ->
enc_PersonalSafetyMessage(Val);
Id =:= 240 ->
enc_TestMessage00(Val);
Id =:= 241 ->
enc_TestMessage01(Val);
Id =:= 242 ->
enc_TestMessage02(Val);
Id =:= 243 ->
enc_TestMessage03(Val);
Id =:= 244 ->
enc_TestMessage04(Val);
Id =:= 245 ->
enc_TestMessage05(Val);
Id =:= 246 ->
enc_TestMessage06(Val);
Id =:= 247 ->
enc_TestMessage07(Val);
Id =:= 248 ->
enc_TestMessage08(Val);
Id =:= 249 ->
enc_TestMessage09(Val);
Id =:= 250 ->
enc_TestMessage10(Val);
Id =:= 251 ->
enc_TestMessage11(Val);
Id =:= 252 ->
enc_TestMessage12(Val);
Id =:= 253 ->
enc_TestMessage13(Val);
Id =:= 254 ->
enc_TestMessage14(Val);
Id =:= 255 ->
enc_TestMessage15(Val);
true ->
open_type_to_binary(Val)
end.

enc_os_Type107(Val, Id) ->
if Id =:= 3 ->
'AddGrpC':'enc_RestrictionUserType-addGrpC'(Val);
true ->
open_type_to_binary(Val)
end.

enc_os_Type13(Val, Id) ->
if Id =:= 3 ->
'AddGrpC':'enc_MapData-addGrpC'(Val);
true ->
open_type_to_binary(Val)
end.

enc_os_Type3(Val, Id) ->
if Id =:= 0 ->
enc_VehicleSafetyExtensions(Val);
Id =:= 1 ->
enc_SpecialVehicleExtensions(Val);
Id =:= 2 ->
enc_SupplementalVehicleExtensions(Val);
true ->
open_type_to_binary(Val)
end.

enc_os_Type39(Val, Id) ->
if Id =:= 3 ->
'AddGrpC':'enc_ConnectionManeuverAssist-addGrpC'(Val);
true ->
open_type_to_binary(Val)
end.

enc_os_Type4(Val, Id) ->
open_type_to_binary(Val).

enc_os_Type52(Val, Id) ->
if Id =:= 3 ->
'AddGrpC':'enc_IntersectionState-addGrpC'(Val);
true ->
open_type_to_binary(Val)
end.

enc_os_Type64(Val, Id) ->
if Id =:= 2 ->
'AddGrpB':'enc_LaneDataAttribute-addGrpB'(Val);
true ->
open_type_to_binary(Val)
end.

enc_os_Type79(Val, Id) ->
if Id =:= 2 ->
'AddGrpB':'enc_MovementEvent-addGrpB'(Val);
true ->
open_type_to_binary(Val)
end.

enc_os_Type88(Val, Id) ->
if Id =:= 2 ->
'AddGrpB':'enc_NodeOffsetPointXY-addGrpB'(Val);
true ->
open_type_to_binary(Val)
end.

enc_os_Type96(Val, Id) ->
if Id =:= 2 ->
'AddGrpB':'enc_Position3D-addGrpB'(Val);
Id =:= 3 ->
'AddGrpC':'enc_Position3D-addGrpC'(Val);
true ->
open_type_to_binary(Val)
end.

adjust_trailing_zeroes(Bs0, Lb) ->
    case bit_size(Bs0) of
        Sz when Sz < Lb ->
            <<Bs0:Sz/bits,0:(Lb - Sz)>>;
        Lb ->
            Bs0;
        _ ->
            <<_:Lb/bits,Tail/bits>> = Bs0,
            Sz = Lb + bit_size(bs_drop_trailing_zeroes(Tail)),
            <<Bs:Sz/bits,_/bits>> = Bs0,
            Bs
    end.

bitstring_from_positions(L0, Lb) ->
    L1 = lists:sort(L0),
    L = diff(L1, - 1, Lb - 1),
    << 
      <<B:(N + 0)>> ||
          {B, N} <- L
    >>.

bs_drop_trailing_zeroes(Bs) ->
    bs_drop_trailing_zeroes(Bs, bit_size(Bs)).

bs_drop_trailing_zeroes(Bs, 0) ->
    Bs;
bs_drop_trailing_zeroes(Bs0, Sz0) when Sz0 < 8 ->
    <<Byte:Sz0>> = Bs0,
    Sz = Sz0 - ntz(Byte),
    <<Bs:Sz/bits,_/bits>> = Bs0,
    Bs;
bs_drop_trailing_zeroes(Bs0, Sz0) ->
    Sz1 = Sz0 - 8,
    <<Bs1:Sz1/bits,Byte:8>> = Bs0,
    case ntz(Byte) of
        8 ->
            bs_drop_trailing_zeroes(Bs1, Sz1);
        Ntz ->
            Sz = Sz0 - Ntz,
            <<Bs:Sz/bits,_:Ntz/bits>> = Bs0,
            Bs
    end.

complete(InList) when is_list(InList) ->
    case list_to_bitstring(InList) of
        <<>> ->
            <<0>>;
        Res ->
            Sz = bit_size(Res),
            case Sz band 7 of
                0 ->
                    Res;
                Bits ->
                    <<Res:Sz/bitstring,0:(8 - Bits)>>
            end
    end;
complete(Bin) when is_binary(Bin) ->
    case Bin of
        <<>> ->
            <<0>>;
        _ ->
            Bin
    end;
complete(InList) when is_bitstring(InList) ->
    Sz = bit_size(InList),
    PadLen = 8 - Sz band 7,
    <<InList:Sz/bitstring,0:PadLen>>.

decode_chars(Val, N) ->
    [ 
     C ||
         <<C:N>> <= Val
    ].

decode_fragmented(SegSz0, Buf0, Unit) ->
    SegSz = SegSz0 * Unit * 16384,
    <<Res:SegSz/bitstring,Buf/bitstring>> = Buf0,
    decode_fragmented_1(Buf, Unit, Res).

decode_fragmented_1(<<0:1,N:7,Buf0/bitstring>>, Unit, Res) ->
    Sz = N * Unit,
    <<S:Sz/bitstring,Buf/bitstring>> = Buf0,
    {<<Res/bitstring,S/bitstring>>, Buf};
decode_fragmented_1(<<1:1,0:1,N:14,Buf0/bitstring>>, Unit, Res) ->
    Sz = N * Unit,
    <<S:Sz/bitstring,Buf/bitstring>> = Buf0,
    {<<Res/bitstring,S/bitstring>>, Buf};
decode_fragmented_1(<<1:1,1:1,SegSz0:6,Buf0/bitstring>>, Unit, Res0) ->
    SegSz = SegSz0 * Unit * 16384,
    <<Frag:SegSz/bitstring,Buf/bitstring>> = Buf0,
    Res = <<Res0/bitstring,Frag/bitstring>>,
    decode_fragmented_1(Buf, Unit, Res).

decode_length(<<0:1,Oct:7,Rest/bitstring>>) ->
    {Oct, Rest};
decode_length(<<2:2,Val:14,Rest/bitstring>>) ->
    {Val, Rest};
decode_length(<<3:2,_:14,_Rest/bitstring>>) ->
    exit({error, {asn1, {decode_length, {nyi, above_16k}}}}).

decode_named_bit_string(Val, NNL) ->
    Bits =
        [ 
         B ||
             <<B:1>> <= Val
        ],
    decode_named_bit_string_1(0, Bits, NNL, []).

decode_named_bit_string_1(Pos, [0 | Bt], Names, Acc) ->
    decode_named_bit_string_1(Pos + 1, Bt, Names, Acc);
decode_named_bit_string_1(Pos, [1 | Bt], Names, Acc) ->
    case lists:keyfind(Pos, 2, Names) of
        {Name, _} ->
            decode_named_bit_string_1(Pos + 1, Bt, Names, [Name | Acc]);
        false ->
            decode_named_bit_string_1(Pos + 1,
                                      Bt, Names,
                                      [{bit, Pos} | Acc])
    end;
decode_named_bit_string_1(_Pos, [], _Names, Acc) ->
    lists:reverse(Acc).

diff([H | T], Prev, Last) ->
    [{1, H - Prev} | diff(T, H, Last)];
diff([], Prev, Last) when Last >= Prev ->
    [{0, Last - Prev}];
diff([], _, _) ->
    [].

encode_chars(Val, NumBits) ->
    << 
      <<C:NumBits>> ||
          C <- Val
    >>.

encode_fragmented(Bin, Unit) ->
    encode_fragmented_1(Bin, Unit, 4).

encode_fragmented_1(Bin, Unit, N) ->
    SegSz = Unit * N * 16384,
    case Bin of
        <<B:SegSz/bitstring,T/bitstring>> ->
            [<<3:2,N:6>>, B | encode_fragmented_1(T, Unit, N)];
        _ when N > 1 ->
            encode_fragmented_1(Bin, Unit, N - 1);
        _ ->
            case bit_size(Bin) div Unit of
                Len when Len < 128 ->
                    [Len, Bin];
                Len when Len < 16384 ->
                    [<<2:2,Len:14>>, Bin]
            end
    end.

ntz(Byte) ->
    T = {8, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2,
         0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0,
         1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1,
         0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0,
         2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3,
         0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0,
         1, 0, 7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1,
         0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0,
         3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2,
         0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0,
         1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1,
         0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0,
         2, 0, 1, 0},
    element(Byte + 1, T).

open_type_to_binary({asn1_OPENTYPE, Bin}) when is_binary(Bin) ->
    Bin.

skipextensions(Bytes0, Nr, ExtensionBitstr)
    when is_bitstring(ExtensionBitstr) ->
    Prev = Nr - 1,
    case ExtensionBitstr of
        <<_:Prev,1:1,_/bitstring>> ->
            {Len, Bytes1} = decode_length(Bytes0),
            <<_:Len/binary,Bytes2/bitstring>> = Bytes1,
            skipextensions(Bytes2, Nr + 1, ExtensionBitstr);
        <<_:Prev,0:1,_/bitstring>> ->
            skipextensions(Bytes0, Nr + 1, ExtensionBitstr);
        _ ->
            Bytes0
    end.
