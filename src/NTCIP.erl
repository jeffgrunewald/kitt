%% Generated by the Erlang ASN.1 PER (unaligned) compiler. Version: 5.0.9
%% Purpose: Encoding and decoding of the types in NTCIP.

-module('NTCIP').
-compile(nowarn_unused_vars).
-dialyzer(no_improper_lists).
-asn1_info([{vsn,'5.0.9'},
            {module,'NTCIP'},
            {options,[{i,"src"},maps,uper,noobj,{outdir,"src"},{i,"."},{i,"asn1"}]}]).

-export([encoding_rule/0,maps/0,bit_string_format/0,
         legacy_erlang_types/0]).
-export(['dialyzer-suppressions'/1]).
-export([
enc_EssMobileFriction/1,
enc_EssPrecipRate/1,
enc_EssPrecipSituation/1,
enc_EssPrecipYesNo/1,
enc_EssSolarRadiation/1
]).

-export([
dec_EssMobileFriction/1,
dec_EssPrecipRate/1,
dec_EssPrecipSituation/1,
dec_EssPrecipYesNo/1,
dec_EssSolarRadiation/1
]).

-export([info/0]).

-export([encode/2,decode/2]).

encoding_rule() -> uper.

maps() -> true.

bit_string_format() -> bitstring.

legacy_erlang_types() -> false.

encode(Type, Data) ->
try complete(encode_disp(Type, Data)) of
  Bytes ->
    {ok,Bytes}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.

decode(Type, Data) ->
try
   {Result,_Rest} = decode_disp(Type, Data),
   {ok,Result}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.

encode_disp('EssMobileFriction', Data) -> enc_EssMobileFriction(Data);
encode_disp('EssPrecipRate', Data) -> enc_EssPrecipRate(Data);
encode_disp('EssPrecipSituation', Data) -> enc_EssPrecipSituation(Data);
encode_disp('EssPrecipYesNo', Data) -> enc_EssPrecipYesNo(Data);
encode_disp('EssSolarRadiation', Data) -> enc_EssSolarRadiation(Data);
encode_disp(Type, _Data) -> exit({error,{asn1,{undefined_type,Type}}}).

decode_disp('EssMobileFriction', Data) -> dec_EssMobileFriction(Data);
decode_disp('EssPrecipRate', Data) -> dec_EssPrecipRate(Data);
decode_disp('EssPrecipSituation', Data) -> dec_EssPrecipSituation(Data);
decode_disp('EssPrecipYesNo', Data) -> dec_EssPrecipYesNo(Data);
decode_disp('EssSolarRadiation', Data) -> dec_EssSolarRadiation(Data);
decode_disp(Type, _Data) -> exit({error,{asn1,{undefined_type,Type}}}).

info() ->
   case ?MODULE:module_info(attributes) of
     Attributes when is_list(Attributes) ->
       case lists:keyfind(asn1_info, 1, Attributes) of
         {_,Info} when is_list(Info) ->
           Info;
         _ ->
           []
       end;
     _ ->
       []
   end.
enc_EssMobileFriction(Val) ->
if 0 =< Val, Val < 102 ->
<<Val:7>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_EssMobileFriction(Bytes) ->
begin
<<V1@V0:7,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_EssPrecipRate(Val) ->
if Val bsr 16 =:= 0 ->
<<Val:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_EssPrecipRate(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_EssPrecipSituation(Val) ->
if Val =:= other ->
<<0:4>>;
Val =:= unknown ->
<<1:4>>;
Val =:= noPrecipitation ->
<<2:4>>;
Val =:= unidentifiedSlight ->
<<3:4>>;
Val =:= unidentifiedModerate ->
<<4:4>>;
Val =:= unidentifiedHeavy ->
<<5:4>>;
Val =:= snowSlight ->
<<6:4>>;
Val =:= snowModerate ->
<<7:4>>;
Val =:= snowHeavy ->
<<8:4>>;
Val =:= rainSlight ->
<<9:4>>;
Val =:= rainModerate ->
<<10:4>>;
Val =:= rainHeavy ->
<<11:4>>;
Val =:= frozenPrecipitationSlight ->
<<12:4>>;
Val =:= frozenPrecipitationModerate ->
<<13:4>>;
Val =:= frozenPrecipitationHeavy ->
<<14:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_EssPrecipSituation(Bytes) ->
begin
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> other;
1 -> unknown;
2 -> noPrecipitation;
3 -> unidentifiedSlight;
4 -> unidentifiedModerate;
5 -> unidentifiedHeavy;
6 -> snowSlight;
7 -> snowModerate;
8 -> snowHeavy;
9 -> rainSlight;
10 -> rainModerate;
11 -> rainHeavy;
12 -> frozenPrecipitationSlight;
13 -> frozenPrecipitationModerate;
14 -> frozenPrecipitationHeavy;
_ -> exit({error,{asn1,{decode_enumerated,V1@V0}}})
end,
{V1@Int2,V1@Buf1}
end.

enc_EssPrecipYesNo(Val) ->
if Val =:= precip ->
<<0:2>>;
Val =:= noPrecip ->
<<1:2>>;
Val =:= error ->
<<2:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_EssPrecipYesNo(Bytes) ->
begin
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> precip;
1 -> noPrecip;
2 -> error;
_ -> exit({error,{asn1,{decode_enumerated,V1@V0}}})
end,
{V1@Int2,V1@Buf1}
end.

enc_EssSolarRadiation(Val) ->
if Val bsr 16 =:= 0 ->
<<Val:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_EssSolarRadiation(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.


%%%
%%% Run-time functions.
%%%

'dialyzer-suppressions'(Arg) ->
    complete(element(1, Arg)),
    ok.

complete(InList) when is_list(InList) ->
    case list_to_bitstring(InList) of
        <<>> ->
            <<0>>;
        Res ->
            Sz = bit_size(Res),
            case Sz band 7 of
                0 ->
                    Res;
                Bits ->
                    <<Res:Sz/bitstring,0:(8 - Bits)>>
            end
    end;
complete(Bin) when is_binary(Bin) ->
    case Bin of
        <<>> ->
            <<0>>;
        _ ->
            Bin
    end;
complete(InList) when is_bitstring(InList) ->
    Sz = bit_size(InList),
    PadLen = 8 - Sz band 7,
    <<InList:Sz/bitstring,0:PadLen>>.
